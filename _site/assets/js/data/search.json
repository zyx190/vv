[
  
  {
    "title": "《机器学习》——集成学习",
    "url": "/posts/ml-%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/",
    "categories": "人工智能, 机器学习",
    "tags": "人工智能, 机器学习, 集成学习",
    "date": "2024-07-01 15:02:00 +0800",
    





    
    "snippet": "个体与集成集成学习将多个个体学习器的学习结果通过某种策略结合起来，每个个体学习器可以使用相同的学习算法，称为基学习器，也可以使用不同的学习算法集成学习通常针对弱学习器进行，个体学习器应该有一定的准确性和多样性，相互之间应该尽可能独立，这是集成学习研究的核心集成学习方法可分为两类  序列化方法：个体学习器之间强依赖关系，必须串行生成，如Boosting  并行化方法：个体学习器之间不存在强依赖...",
    "content": "个体与集成集成学习将多个个体学习器的学习结果通过某种策略结合起来，每个个体学习器可以使用相同的学习算法，称为基学习器，也可以使用不同的学习算法集成学习通常针对弱学习器进行，个体学习器应该有一定的准确性和多样性，相互之间应该尽可能独立，这是集成学习研究的核心集成学习方法可分为两类  序列化方法：个体学习器之间强依赖关系，必须串行生成，如Boosting  并行化方法：个体学习器之间不存在强依赖关系，可同时生成，如Bagging和随机森林BoostingBoosting是一类可将弱学习器提升到强学习器的算法，基本流程是先训练出一个基学习器，根据基学习器的表现对样本分布进行调整，使做错的样本收到更多关注，基于调整后的样本来训练下一个基学习器，直到训练出T个学习器，将T个学习器加权结合Boosting算法中最著名的是AdaBoost算法Boosting算法要求基学习器能对特定的数据分布进行学习，这可通过重赋权法实施，即在训练过程的每一轮中，根据样本分布为每个训练样本重新赋予一个权重对无法接受带权样本的基学习算法，则可通过重采样法来处理，即在每一轮学习中，根据样本分布对训练集重新进行采样，再用重采样而得的样本集对基学习器进行训练BaggingBagging基于自主采样法，对训练集进行m次有放回随机采样，产生一个采样集，采样出T个采样集，基于这些采样集训练出T个基学习器，再将基学习器进行结合，对于分类任务，通常使用简单投票法结合，对于回归任务，通常使用简单平均法结合随机森林在以决策树作为基学习器的Bagging算法的基础上，加入随机属性选择，形成了随机森林算法一般决策树在属性集中直接选择一个最优属性进行划分，随机森林中首先随机选择出一个包含k个属性的属性集，在该属性集中选择最优属性进行划分，当$k=d$时，与一般决策树相同，当$k=1$时，则随机选择一个属性进行划分，一般情况下，设置$k=\\log_2d$结合策略对于T个学习器的输出${h_1,h_2,…,h_T}$，有以下常见方法将它们结合起来平均法  简单平均法：$H(x)={1\\over T}\\sum\\limits_{i=1}^Th_i(x)$  加权平均法：$H(x)={1\\over T}\\sum\\limits_{i=1}^T\\omega_ih_i(x)$，通常要求$\\sum\\limits_{i=1}^T\\omega_i=1,\\omega_i\\ge0$简单平均法的性能未必弱于加权平均法，通常来说，个体学习器的性能相近时采用简单平均法，个体学习器的性能差距较大时采用加权平均法投票法对于一个学习器，它可能在多个类别上投票，输出表示为一个N维向量$(h_i^1(x);h_i^2(x);…;h_i^N(x))$  绝对多数投票法：若某个类别的投票数超过总票数一半，则预测为该类  相对多数投票法：预测为得票最多的类别，若有多个类别得票最高，则随机选择一个  加权投票法：对每个学习器的投票设置权重，预测为得票最多的类别学习器的输出$h_i^j(x)$有以下两种，不同类型的输出不能混用  类标记：直接输出类别的标记值，称为硬投票  类概率：输出样本预测为某个类别的概率值，称为软投票学习法使用另一个学习器进行结合，典型代表有Stacking算法，Stacking算法中基学习器称为初级学习器，结合学习器称为次级学习器Stacking算法先从初始训练集中训练出初始学习器，然后将所有初始学习器的输出作为次级学习器的输入，初始标记依然作为次级学习器的标记当初级学习器输出为类概率，次级学习器使用多响应线性回归（MLR）时，效果较好多样性误差-分歧分解误差-分歧分解公式，说明了个体学习器的准确性越高、多样性越大，集成性能越好\\[E=\\bar E-\\bar A\\]其中$E$为集成泛化误差，$\\bar E$为个体学习器的泛化误差的加权均值，$\\bar A$为个体学习器的加权分歧值分歧值表征了个体学习器在样本上的不一致性，反映了个体学习器的多样性多样性度量对于两个分类器，度量它们的多样性，典型做法是度量它们的相似度设共有m个样本，构造两个分类器预测结果的列联表      不合度量：$dis_{ij}=\\frac{b+c}{m}$，值越大，多样性越大        相关系数：$\\rho_{ij}=\\frac{ad-bc}{\\sqrt{(a+c)(a+b)(c+d)(b+d)}}$        Q-统计量：$Q_{ij}=\\frac{ad-bc}{ad+bc}$        $\\kappa$-统计量：$\\kappa=\\frac{p_1-p_2}{1-p_2}$    $p_1$为结果一致的概率，$p_2$为结果偶然一致的概率，$p_1={a+d\\over m},p_2={(a+b)(a+c)+(c+d)(b+d)\\over m^2}$  多样性增强多样性增强通常的做法是引入随机因素，对样本、输入属性、输出表示、参数进行扰动  样本扰动：基于采样法，对于不稳定的学习器有显著效果  输入属性扰动：每一个属性子集可以看做观察样本的不同视角，因此采用不同的属性子集可以训练出具有多样性的基学习器  输出表示扰动：对模型的输出表示进行处理，如随机改变一些样本的标记，或者对分类输出转化为回归输出  算法参数扰动：通过随机设置不同的参数训练出多样性较大的基学习器"
  },
  
  {
    "title": "《机器学习》——贝叶斯分类器",
    "url": "/posts/ml-%E8%B4%9D%E5%8F%B6%E6%96%AF/",
    "categories": "人工智能, 机器学习",
    "tags": "人工智能, 机器学习, 贝叶斯分类器",
    "date": "2024-06-29 21:16:00 +0800",
    





    
    "snippet": "贝叶斯决策论贝叶斯判定准则：为最小化总体风险，只需在每个样本上选择那个能使条件风险最小的类别标记\\[h^*(x)=\\arg\\min\\limits_{c\\in\\Upsilon}R(c\\vert x)\\]$h^*(x)$称为贝叶斯最优分类器，对应的总体风险称为贝叶斯风险贝叶斯判定准则基于后验概率$P(c\\vert x)$，根据贝叶斯定理有\\[P(c\\vert x)=\\frac{P(c)P(x\\v...",
    "content": "贝叶斯决策论贝叶斯判定准则：为最小化总体风险，只需在每个样本上选择那个能使条件风险最小的类别标记\\[h^*(x)=\\arg\\min\\limits_{c\\in\\Upsilon}R(c\\vert x)\\]$h^*(x)$称为贝叶斯最优分类器，对应的总体风险称为贝叶斯风险贝叶斯判定准则基于后验概率$P(c\\vert x)$，根据贝叶斯定理有\\[P(c\\vert x)=\\frac{P(c)P(x\\vert c)}{P(x)}\\]其中$P(c)$可以根据各类样本出现的频率进行估计极大似然估计估计类条件概率$P(x\\vert c)$的常用策略是先假定其具有某种确定的概率分布，再基于训练样本对概率分布的参数进行估计令$D_c$为训练集D中第c类样本的集合\\[\\begin{aligned}P(D_c\\vert\\theta_c)&amp;=\\prod\\limits_{x\\in D_c}P(x\\vert\\theta_c)\\\\L(\\theta_c)&amp;=\\ln P(D_c\\vert\\theta_c)=\\sum\\limits_{x\\in D_c}\\ln P(x\\vert\\theta_c)\\\\\\hat\\theta_c&amp;=\\arg\\max\\limits_{\\theta_c}L(\\theta_c)\\end{aligned}\\]朴素贝叶斯分类器朴素贝叶斯分类器假设所有属性相互独立，则有\\[\\begin{aligned}P(c\\vert x)&amp;=\\frac{P(c)P(x\\vert c)}{P(x)}=\\frac{P(c)}{P(x)}\\prod\\limits_{i=1}^dP(x_i\\vert c)\\\\h_{nb}(x)&amp;=\\arg\\max\\limits_{c\\in\\Upsilon}P(c)\\prod\\limits_{i=1}^dP(x_i\\vert c)\\end{aligned}\\]当某个属性值在训练集中没有与某个类同时出现过，即使通过其他属性可以判定为正类，依然会被判为负类，此时需要进行拉普拉斯修正\\[\\begin{aligned}P(c)&amp;=\\frac{\\vert D_c\\vert+1}{\\vert D\\vert+N}\\\\P(x_i\\vert c)&amp;=\\frac{\\vert D_{c,x_i}\\vert+1}{\\vert D_c\\vert+N_i}\\end{aligned}\\]半朴素贝叶斯分类器半朴素贝叶斯分类器与朴素贝叶斯不同在于不需要要求属性之间全部相互独立，适当考虑一部分强相关的属性依赖属性之间的依赖关系可以构建出树或者图，从而使用相关的算法来选择属性依赖独依赖估计（ODE）是半朴素贝叶斯分类器最常用的一种策略，它假设每个属性在类别之外最多仅依赖于一个其他属性\\[P(c\\vert x)\\propto P(c)\\prod\\limits_{i=1}^dP(x_i\\vert c,pa_i)\\]SPODE算法假设所有属性都依赖于同一个属性，再通过交叉验证等模型选择方法来确定超父属性TAN算法在属性依赖构成的树结构上，使用最大生成树算法，选择强相关的属性依赖AODE是一种基于集成学习机制、更为强大的独依赖分类器，它尝试将每个属性都作为超父来构建SPODE，最后将那些具有足够训练数据支撑的SPODE集成起来作为最终结果贝叶斯网贝叶斯网借助DAG图来描述属性之间的依赖关系，使用条件概率表来描述属性间的联合概率分布结构贝叶斯网中有三种典型的结构，分别是同父结构、V型结构和顺序结构使用有向分离来分析贝叶斯网  找出图中所有的V型结构，在V型结构的两个父节点之间加上一条无向边  将所有的有向边改为无向边经过以上处理产生的无向图称为道德图，该过程称为道德化在道德图中，若节点x和y能被z分开，即去除z节点后，x和y属于两个连通分支，则称属性x和y被z有向分离学习若网络结构已知，则只需对训练样本计数，估计出每个节点的条件概率即可，因此在学习之前，首先要找到结构最合适的贝叶斯网，使用评分搜索来解决这个问题，定义一个评分函数，评估贝叶斯网和训练集的契合程度，基于这个评分函数来寻找结构最优的贝叶斯网常用的评分函数基于信息论的准则，寻找一个能与数据契合的长度最短的编码，定义评分函数为以下形式\\[\\begin{aligned}s(B\\vert D)&amp;=f(\\theta)\\vert B\\vert-LL(B\\vert D)\\\\LL(B\\vert D)&amp;=\\sum\\limits_{i=1}^m\\log P_B(x_i)\\end{aligned}\\]其中，$\\vert B\\vert$表示贝叶斯网B的参数个数，$f(\\theta)$表示描述每个参数$\\theta$所需的编码位数当$f(\\theta)=1$，函数称为AIC评分函数，当$f(\\theta)={1\\over2}\\log m$，函数称为BIC评分函数推断直接根据贝叶斯网定义的联合概率分布来精确计算后验概率是一个NP难问题，通常使用吉布斯采样来求得近似解设经过T次采样得到与q一致的样本共有$n_q$个，则估计后验概率为\\[P(Q=q\\vert E=e)\\simeq\\frac{n_q}{T}\\]吉布斯采样的每一步依赖于前一步的状态，这是一个马尔可夫链，在一定条件下，在$t\\rightarrow\\infty$时必收敛于一个平稳分布EM算法EM算法用于估计参数隐变量，即在样本属性存在缺失值时进行参数估计以参数初始值$\\Theta_0$为起点，迭代以下步骤直到收敛  E步：基于$\\Theta^t$推断隐变量Z的期望，记为$Z^t$  M步：基于已观测变量$X$和$Z^t$对参数$\\Theta$做极大似然估计，记为$\\Theta^{t+1}$"
  },
  
  {
    "title": "《机器学习》——神经网络",
    "url": "/posts/ml-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/",
    "categories": "人工智能, 机器学习",
    "tags": "人工智能, 机器学习, 神经网络",
    "date": "2024-06-21 17:08:00 +0800",
    





    
    "snippet": "神经元模型感知机与多层网络感知机由两层神经元组成，包含输入层和输出层，只有输出层拥有激活函数其中的权重和阈值可以通过学习得到，更一般地，将阈值看做一个固定输入为-1的哑节点的连接权重，权重和阈值的学习就统一为权重的学习感知机的学习规则，设样本$(\\boldsymbol x,y)$，当前感知机的输出为$\\hat y$\\[\\omega_i \\leftarrow \\omega_i+\\Delta\\o...",
    "content": "神经元模型感知机与多层网络感知机由两层神经元组成，包含输入层和输出层，只有输出层拥有激活函数其中的权重和阈值可以通过学习得到，更一般地，将阈值看做一个固定输入为-1的哑节点的连接权重，权重和阈值的学习就统一为权重的学习感知机的学习规则，设样本$(\\boldsymbol x,y)$，当前感知机的输出为$\\hat y$\\[\\omega_i \\leftarrow \\omega_i+\\Delta\\omega_i\\\\\\Delta\\omega=\\eta(y-\\hat y)x_i\\]每层神经元与下一层神经元全互联，不存在跨层连接、同层连接，这样的网络称为多层前馈网络，其中隐层和输出层神经元具有激活函数，对输入进行加工误差逆传播算法误差逆传播算法(BP)可用于训练多层前馈网络，也可训练递归神经网络除上图标记外，第j个输出神经元的阈值为$\\theta_j$，第h个隐层神经元的阈值为$\\gamma_h$设训练样本$(\\boldsymbol x^k,y^k)$，网络输出为$\\hat y^k=(\\hat y^k_1,\\hat y^k_2,…,\\hat y^k_l)$，隐层和输出层的激活函数均使用sigmoid函数\\[\\hat y^k_j=f(\\beta_j-\\theta_j)\\]sigmoid函数求导有\\[f'(x)=f(x)(1-f(x))\\]均方误差为\\[E_k={1\\over2}\\sum\\limits_{j=1}^l(\\hat y_j^k-y_j^k)^2\\]广义上的任意参数$\\nu$更新估计式为\\[\\nu\\leftarrow\\nu+\\Delta\\nu\\]BP算法使用梯度下降策略，以目标的负梯度方向对参数进行调整，给定学习率$\\eta$，计算输出层到隐层的权重$\\omega_{hj}$的梯度\\[\\begin{aligned}\\omega_{hj}&amp;\\leftarrow\\omega_{hj}+\\Delta\\omega_{hj}\\\\\\Delta\\omega_{hj}&amp;=-\\eta\\frac{\\partial E_k}{\\partial\\omega_{hj}}\\\\\\frac{\\partial E_k}{\\partial\\omega_{hj}}&amp;=\\frac{\\partial E_k}{\\partial\\hat y^k_j}\\cdot\\frac{\\partial\\hat y^k_j}{\\partial\\beta_j}\\cdot\\frac{\\partial\\beta_j}{\\partial\\omega_{hj}}\\\\\\frac{\\partial\\beta_j}{\\partial\\omega_{hj}}&amp;=b_h\\\\\\frac{\\partial E_k}{\\partial\\omega_{hj}}&amp;=\\frac{\\partial E_k}{\\partial\\hat y^k_j}\\cdot\\frac{\\partial\\hat y^k_j}{\\partial\\beta_j}\\cdot b_h\\\\记g_j&amp;=-\\frac{\\partial E_k}{\\partial\\hat y^k_j}\\cdot\\frac{\\partial\\hat y^k_j}{\\partial\\beta_j}=-(\\hat y^k_j-y^k_j)\\hat y^k_j(1-\\hat y^k_j)\\\\综上，\\Delta\\omega_{hj}&amp;=\\eta g_jb_h=\\eta (y^k_j-\\hat y^k_j)(\\hat y^k_j-1)b_h\\end{aligned}\\]$\\theta_j$的梯度计算如下\\[\\begin{aligned}\\Delta\\theta_j&amp;=-\\eta\\frac{\\partial E_k}{\\partial\\theta_j}\\\\\\frac{\\partial E_k}{\\partial\\theta_j}&amp;=\\frac{\\partial E_k}{\\partial\\hat y^k_j}\\cdot\\frac{\\partial\\hat y^k_j}{\\partial\\theta_j}=-(\\hat y^k_j-y^k_j)\\hat y^k_j(1-\\hat y^k_j)=g_j\\\\\\Delta\\theta_j&amp;=-\\eta g_j\\end{aligned}\\]类似可得\\[\\begin{aligned}e_h&amp;=-\\frac{\\partial E_k}{\\partial b_h}\\cdot\\frac{\\partial b_h}{\\partial \\alpha_h}=b_h(1-b_h)\\sum\\limits^l_{j=1}\\omega_{hj}g_j\\\\\\Delta\\nu_{ih}&amp;=\\eta e_hx_i\\\\\\Delta\\gamma_h&amp;=-\\eta e_h\\end{aligned}\\]根据单个样本的误差来计算梯度并更新参数的BP算法称为标准BP算法，而使用整个数据集的累积误差(误差平均值)来更新参数的BP算法称为累积BP算法  累积BP算法：参数更新频率低，下降到一定程度后，下降非常缓慢  标准BP算法：参数更新频率高，更新效果可能会抵消，但在误差非常小时能够获得更优解解决BP网络的过拟合问题  早停：使用训练集和验证集，当训练集误差降低而验证集误差升高时，立即停止训练  正则化：在损失函数中增加正则化项，描述了网络的复杂度，从而使网络偏好较小的权重，输出更加光滑全局最小与局部最小使用梯度下降的参数寻优方法时，总是沿负梯度方向搜索，即损失函数值下降最快的方向，在参数寻优的过程中，可能会陷入局部最小，若损失函数仅有一个局部最小，则为全局最小，若存在多个局部最小，有几种策略来跳出当前的局部最小  以多组初始值不同的参数来训练网络，即从不同的起点开始搜索，取其中误差最小的解  模拟退火算法：在搜索的每一步有概率接收比当前解更差的结果，使得搜索跳出局部最小  随机梯度下降：计算梯度时加入随机因素，使得在局部最小的梯度仍可能不为0，从而跳出局部最小"
  },
  
  {
    "title": "《机器学习》——决策树",
    "url": "/posts/ml-%E5%86%B3%E7%AD%96%E6%A0%91/",
    "categories": "人工智能, 机器学习",
    "tags": "人工智能, 机器学习, 决策树",
    "date": "2024-06-15 23:20:00 +0800",
    





    
    "snippet": "基本流程决策树是基于树结构来进行分类，叶子节点对应决策结果，分支节点对应一个属性测试决策树的递归过程有三种情况导致返回  当前节点包含的样本全部判定为同一类别，无需划分  当前属性集为空，或是所有样本在所有属性上取值相同，无法划分，该节点作为叶子节点  当前节点包含的样本集为空，无法划分，该节点作为叶子节点，决策结果为父节点样本最多的类别划分选择决策树的每个节点需要从属性集中选择最优的划分属...",
    "content": "基本流程决策树是基于树结构来进行分类，叶子节点对应决策结果，分支节点对应一个属性测试决策树的递归过程有三种情况导致返回  当前节点包含的样本全部判定为同一类别，无需划分  当前属性集为空，或是所有样本在所有属性上取值相同，无法划分，该节点作为叶子节点  当前节点包含的样本集为空，无法划分，该节点作为叶子节点，决策结果为父节点样本最多的类别划分选择决策树的每个节点需要从属性集中选择最优的划分属性，再根据该属性进行样本集划分信息熵通常使用信息熵度量样本集合纯度，设样本集D中第k类样本所占比例为$p_k$，则信息熵定义为\\[Ent(D)=-\\sum\\limits^{\\vert C\\vert}_{k=1}p_k\\log_2p_k\\]信息熵的值越小，D的分类纯度越高信息增益对于一个特定属性a可以计算它的信息增益，设属性a的取值为$a^1,a^2,…,a^V$，所有在属性a上取同一个值的样本的集合为$D^v$，则属性a的信息增益为\\[Gain(D,a)=Ent(D)-\\sum\\limits^V_{v=1}\\frac{\\vert D^v\\vert}{\\vert D\\vert}Ent(D^v)\\]属性的信息增益越大，使用该属性进行划分获得的纯度提升越大，ID3决策树算法就是使用信息增益作为划分准则增益率信息增益的划分准则对取值数目较多的属性具有偏好，在C4.5决策树算法中使用增益率作为划分准则\\[\\begin{aligned}Gain\\_ratio(D,a)&amp;=\\frac{Gain(D,a)}{TV(a)}\\\\IV(a)&amp;=-\\sum\\limits^V_{v=1}\\frac{\\vert D^v\\vert}{\\vert D\\vert}\\log_2\\frac{\\vert D^v\\vert}{\\vert D\\vert}\\end{aligned}\\]$IV(a)$称为属性a的固有值，属性取值越多，固有值越大，增益率准则对属性取值较少的属性具有偏好基尼指数基尼指数反映了从D中随机抽取两个样本，它们不属于同一类的概率，基尼指数越小，样本集纯度越高\\[Gini(D)=\\sum\\limits^{\\vert C\\vert}_{k=1}\\sum\\limits_{k'\\ne k}p_kp_{k'}=1-\\sum\\limits^{\\vert C\\vert}_{k=1}p_k^2\\]属性a的基尼指数为\\[Gini\\_index(D,a)=\\sum\\limits^{\\vert V\\vert}_{v=1}\\frac{\\vert D^v\\vert}{\\vert D\\vert}Gini(D^v)\\]剪枝处理决策树算法使用剪枝来解决过拟合，分为预剪枝和后剪枝      预剪枝    在每个节点确定划分前先比较划分前和划分后的预测精度，若划分后精度大于划分前精度，则确定当前属性划分    预剪枝会阻止精度较低的判定分支展开，这可能导致后续精度提升较大的划分无法展开，导致欠拟合        后剪枝    先训练一棵决策树，自底向上对分支节点判断将分支节点替换为叶子节点是否能提升泛化性能，若能，则替换为叶子节点  连续与缺失值在连续值属性上使用决策树算法，首先需要将连续值转换为离散值，最简单的方法是使用连续值属性取值的中间值作为阈值，将大于阈值和小于阈值的归为两类对于缺失值，记$\\tilde D$为数据集$D$上属性a无缺失值的样本集，属性a的取值为$a^1,a^2,..,a^V$，为每个样本设置一个权重$\\omega_x$，定义比值$\\tilde r_v$\\[\\tilde r_v=\\frac{\\sum_{x\\in\\tilde D^v}\\omega_x}{\\sum_{x\\in\\tilde D}\\omega_x}\\]若样本x在属性a上取值已知，则将该样本划分到对应的子节点，权值为$\\omega_x$，若取值未知，则将该样本划分到所有节点，每个节点中的权重为$\\tilde r_v\\cdot\\omega_x$，即将该样本以不同的概率划分到不同的节点中多变量决策树从属性空间来看，决策树分类形成的分类边界与空间的每个轴是平行的，这样难以实现复杂的划分，使用多变量决策树可以实现复杂划分多变量决策树在进行决策时，不是使用一个单一属性，而是使用多个属性的线性组合，即每个分支节点是一个无偏移的线性分类器"
  },
  
  {
    "title": "《机器学习》——线性模型",
    "url": "/posts/ml-%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/",
    "categories": "人工智能, 机器学习",
    "tags": "人工智能, 机器学习, 线性模型",
    "date": "2024-06-15 23:19:00 +0800",
    





    
    "snippet": "基本形式对样本$x=(x_1;x_2;x_3;…;x_d)$，有\\[f(x_i)=\\omega^Tx+b\\]其中$\\omega=(\\omega_1;\\omega_2;…;\\omega_d)$线性回归离散属性处理  具有序关系的属性可以连续化，如身高  不具有序关系的属性转化为k维向量一元线性回归对于一元线性回归\\[f(x_i)=\\omega x_i+b\\]使用均方误差来衡量$f(x)$与$y...",
    "content": "基本形式对样本$x=(x_1;x_2;x_3;…;x_d)$，有\\[f(x_i)=\\omega^Tx+b\\]其中$\\omega=(\\omega_1;\\omega_2;…;\\omega_d)$线性回归离散属性处理  具有序关系的属性可以连续化，如身高  不具有序关系的属性转化为k维向量一元线性回归对于一元线性回归\\[f(x_i)=\\omega x_i+b\\]使用均方误差来衡量$f(x)$与$y$​的差别，并使其最小化来求解模型的方法称为最小二乘法最小二乘参数估计\\[\\begin{aligned}E(\\omega,b)&amp;=\\sum\\limits_{i=1}^m(f(x_i)-y_i)^2\\\\\\frac{\\partial E(\\omega,b)}{\\partial \\omega}&amp;=2(\\omega\\sum\\limits_{i=1}^mx_i^2-\\sum\\limits_{i=1}^m(y_i-b)x_i)\\\\\\frac{\\partial E(\\omega,b)}{\\partial b}&amp;=2(mb-\\sum\\limits_{i=1}^m(y_i-\\omega x_i))\\end{aligned}\\]令两个偏导为0可求得$\\omega$和$b$最优解多元线性回归对于多元线性回归\\[f(x_i)=\\omega^T x_i+b\\]定义向量形式如下\\[\\begin{aligned}X&amp;=\\begin{bmatrix}x_{11} &amp; x_{12} &amp; \\cdots &amp; x_{1d} &amp; 1\\\\x_{21} &amp; x_{22} &amp; \\cdots &amp; x_{2d} &amp; 1\\\\\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots &amp; \\vdots\\\\x_{m1} &amp; x_{m2} &amp; \\cdots &amp; x_{md} &amp; 1\\\\\\end{bmatrix}=\\begin{bmatrix}\\vec{x}_1^T &amp; 1\\\\\\vec{x}_2^T &amp; 1\\\\\\vdots &amp; \\vdots\\\\\\vec{x}_m^T &amp; 1\\\\\\end{bmatrix}\\\\\\hat{\\omega}&amp;=(\\vec{\\omega},b)\\\\\\vec{y}&amp;=(y_1;y_2;...;y_m)\\end{aligned}\\]由最小二乘法有\\[\\begin{aligned}E(\\hat{\\omega})&amp;=(\\vec{y}-X\\hat{\\omega})^T(\\vec{y}-X\\hat{\\omega})\\\\\\frac{\\partial E(\\hat{\\omega})}{\\partial \\omega}&amp;=2X^T(X\\hat{\\omega}-\\vec{y})\\end{aligned}\\]当$X^TX$满秩时，令偏导为0有唯一解，也称为正规方程法\\[\\hat\\omega=(X^TX)^{-1}X^T\\vec y\\]当$X^TX$不满秩时，存在多组解，由算法的归纳偏好决定输出哪一组解，通常引入正则化项广义线性模型\\[y=g^{-1}(\\omega^Tx+b)\\]其中函数$g(.)$单调可微，称为联系函数，可以理解为将线性模型的预测值与实际标记联系起来的函数对数几率回归对于二分类任务，使用线性模型需要将线性模型的输出值与分类联系起来使用sigmoid函数作为联系函数\\[y=\\frac{1}{1+e^{-z}}\\]sigmoid函数将$(-\\infty,+\\infty)$映射到$(0,1)$之间代入线性函数有\\[\\begin{aligned}y&amp;=\\frac{1}{1+e^{-(\\omega^Tx+b)}}\\\\\\ln\\frac{y}{1-y}&amp;=\\omega^T+b\\end{aligned}\\]其中$\\ln\\frac{y}{1-y}$​称为对数几率（logit），反映了正例的相对几率将$y$重写为概率估计，通过极大似然估计可求解参数\\[\\begin{aligned}p(y=1\\vert x)&amp;=\\frac{e^{\\omega^Tx+b}}{1+e^{\\omega^Tx+b}}\\\\p(y=0\\vert x)&amp;=\\frac{1}{1+e^{\\omega^Tx+b}}\\end{aligned}\\]线性判别分析在二分类问题上，线性判别分析（LDA）通过将样本投影到一条直线上，同时使得相同类别的样本的投影点尽可能接近，而不同类别的样本的投影点尽可能远离，确定直线后，将新样本投影到该直线上，根据投影点的位置判定类别LDA的目标是使同类样本的投影点尽可能接近，则可以使同类样本投影点的协方差尽可能小，使不同的样本的投影点尽可能远离，则可以使类中心的距离尽可能大，用$\\mu_0$和$\\mu_1$表示两类样本的均值向量，$\\Sigma_0$和$\\Sigma_1$表示两类样本的协方差矩阵，有最大化目标函数\\[J=\\frac{\\omega^T(\\mu_0-\\mu_1)(\\mu_0-\\mu_1)^T\\omega}{\\omega^T(\\Sigma_0+\\Sigma_1)\\omega}=\\frac{\\omega^TS_b\\omega}{\\omega^TS_\\omega\\omega}\\]多分类学习对于多分类问题，通常是使用一些拆分策略，将其转换为多个二分类问题，通常有以下三种拆分策略  一对一（OvO）：将N个类别两两配对，形成$N(N-1)/2$组二分类问题，最终结果取预测最多的类别  一对其余（OvR）：将一个类别作为正例，其余类别作为反例，形成N个二分类问题  多对多（MvM）：取多个类别作为正例，其他类别作为反例，通常使用纠错输出码（ECOC）拆分ECOC分为两步  编码：对N个类别做M次划分，划分出M个训练集，训练出M个分类器  解码：M个分类器分别对测试样本分类，产生的预测标记组成一个编码，将这个编码与每个类别定义的编码进行比较，将其中距离最小的类别作为结果ECOC常见的有二元码和三元码，类别和类别划分组成编码矩阵，其中1表示正类，-1表示负类a图中分类器f1的预测结果为$(-1,+1,-1,-1)$，f2的预测结果为$(+1,-1,+1,-1)$，f3的预测结果为$(-1,-1,+1,+1)$，f4的预测结果为$(+1,+1,-1,+1)$，f5的预测结果为$(+1,-1,+1,-1)$，对于C1类别组成了一个编码$(-1,+1,-1,+1,+1)$，使用该编码与测试样本的编码进行比较对于同一个学习任务，一般编码越长，纠错能力越强，但编码越长，所需的分类器越多，训练开销越大类别不平衡问题类别不平衡是指分类任务重不同类别的训练样本数目差别很大，同时在使用OvR和MVM拆分多分类问题时也可能导致类别不平衡使用再缩放策略解决类别不平衡问题通常认为正反例的可能性相同，当正例几率大于0.5时预测为正例\\[\\frac{y}{1-y}&gt;1\\]当正反例的数目不同时，假设训练集是真实样本集的无偏采样，当正例几率大于数据集中正例的观测几率就可以判为正例\\[\\frac{y}{1-y}&gt;\\frac{m^+}{m^-}\\]对预测值进行再缩放调整\\[\\frac{y'}{1-y'}=\\frac{y}{1-y}\\times\\frac{m^-}{m^+}\\]实际操作中观测几率通常不能代表真实几率，此时使用三种方法处理  多数样本欠采样：删除多数样本  少数样本过采样：通常使用插值增加样本  阈值移动：将再缩放方法加入决策过程中"
  },
  
  {
    "title": "XPath基础",
    "url": "/posts/xpath/",
    "categories": "Python, 爬虫",
    "tags": "XPath, Python, 爬虫",
    "date": "2024-06-09 23:10:00 +0800",
    





    
    "snippet": "开始XPath是一门在XML文档中查找信息的语言，通常用于HTML文档的解析，使用路径表达式可以选择文档中的节点路径选择有两种路径选择方式  /：选择直接子节点  //：选择所有子孙节点e.g. 对于下面的文档，选择其中的两个price节点&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;bookstore&gt;&lt;title class...",
    "content": "开始XPath是一门在XML文档中查找信息的语言，通常用于HTML文档的解析，使用路径表达式可以选择文档中的节点路径选择有两种路径选择方式  /：选择直接子节点  //：选择所有子孙节点e.g. 对于下面的文档，选择其中的两个price节点&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;bookstore&gt;&lt;title class=\"my-class\"&gt;Hello&lt;/title&gt; &lt;book&gt;  &lt;title lang=\"eng\"&gt;Harry Potter&lt;/title&gt;  &lt;price&gt;29.99&lt;/price&gt;&lt;/book&gt; &lt;book&gt;  &lt;title lang=\"eng\"&gt;Learning XML&lt;/title&gt;  &lt;price&gt;39.95&lt;/price&gt;&lt;/book&gt; &lt;/bookstore&gt;两种方式的表达式分别如下  /bookstore/book/price  //price获取节点内容的方式      获取节点文本：text()    //title/text()            获取节点属性：@attr    //title/@class      路径表达式组合：使用|组合两个路径表达式//price | //title节点过滤在节点后加上[]，可以在当前节点集中进行过滤，[]中可以进行两类过滤  按指定位置过滤：选择指定位置的节点，从1开始  按逻辑表达式过滤：选择满足条件的节点选择指定位置的节点//div[1]  # 选择第一个节点//div[last()]  # 选择最后一个节点//div[position()=3]  # 选择第三个节点选择满足条件的节点# 相等匹配（xpath支持比较匹配和运算，但使用较少，不再记录）//div[text()='hello']  # 根据文本内容筛选//div[@class='my-class']  # 根据属性值筛选# 模糊匹配//div[contains(text(), 'hello')]  # 文本内容包含//div[starts-with(text(), 'hello')]  # 文本内容开头//div[contains(@class, 'hello')]  # 属性值包含//div[starts-with(@class, 'hello')]  # 属性值开头# 逻辑组合//div[text()='hello' and @class='my-class']//div[text()='hello' or @class='my-class']注意，节点过滤是针对单个层级路径下的节点集进行过滤，例如下面的例子&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;bookstore&gt; &lt;book&gt;  &lt;price id=\"book1-price1\"&gt;29.99&lt;/price&gt;  &lt;price id=\"book1-price2\"&gt;29.99&lt;/price&gt;&lt;/book&gt; &lt;book&gt;  &lt;price id=\"book2-price1\"&gt;39.95&lt;/price&gt;  &lt;price id=\"book2-price2\"&gt;39.95&lt;/price&gt;&lt;/book&gt; &lt;/bookstore&gt;当使用//price时会选择全部四个price节点，此时筛选节点//price[1]，对每个层级路径都会进行一次过滤，即筛选后选择了id为book1-price1和book2-price1的节点"
  },
  
  {
    "title": "《机器学习》——模型评估与选择",
    "url": "/posts/ml-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0/",
    "categories": "人工智能, 机器学习",
    "tags": "人工智能, 机器学习, 模型评估与选择",
    "date": "2024-06-08 23:48:00 +0800",
    





    
    "snippet": "经验误差与过拟合训练误差/经验误差：学习器在训练集上的误差  泛化误差：学习器在新样本上的误差  过拟合：学习器的学习能力过于强大，将样本的特点当做了一般性质  欠拟合：学习器的学习能力低下，没有学习到样本的一般性质评估方法使用一个测试集对学习器进行测试，产生的测试误差作为泛化误差的近似，从而评估学习器的泛化能力对数据集划分出训练集和测试集的方法      留出法：直接将数据集划分为两个互斥...",
    "content": "经验误差与过拟合训练误差/经验误差：学习器在训练集上的误差  泛化误差：学习器在新样本上的误差  过拟合：学习器的学习能力过于强大，将样本的特点当做了一般性质  欠拟合：学习器的学习能力低下，没有学习到样本的一般性质评估方法使用一个测试集对学习器进行测试，产生的测试误差作为泛化误差的近似，从而评估学习器的泛化能力对数据集划分出训练集和测试集的方法      留出法：直接将数据集划分为两个互斥的集合，划分要尽可能保持数据分布的一致性    单次使用留出法的结果往往不可靠，通常需要多次随机划分，然后取所有划分产生结果的平均值        交叉验证法：将数据集划分为k个互斥的集合，每轮用其中的k-1个集合作为训练集，剩下的1个集合作为测试集，产生k个结果，取其平均值        留一法：交叉验证法的特例，每个子集中只包含一个样本        自助法：对m个样本的数据集进行m次有放回随机抽样，产生的集合作为训练集，原始数据集作为测试集  机器学习中的参数分为两类  超参数：人工设定的参数  模型参数：模型学习中产生的参数验证集：在训练集的基础上进一步划分为训练集和验证集，通过模型在验证集上的性能来评估模型和调参性能度量均方误差回归任务中常用的性能度量是均方误差MSE\\[E(f;D)={1\\over m}\\sum\\limits^m_{i=1}(f(x_i)-y_i)^2\\]错误率与精度  错误率：分类错误样本占总样本的比例  精度：分类正确的样本占总样本的比例查准率与查全率  查准率：分类为正例中实际正例的比例，$P=\\frac{TP}{TP+FP}$  查全率：分类正确的样本中实际正例的比例，$R=\\frac{TP}{TP+FN}$  PR曲线：查准率为纵轴，查全率为横轴构成的曲线通过PR曲线判断模型的性能平衡点：查准率等于查全率的点的取值，当模型A的平衡点大于模型B，可认为A性能优于BF1分数：查准率与查全率的调和平均\\[F1=\\frac{2\\times P\\times R}{P+R}\\]F1分数的一般形式$F_\\beta$\\[F_\\beta=\\frac{(1+\\beta^2)\\times P\\times R}{(\\beta^2\\times P)+R}\\]  当$\\beta=1$时，退化为F1  当$\\beta&gt;1$时，查全率影响更大  当$\\beta&lt;1$时，查准率影响更大当产生多个二分类混淆矩阵时，有两种做法  macro：对每个混淆矩阵计算查准率和查全率，再取平均，得到macro-P和macro-R，基于此，计算得到macro-F1  micro：对混淆矩阵的每个元素取平均，即计算TP、FP、TN和FN的平均值，基于此计算得到micro-P和micro-R，进一步得到micro-F1ROC与AUC将TPR作为纵轴，FPR作为横轴构成ROC曲线，AUC为ROC曲线下的面积  TPR：真正例率，$TPR=\\frac{TP}{TP+FN}$  FPR：假正例率，$FPR=\\frac{FP}{TN+FP}$代价敏感错误率与代价曲线对于不同类型的错误，可以为错误赋予非均等代价总体代价敏感错误率\\[E(f;D;cost)={1\\over m}(\\sum\\limits_{x_i\\in D^+}I(f(x_i)\\ne y_i)\\times cost_{01}+\\sum\\limits_{x_i\\in D^-}I(f(x_i)\\ne y_i)\\times cost_{10})\\]偏差与方差偏差-方差分解可以用于解释泛化误差，泛化误差可理解为偏差、方差与噪声之和  偏差：表示了学习算法的期望预测与真实结果的偏离程度，表现了算法的拟合能力  方差：表示了训练集中数据的变动造成的学习性能变化  噪声：表示了当前任务上任何学习算法所能达到的期望泛化误差的下界，表现了学习问题本身的难度偏差与方差随着算法拟合能力的变化而变化  当算法拟合能力不足时，期望预测与真实结果的偏离程度较大，而数据集中的数据变化不足以导致学习性能变化，此时偏差较大，方差较小  当算法拟合能力过强时，期望预测与真实结果的偏离程度较小，而数据集中的数据变化被学习器学习到，可能导致学习性能显著变化，此时偏差较小，方差较大"
  },
  
  {
    "title": "《机器学习》——绪论",
    "url": "/posts/ml-%E7%BB%AA%E8%AE%BA/",
    "categories": "人工智能, 机器学习",
    "tags": "人工智能, 机器学习",
    "date": "2024-06-08 23:47:00 +0800",
    





    
    "snippet": "前言本系列文章是对周志华老师的《机器学习》所做的笔记与总结，格式随意，仅做复习参考之用基本术语            术语      说明                  样本      对一个具体对象的描述              属性/特征      反映对象的性质              属性值      针对某个具体对象的特征取值              属性空间      ...",
    "content": "前言本系列文章是对周志华老师的《机器学习》所做的笔记与总结，格式随意，仅做复习参考之用基本术语            术语      说明                  样本      对一个具体对象的描述              属性/特征      反映对象的性质              属性值      针对某个具体对象的特征取值              属性空间      将一个属性看做一个坐标轴，所有属性坐标轴张成的空间              特征向量      具体对象的一组属性值，对应到属性空间中的一个点              数据集      样本的集合              训练      执行学习算法，从数据集中学得模型的过程              假设      学习到的关于数据的潜在规律              标记      有关样本结果的信息              标记空间      所有标记的集合              分类任务      样本的结果信息为离散值的学习任务              回归任务      样本的结果信息为连续值的学习任务              有监督学习      训练样本具有标记信息的学习任务              无监督学习      训练样本不具有标记信息的学习任务              泛化能力      学习模型适用于新样本的能力      假设空间假设是关于数据的一种特定的潜在规律，可以理解为，假设是一个特定的函数，假设空间就是多个函数组成的集合，假设的表示就是这一类函数的表示形式（也可以理解为一种模型就是一种假设表示），学习过程可以看做在假设空间里搜索匹配训练样本的假设，也就是搜索拟合的函数当假设的表示确定了，假设空间及其规模大小也就确定了例如，一类函数表示为线性函数$y=w^Tx+b$，其中不同的w和b会形成不同的函数，这些函数构成了一个线性函数的假设空间再例如，一种分类模型表示为决策树，其中不同的分类规则形成不同的决策树模型，这些决策树模型构成了一个决策树的假设空间版本空间：匹配训练集的所有假设组成的假设集合归纳偏好当存在多个匹配训练集的假设时，我们要在其中选择一个，学习算法本身的偏好会影响这个选择，任何机器学习算法都必有其归纳偏好若有多个假设与观察一致，选最简单的假设，这个准则称为奥卡姆剃刀，对于“简单”的定义不同，奥尔姆剃刀并非唯一可行任意学习算法在所有可能的目标函数上，它们的期望性能是相等的，这称为NFL定理，说明没有一种算法能够在所有可能的问题上都优于其他算法，选择算法时必须考虑具体问题的特性和需求，而不是期望找到一种万能算法"
  },
  
  {
    "title": "8086汇编语言基础",
    "url": "/posts/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/",
    "categories": "",
    "tags": "汇编语言, Intel 8086, 计算机组成原理",
    "date": "2024-06-03 21:21:00 +0800",
    





    
    "snippet": "前言本篇文章是对王爽老师的《汇编语言（第三版）》所做的笔记与总结，格式比较随意，权当复习参考之用基础编译器：将汇编语言转换为机器语言汇编语言的组成  汇编指令：机器码的助记符，有对应的机器码  伪指令：没有对应的机器码，由编译器执行  其他符号：如+,-,*,/等，由编译器识别，没有对应的机器码指令和数据：一段二进制信息，可以被看做数据或者看做程序CPU读写数据：CPU读写数据时，与外部设备...",
    "content": "前言本篇文章是对王爽老师的《汇编语言（第三版）》所做的笔记与总结，格式比较随意，权当复习参考之用基础编译器：将汇编语言转换为机器语言汇编语言的组成  汇编指令：机器码的助记符，有对应的机器码  伪指令：没有对应的机器码，由编译器执行  其他符号：如+,-,*,/等，由编译器识别，没有对应的机器码指令和数据：一段二进制信息，可以被看做数据或者看做程序CPU读写数据：CPU读写数据时，与外部设备交互存储单元的地址(地址信息)，器件信息，读或写的命令(控制信息)，读或写的数据(数据信息)总线：CPU与其他芯片的导线，分为地址总线，控制总线，数据总线      地址总线    地址总线宽度为N，则CPU寻找的范围为2^N^个内存单元        数据总线    数据总线的宽度决定了数据传输的速度        控制总线    控制总线的宽度决定了CPU对外部设备的控制能力，其中有一根读信号输出线，低电平表示将要读取数据，写信号输出线负责传输写信号  存储器芯片  随机存储器(RAM)：用于存放CPU使用绝大部分程序和数据，分为主板上的RAM和插在扩展插槽上的RAM  装有BOIS的ROM(装有基本输入输出系统的只读存储器)：可以通过各类主板和接口卡上的BOIS使用该设备进行基本的输入输出  接口卡上的RAM：接口卡对大批量输入输出数据进行暂时存储，用于与设备进行输入输出内存地址空间：CPU地址总线可以寻到的所有存储单元组成CPU的内存地址空间，对于各类接口卡，CPU通过总线控制它们，将它们看做一个由多个存储单元组成的逻辑存储器寄存器通过改变各种寄存器中的内容来实现对CPU的控制通用寄存器：用于存放一般性数据对于一个16位寄存器来说，存储的数据可以看做16位二进制，也可以看做一个字字分为高位字节和低位字节，如ax分为ah,al，两个字节为8位，可以将它们看做单独的两个寄存器，做运算时产生的进位不影响其他位16位机的含义：位数描述了CPU的几个结构特性  运算器最多一次可以处理16为的数据  寄存器的最大宽度为16位  寄存器和运算器之间的通路为16位CPU给出物理地址的方法CPU在地址总线上传输的是内存单元的物理地址，CPU首先需要在内部生成这个物理地址，CPU给出物理地址的方法可以概括为基础地址+偏移地址=物理地址，基础地址(段地址)由段寄存器提供(8086CPU有4个段寄存器:CS,DS,SS,ES)流程：CS，IP中的段地址和偏移地址传入到地址加法器，将物理地址传入输入输出控制电路，从内存中读取指令，传回指令寄存器，执行指令，CPU只认为CS和IP所指的地址为指令修改CS和IP的指令：jmp 段地址:偏移地址，该指令只能使用在调试模式仅改变IP的指令：jmp ax内存访问内存中字的存储字单元：存放一个字形数据(16位)的内存单元，由两个地址连续的内存单元组成，高地址单元存放高位字节，低地址单元存放低位字节DS和[address]8086CPU有一个DS寄存器，用于存放要访问数据的段地址mov ax [0]：将DS中的段地址+中括号里的偏移地址所指定的内存单元传入ax设置DS中的地址：需要将地址传入其他寄存器，再从其他寄存器传入DS，mov ds axmov,add,sub指令mov指令  mov register data  mov register1 register2  mov register memory，内存单元用中括号包围  mov memory register  mov segment-register registeradd指令  add register data  add register1 register2  add register memory  add memory registersub指令  sub register data  sub register1 register2  sub register memory  sub memory register栈8086CPU提供出栈和入栈的指令：push/pop出栈和入栈的单位为字8086CPU中的两个寄存器SS(段寄存器)和SP存储栈顶元素的地址，入栈时，栈顶从高地址向低地址增长SS:SP初始时指向栈空间最高地址(栈底)的下一个单元SS:SP不会记忆栈空间的大小，只知道当前执行的地址，需要注意操作时不要越界创建栈(创建10000到1000f为栈空间)mov ax,1000mov ss,axmov sp,0010在debug模式调用t指令时，执行mov ss,ax后会继续执行mov sp,0010push指令  push register  push segment-register  push memory，注意栈操作以字为单位(16位，两个8位字节)pop指令  pop register  pop segment-register  pop memoryDebug模式  r指令：查看当前寄存器状态，r register，修改寄存器中的值  d指令：查看指定内存的内容，显示为十六进制          d 1000:0 f，显示1000:0000到1000:000f的内容      d cs:0，查看当前代码段中的内容        e指令：改写内存中的内容          e 1000:0 data1 data2 ...，从1000:0000开始写入数据      e 1000:0，以提问形式逐个单元写入十六进制        u指令：将内存中的机器码翻译为汇编语言，u 1000:0，查看1000:0000开始的汇编代码  a指令：在内存中写入汇编代码，a 1000:0，从1000:0000开始写入汇编代码  t指令：执行当前CS:IP指向的内存地址中的代码程序编写  编写汇编代码源文件  对源文件进行编译和链接，产生机器码，存储在可执行文件  执行可执行文件伪指令伪指令没有对应的机器指令，由编译器执行，编译器根据伪指令来进行编译segment-ends用于标注一个段，格式为code_name segment...code_name endsend标识整个程序的结束，在end处结束编译assume表示将某一段寄存器与程序中的某一个段相关联，assume segment_register:code_name程序返回：mov ax,4c00h\tint 21h，汇编中十六进制数字后面加h，数据不能以字母开头，需要在前面加0程序执行过程汇编程序从编写到执行的过程编写(1.asm)——编译masm(1.obj)——连接link(1.exe)——加载——内存中的程序——运行(CPU)调试程序指令：debug 1.exe调试时使用p命令执行int 21h，q命令退出debug模式[bx]和loop指令[bx][bx]表示bx中的偏移地址，与DS的段地址组成物理地址inc bx：将bx的内容+1dec bx：将bx的内容-1编译器和debug模式对[idata]的执行情况不同  debug模式将[idata]解释为用常量表示偏移地址  编译器将[idata]解释为数字常量，在[idata]前加段地址mov ax,ds:[0]即可表示偏移地址  两个模式对[bx]的解释相同loop标号：s: add ax,ax，标号标识了一个地址，该地址处有一条指令使用loop：loop s，将cx作为循环计数器(loop指令默认cx为计数器)，执行的代码段放在标号和loop之间，loop放在标号之后，注意在loop之前，代码已经执行过一次，相当于do-while  (cx)=(cx)-1  判断cx的值，若不为0，则跳转到标号处，否则跳出循环debug模式跳转到指定位置执行：g 偏移地址(ip)自动结束循环：p，在loop指令处调用多个段的程序定义字型数据：dw 0123h,0456h，系统在该指令地址处分配空间存放数据定义字节型数据：db 'abc'在程序前定义数据会出现程序入口不确定的问题使用标号标注程序的入口，end start表示结束start处的程序定义多个段分别存放数据、代码、栈assume cs:code,ds:data,ss:stackdata segment\tdw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987hdata endsstack segment\tdw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0stack endscode segmentstart:\tmov ax,stack\t\tmov ss,ax\t\tmov sp,20h\t\tmov ax,data\t\tmov ds,ax\t\tmov bx,0\t\tmov cx,8\t\ts:\t\tpush [bx]\t\tadd bx,2\t\tloop s\t\tmov bx,0\t\tmov cx,8\t\ts0:\t\tpop [bx]\t\tadd bx,2\t\tloop s0\t\tmov ax,4c00h\t\tint 21hcode endsend start定位内存地址and和or指令and al,00111011bor al,00111011b将输入值与寄存器中的值进行按位与/或运算，存储在第一个寄存器参数中字符串处理字符和字符串以ASCII码的形式存储在寄存器中，数据段中使用db定义字符串空间大小写转换：大写字母的二进制第5位为0(从0开始)，小写字母的二进制第5位为1，运用and和or指令将字母的二进制第5位设置为0或1，即可转换大小写[bx+idata]可以使用bx中的地址加上一个偏移量表示一个内存单元，物理地址为(ds)*16+(bx)+idata其他格式：[200+bx],200[bx],[bx].200实现数组操作：idata[bx]，ds为起始段地址，idata为数组相对于ds的起始地址，bx作为索引  si,di寄存器：si和di为8086CPU中与bx功能相近的寄存器，它们不能分为两个8位寄存器其他偏移格式      [bx+si]表示一个内存单元，物理地址为(ds)*16+(bx)+(si)    其他格式：[bx][si]        [bx+si+idata]，物理地址为(ds)*16+(bx)+(si)+idata    其他格式：[bx+si+200],[200+bx+si],200[bx][si],[bx].200[si],[bx][si].200  当程序中多个数据(如多层循环计数器)需要暂存时，应该使用栈数据处理寄存器类型reg:ax,bx,cx,dx,ah,al,bh,bl,ch,cl,dh,dl,sp,bp,si,disreg:ds,ss,cs,esbx,si,bp,di可用于偏移地址寻址，bx和bp不能同时在一个中括号中寻址，si和di同理数据的表达数据位置的表达      立即数    在汇编指令中直接给出的数据，包括数字和字符串，执行前数据存放在CPU内部的指令缓冲器        寄存器    使用寄存器中存储的数据，执行前数据存储在CPU内部的寄存器        段地址:偏移地址(SA:EA)    使用SA:EA索引内存中的数据，执行前数据存储在内存中相应的内存单元中    SA默认为ds中的地址  数据尺寸的表达8086CPU可以处理两种尺寸的数据：byte,word，byte为8位，word为16位      通过寄存器名指明操作的数据尺寸    通过ax,bx等表明操作的是word，通过ah,al等表明操作的是byte        使用操作符X ptr指明数据尺寸      mov word ptr ds:[0],1\t;按字操作  mov byte ptr ds:[0],1\t;按字节操作            操作默认的尺寸    栈操作push,pop默认按word操作  其他指令div指令用于做除法操作  除数：除数为8位或16位，存储在内存或寄存器中  被除数：若除数为8位，则被除数为16位，默认存放在ax中，若除数为16位，则被除数为32位，默认存放在dx和ax中，dx存放高16位，ax存放低16位  结果：若除数为8位，则结果存放在ax中，al存储商，ah存储余数，若除数为16位，则结果存放在dx和ax中，dx存储余数，ax存储商div reg/memory提前在ax和dx中设置被除数，div指令传入除数所在的寄存器或内存单元伪指令dddd用于定义双字型数据，占两个word的大小(32位)dup操作符dup操作符同db,dw,dd等指令配合使用，用于数据重复db 3 dup (0)\t\t;定义了3个字节，内容都为0db 3 dup (0,1,2)\t;定义了9个字节，内容重复0,1,2转移指令可以修改IP或同时修改CS和IP的指令称为转移指令  只修改IP时，称为段内转移  同时修改cs和ip，称为段间转移转移种类：无条件转移，条件转移，循环指令，过程，中断操作符offsetoffset由编译器处理，用于取得标号的偏移地址mov ax,offset sjmp指令jmp为无条件跳转指令，可只修改IP或同时修改cs:ipjmp short label无条件跳转到标号处执行指令，实现段内短位移，转移的偏移量为8位(-128~127)CPU在执行jmp指令时不需要知道转移的目的地址，该指令的机器码中包含了目的地址到jmp指令的下一条指令的偏移量jmp near ptr label该指令表示段内近转移，偏移量为16位(-32768~32767)jmp far ptr label表示段间转移，机器码中包含标号所在的cs和ipjmp regreg为16位寄存器，修改ip为寄存器中的地址转移地址在内存中的jmp指令  jmp word ptr addr：指定一个内存单元地址，该内存单元存放一个字大小的目的偏移地址，实现段内转移  jmp dword ptr addr：指定一个内存单元地址，该内存单元存放两个字大小的目的偏移地址，实现段间转移，高位的字作为cs，低位的字作为ipjcxz指令jcxz为条件跳转指令，条件跳转指令都是短转移，机器码中包含偏移量(同jmp指令)jcxz label当cx=0时，跳转到指定标号处，否则向下执行call和ret指令call和ret都是转移指令，他们都修改ip或同时修改cs和ip，可用于子程序调用和返回ret,retf  ret指令用栈中的数据，修改ip，实现近转移  retf用栈中的数据，修改cs和ip，实现远转移，先从栈中弹出ip再弹出cs两个指令使用栈中数据时会同时弹出栈元素callcall label执行call指令时，CPU将当前的ip压入栈中，之后转移到标号处，实现段内近转移call指令转移通过偏移量转移类似jmp short labelcall far ptr label该指令执行时，CPU先压入当前cs再压入ip，之后转移到标号处，实现段间转移机器码中包含目的cs和ip，类似jmp far ptr labelcall reg(16bit)CPU先压入IP，再执行jmp reg跳转转移地址在内存中的call指令  call word ptr memory：先压入当前ip，再执行jmp word ptr memory跳转  call dword ptr memort：先压入cs，再压入ip，执行jmp dword ptr memory跳转子程序设计assume cs:codecode segmentmain:\tstatements\t\tcall s\t\tstatements\t\tmov ax,4c00h\t\tint 21h\t\ts:\t\tstatements\t\tretcode endsend mainmul指令用于乘法，两个操作数应同时为8位或16位同时为8位时，一个默认放在al中，一个放在8位寄存器或内存单元中，结果默认存放在ax中同时为16位时，一个默认存放在ax，一个放在16位寄存器或内存单元中，结果高位存放在dx中，低位存放在ax中参数和结果传递可以通过寄存器传递参数和返回值对于多个参数，可以将数据存储在内存中，在子程序中通过数据首地址访问当主程序寄存器和子程序寄存器冲突时，可以使用栈保存冲突的寄存器内容，返回时弹出内容标志寄存器标志寄存器用于存储相关指令的某些执行结果，为CPU执行相关指令提供行为依据，控制CPU的工作方式标志寄存器中的信息被称为程序状态字add,sub,mul,div,inc,or,and等运算影响标志位mov,push,pop等传送指令不影响标志位  ZF标志：零标志位，若执行结果为0，则ZF=1，否则为0  PF标志：奇偶标志位，若执行结果每一bit中1的个数为偶数，则PF=1，若为奇数，则PF=0  SF标志：符号标志位，若执行结果为负数，则SF=1，否则为0  CF标志：进位标志位，记录了无符号数运算低位向高位的进位值或借位值  OF标志：溢出标志位，若有符号数运算发生溢出，则OF=1，否则为0adc指令adc指令为带进位加法指令，它利用了CF位的进位值adc obj1,obj2\t;obj1=obj1+obj2+CFsbb指令sbb指令为带借位减法指令sbb obj1,obj2\t;obj1=obj1-obj2-CFcmp指令cmp为比较指令，对标志寄存器产生影响从而影响其他指令的判断结果，立即数必须放在第二个操作数cmp obj1,obj2执行obj1-obj2，根据结果设置标志寄存器对无符号数比较的结果  zf=1：obj1=obj2  zf=0：obj1!=obj2  cf=1：obj1&lt;obj2  cf=0：obj1&gt;=obj2  cf=0&amp;&amp;zf=0：obj1&gt;obj2  cf=1||zf=1：obj1&lt;=obj2对有符号数比较的结果  sf=1&amp;&amp;of=0：obj1&lt;obj2  sf=1&amp;&amp;of=1：obj1&gt;obj2  sf=0&amp;&amp;of=1：obj1&lt;obj2  sf=0&amp;&amp;of=0：obj1&gt;=obj2条件转移指令配合cmp指令跳转  je：相等跳转，zf=1  jne：不相等跳转，zf=0  jb：小于跳转，cf=1  jnb：不小于跳转，cf=0  ja：大于跳转，cf=0&amp;&amp;zf=0  jna：不大于跳转，cf=1||zf=1DF标志和串传送指令DF为方向标志位，在串传送指令中，控制每次操作后si,di的增减  df=0，si,di递增  df=1，si,di递减movsb指令相当于((es)*16+(di))=((ds)*16+(si))，之后根据df标志，si,di递增或递减，传输的单位为字节movsw指令与movsb同理，传输的单位为字两个指令与rep指令配合使用rep movsbrep movsw表示根据cx的值循环执行movsb/movsw设置df的指令  cld：令df=0  std：令df=1pushf和popfpushf将标志寄存器压栈，popf将栈中数据弹出到标志寄存器中flag在debug中的表示            flag      value=1      value=0                  of      OV      NV              sf      NG      PL              zf      ZR      NZ              pf      PE      PO              cf      CY      NC              df      DN      UP      内中断在CPU执行完当前的指令后，可以检测到从CPU外部或内部发送来的一种特殊信息，使CPU立即对这种特殊信息进行处理，而不继续进行接下来的指令内中断是CPU内部产生了中断信息当CPU内部发生以下情况时产生中断信息  除法错误，执行div产生除法溢出  单步执行，当TF=1时触发  执行into指令  执行int指令中断类型码标识了中断信息的来源，用于定位中断处理程序的位置  除法错误：0  单步执行：1  into：4  int n：n为提供给CPU的类型码中断向量表：记录了中断类型码对应的中断处理程序的入口地址(cs:ip)，一个入口地址为两个字，高地址字存放段地址，低地址字存放偏移地址，设类型码为n，偏移地址存放的偏移地址为4n，段地址为4n+2中断过程  从中断信息中取得中断类型码  标志寄存器入栈  将flag的第8位TF和第9位IF设为0  cs入栈  ip入栈  从中断向量表中读取处理程序的入口地址编写中断处理程序  使用到的寄存器入栈  处理中断  使用到的寄存器出栈  用iret指令返回，相当于自动完成pop ip pop cs popf使一段程序成为中断处理程序      将一段中断处理子程序传输到内存中存储    使用rep movsb传输，ds:si指向源地址，es:di指向目的地址，cx为传输长度(处理程序的代码长度)，cld设置传输方向为正    编译器可以处理立即数表达式，使用加减乘除等符号，表达式中不能存在寄存器    在处理程序的开头和结束设置一个标号，mov cx,offset func_end-offset func_begin可以获取处理程序的长度    处理程序中需要的字符串等数据应该存放在不会被覆盖的区域，可在处理程序的开头跳转到真正的处理程序，跳转指令后分配字符串等数据的内存空间        设置中断向量表，将对应中断类型的表项设置为子程序的入口地址  int中断int nn为中断类型码，int指令可以引发指定的中断过程可手动编写中断例程，将例程的入口地址设置到中断向量表中，通过int指令，手动触发中断，执行中断例程BIOS和DOS的中断例程BIOS主要包括  硬件系统的检测和初始化程序  外部中断和内部中断的中断例程  用于对硬件设备进行IO操作的中断例程  其他和硬件系统相关的中断例程中断例程的安装过程  CPU从ffff:0000开始执行程序，ffff:0有一条跳转指令，跳转到BIOS中的硬件系统检测和初始化  初始化程序建立BIOS的中断向量，记录在中断向量表中  调用int 19h进行操作系统的引导，此后计算机由操作系统控制  DOS启动后，将DOS提供的中断例程装入内存，建立中断向量BIOS和DOS的中断例程用ah来传递中断例程中执行的子程序的编号，用int指令触发int 21h程序返回例程21h号中断例程中的4ch号子程序为程序返回程序，使用ah传输子程序的编号，al传输程序的返回值端口主板上的接口芯片和各种接口卡的接口芯片都有一组由CPU读写的寄存器，它们都和CPU的总线相连，CPU对它们进行读写时通过控制线向它们所在的芯片发出端口读写命令端口读写命令只有in,out两条指令，分别向端口读取数据和向端口写入数据只能使用ax或al来存放从端口读取的数据和要向端口写入的数据，访问8位端口时使用al，16位端口使用axshl和shr指令shl和shr是逻辑移位指令shl reg,reg1shr reg,reg1reg1中的值为n，将寄存器中的值左/右移n位，最后移出的一位写入CF中，最低/最高位补0移位位数必须放在cl中CMOS RAM芯片该芯片包含一个实时钟和一个有128个存储单元的RAM存储器，RAM中0-0dh用来保存时间信息，其余大部分用于保存系统配置信息，系统启动时供BIOS读取该芯片提供两个端口，分别是70h和71h，通过这两个端口来读写CMOS，70h为地址端口，存放要访问的RAM单元的地址，71h为数据端口，存放从选定单元中读取的数据或向选定单元写入的数据外中断由CPU外部产生的中断信息，外中断源共有两类      可屏蔽中断    CPU可以不响应的中断，根据TF来决定是否响应中断，IF=1响应中断，IF=0不响应中断，在进入中断例程时使TF=0，IF=0可以屏蔽其他可屏蔽中断，若需要在进入中断例程后处理可屏蔽中断，可将IF=1          sti:IF=1      cli:IF=0            不可屏蔽的中断    CPU必须处理的外中断，对8086CPU，不可屏蔽中断的中断类型码固定为2  键盘的处理过程      键盘扫描    键盘中的芯片对键盘上的每一个键进行扫描，按下按键，芯片产生一个通码，松开按键，芯片产生一个断码，两种扫描码被送入芯片的寄存器中，寄存器端口地址为60h，读取键盘输入in al,60h    扫描码的长度为一个字节，通码的第7位为0，断码的第7位为1，断码=通码+80h        引发9号中断        执行9号中断例程  直接定址表定义数据长度的标号data segment\ta db 1,2,3,4,5,6,7,8\tb dw 0\tc dd a,bdata ends这种标号表示了地址，还表示了单元长度，如a表示了地址code:0，还表示了从该地址开始之后的单元都是字节单元加冒号的标号只能在代码段中使用，在其他段中不能使用标号还可以表示一个或一组内存单元，在指令中标号b表示code:[8]的内存单元，标号a表示一组内存单元，通过类似数组索引的方式访问a[idata]，等价于code:0[idata]，标号c处存储a和b处的偏移地址和段地址，等价于c dw offset a,seg a,offset b,seg bseg运算符取得某一标号的段地址若为dw类型，则存储偏移地址使用标号访问数据段中的数据必须将标号所在的段与段寄存器联系起来直接定址表直接获取或计算得到要查数据所在的位置的表称为直接定址表将表定义在数据段中，通过标号可直接获取到数据，简化程序或加快运算速度表中存储不同子程序的入口地址，从而实现方便地调用不同的子程序BIOS进行键盘输入和磁盘读写int9中断例程int9中断例程将从键盘读出的扫描码转化为相应的ASCII码或状态信息，存储在键盘缓冲区或状态字节中键盘缓冲区的逻辑结构为循环队列int9例程从端口读出按键的通码，然后检测状态字节，查看是否有Shift、Ctrl等控制键按下，将按键的扫描码和对应的ASCII码存到缓冲区的字单元中该例程在按键按下时调用int16h中断例程int16h中断例程中的0号子程序从键盘缓冲区中读取数据，读取的数据存放在ax中，高位存放扫描码，低位为ASCII码例程先检查缓冲区中是否存在数据，有数据时读取第一个数据，存入ax，同时将缓冲区中的数据删除该例程在程序需要读取键盘时调用，与int9调用的时刻不同int13h中断例程int13h例程用于对磁盘进行访问，通过控制磁盘控制器来访问磁盘，读写以扇区为单位参数  ah：功能号，2表示读扇区，3表示写扇区  al：操作的扇区数  ch：磁道号  cl：扇区号  dh：磁头号(面号)  dl：驱动器号  es:bx：指向接收从扇区读入的数据的内存区  返回值          成功：ah=0，al=操作的扇区数      失败：ah=出错代码      "
  },
  
  {
    "title": "K短路算法",
    "url": "/posts/k%E7%9F%AD%E8%B7%AF%E7%AE%97%E6%B3%95/",
    "categories": "算法",
    "tags": "算法, 图论, 最短路径, K短路",
    "date": "2024-06-01 18:36:00 +0800",
    





    
    "snippet": "前言在大二做树数据结构课设时，选到的题目是做一个校园地图导航应用，其中需要实现一个寻路算法，并且有一个功能需要展示到达一个地点的多种路线方案，最终采用了K短路算法，在此记录一下为了说明方便，文中用Python来实现代码堆优化Dijkstra算法Dijkstra算法是解决最短路径问题的经典算法，通过逐步扩展已知的最短路径集来找到最短路径，每次从未处理的顶点中选择一个距离源顶点最近的顶点，更新其...",
    "content": "前言在大二做树数据结构课设时，选到的题目是做一个校园地图导航应用，其中需要实现一个寻路算法，并且有一个功能需要展示到达一个地点的多种路线方案，最终采用了K短路算法，在此记录一下为了说明方便，文中用Python来实现代码堆优化Dijkstra算法Dijkstra算法是解决最短路径问题的经典算法，通过逐步扩展已知的最短路径集来找到最短路径，每次从未处理的顶点中选择一个距离源顶点最近的顶点，更新其邻居的最短路径值，直到所有顶点都处理完毕在选择距离源顶点最近的顶点这一步上，可以使用最小堆来优化，算法的时间复杂度可以降到$O(n\\log n)$​首先定义一个状态类，存储顶点和当前最短距离的状态class Entry:    def __init__(self, vertex, dist):        self.vertex = vertex        self.dist = dist    # 比较当前最短距离，用于最小堆比较    def __lt__(self, other):        return self.dist &lt; other.dist使用heapq模块实现最小堆操作，堆优化的Dijkstra算法实现如下# size：顶点个数# source：源点# graph：带权无向图，邻接矩阵visited = [False] * size  # 各顶点的访问状态dists = [inf] * size  # 源点到各顶点的最短距离heap = []  # 最小堆# 初始状态dists[source] = 0cur_v = sourceheapq.heappush(heap, Entry(cur_v, 0))while len(heap) != 0:    cur_v = heapq.heappop(heap).vertex    visited[cur_v] = True    # 当前顶点的邻接点    adjoins = [adjoin for adjoin in range(size)                if adjoin != cur_v and graph[cur_v][adjoin] != inf]    # 遍历邻接点    for adjoin in adjoins:        # 若邻接点未访问过        if not visited[adjoin]:            # 源点到当前顶点的最短距离 + 当前顶点到邻接点的距离 &lt; 源点到邻接点的最短距离            if dists[cur_v] + graph[cur_v][adjoin] &lt; dists[adjoin]:                # 更新源点到邻接点的最短距离                dists[adjoin] = dists[cur_v] + graph[cur_v][adjoin]                heapq.heappush(heap, Entry(adjoin, dists[adjoin]))运行测试用例graph = [    [0, 2, inf, 6, inf],    [2, 0, 3, 8, 5],    [inf, 3, 0, inf, 7],    [6, 8, inf, 0, 9],    [inf, 5, 7, 9, 0]]size = len(graph)source = 0dists = Dijkstra(graph, size, source)print(f'dists = {dists}')# 运行结果# dists = [0, 2, 5, 6, 7]# 顶点0到顶点1的最短距离为2# 顶点0到顶点2的最短距离为5# 顶点0到顶点3的最短距离为6# 顶点0到顶点4的最短距离为7A*算法A*算法定义了一个对当前状态的估价函数$f(x)=g(x)+h(x)$，其中$g(x)$为从初始状态到达当前状态的实际代价，$h(x)$为从当前状态到达目标状态的最佳路径的估计代价，$f(x)$为当前状态的代价值应用在最短路径问题中，在Dijkstra算法中选择距离源顶点最近的顶点这一步上，对应到A*算法，就变成了选择代价值$f(x)$​​最小的顶点，这依然可以使用最小堆来实现A*算法的关键在于估计代价$h(x)$的实现，$h(x)$也被称为启发式函数，$h(x)$计算的估计代价越精确，得到的最短路径越优，但同时越精确的代价计算消耗的时间越多，因此在$h(x)$​的实现上需要权衡精确性和速度同时，$h(x)$代价值的大小也会影响总代价值$f(x)$​  $h(x)$过小或等于0，A*算法退化为Dijkstra算法  $h(x)$过大，A*算法退化为BFS算法在导航应用中，可知某个地点的经纬度，可以看做一个网格地图，在网格地图中，有以下几种启发式函数  曼哈顿距离：$h(v)=\\lvert v_x-goal_x\\rvert+\\lvert v_y-goal_y\\rvert$  欧几里得距离：$h(v)=\\sqrt{(v_x-goal_x)^2+(v_y-goal_y)^2}$  切比雪夫距离：$h(v)=\\max(\\lvert v_x-goal_x\\rvert ,\\lvert v_y-goal_y\\rvert)$使用欧几里得距离来实现A*算法如下# h函数实现欧几里得距离def h(v, goal):    return sqrt((v[0] - goal[0]) ** 2 + (v[1] - goal[1]) ** 2)def a_star(graph, size, position, source, goal):    visited = [False] * size  # 各顶点的访问状态    dists = [inf] * size  # 源点到各顶点的最短距离    heap = []  # 最小堆    back_from = {}  # 记录回溯路径    # 初始状态    dists[source] = 0    cur_v = source    heapq.heappush(heap, Entry(cur_v, 0))    while len(heap) != 0:        cur_v = heapq.heappop(heap).vertex        visited[cur_v] = True        # 到达目标顶点停止        if cur_v == goal:            break        # 当前顶点的邻接点        adjoins = [adjoin for adjoin in range(size)                    if adjoin != cur_v and graph[cur_v][adjoin] != inf]        # 遍历邻接点        for adjoin in adjoins:            # 若邻接点未访问过            if not visited[adjoin]:                # 源点到当前顶点的最短距离 + 当前顶点到邻接点的距离 &lt; 源点到邻接点的最短距离                if dists[cur_v] + graph[cur_v][adjoin] &lt; dists[adjoin]:                    # 记录回溯路径                    back_from[adjoin] = cur_v                    # 更新源点到邻接点的最短距离                    dists[adjoin] = dists[cur_v] + graph[cur_v][adjoin]                    # 计算代价                    cost = dists[adjoin] + h(position[adjoin], position[goal])                    heapq.heappush(heap, Entry(adjoin, cost))    # 回溯路径    path = []    cur_v = goal    while cur_v in back_from:        path.append(cur_v)        cur_v = back_from[cur_v]    path.append(cur_v)    path.reverse()    return path, dists[goal]运行测试用例graph = [    [0, 2, inf, 6, inf],    [2, 0, 3, 8, 5],    [inf, 3, 0, inf, 7],    [6, 8, inf, 0, 9],    [inf, 5, 7, 9, 0]]size = len(graph)source = 0goal = 4position = [(0, 0), (2, 0), (2, 2), (0, 3), (3, 3)]path, dist = a_star(graph, size, position, source, goal)print(f'path = {path}\\ndist = {dist}')# 运行结果# path = [0, 1, 4]# dist = 7# 最短路径为0-&gt;1-&gt;4，距离为7  关于A*算法的更多介绍，可参考：Amit’s A* PagesK短路算法A*算法中每次选取的都是代价最小的顶点，这个选取就是一种取最短的最优化，当选取的顶点第一次为目标顶点时，第一条最短的路径就到达了目标顶点，那么推广一下，求第k条最短路径，也就需要选取的顶点第k次为目标顶点我们可以将visited数组保存的内容变为到达顶点的次数，每次到达一个顶点i，令visited[i] += 1，当到达的顶点为目标顶点且到达次数为k时，跳出循环此外，还有两个要注意的问题      对于visited[i] &gt; k的顶点，不应该继续遍历它们的邻接点    因为当visited[i] &gt; k时，表示已经访问了该顶点k次，那么在产生的k条最短路径中一定都经过了该顶点，也就是经过该顶点产生了k条合法的最短路径，那么该顶点的邻接点状态就不必放入最小堆中进行比较，优化了运行效率，同时，这样也可以避免当图中出现环时，算法困在环中        在将邻接点状态放入最小堆时，邻接点状态应包含邻接点的前驱顶点（也就是当前顶点）    这是在无向图或非简单有向图中会出现的问题，当遍历邻接点状态时，在无向图中会将当前顶点的前驱顶点也作为邻接点，将它的状态放入最小堆中，这可能会导致算法不停地在当前顶点和前驱顶点间跳转，陷入死循环    在Dijkstra算法或A*算法中，我们通过visited数组来判断顶点是否被访问过，在遍历邻接点状态时，将未访问过的邻接点状态放入最小堆中，这样就过滤掉了前驱顶点，因为前驱顶点必然被访问过    在K短路算法中，我们使用visited数组来记录顶点的访问次数，仅仅通过访问次数难以过滤掉前驱顶点，因此在将邻接点状态放入最小堆时，应该将当前顶点作为前驱顶点添加到状态中。在遍历下一个顶点的邻接点时，就可以通过判断邻接点是否是该顶点的前驱顶点来过滤掉前驱顶点  修改状态类，增加代价、前驱顶点信息class Entry:    def __init__(self, vertex, dist, cost, pre_entry=None):        self.vertex = vertex        self.dist = dist  # 实际距离        self.cost = cost  # 加上h(x)的代价值        self.pre_entry = pre_entry  # 前驱顶点    def __lt__(self, other):        return self.cost &lt; other.costK短路算法实现如下def h(v, goal):    return sqrt((v[0] - goal[0]) ** 2 + (v[1] - goal[1]) ** 2)def ksp(graph, size, position, source, goal, k):    visited = [0] * size  # 各顶点的访问次数    heap = []  # 最小堆    # 初始状态    cur_entry = Entry(source, 0, 0)    heapq.heappush(heap, cur_entry)    while len(heap) != 0:        cur_entry = heapq.heappop(heap)        cur_v = cur_entry.vertex        pre_entry = cur_entry.pre_entry        # 增加访问次数        visited[cur_v] += 1        # 到达目标顶点停止        if cur_v == goal and visited[cur_v] == k:            break        # 访问次数大于k，跳过        if visited[cur_v] &gt; k:            continue        # 当前顶点的邻接点        adjoins = [adjoin for adjoin in range(size)                   if adjoin != cur_v and graph[cur_v][adjoin] != inf]        # 遍历邻接点        for adjoin in adjoins:            # 当邻接点不是前驱顶点            if pre_entry is None or pre_entry.vertex != adjoin:                # 计算代价                dist = cur_entry.dist + graph[cur_v][adjoin]                cost = dist + h(position[adjoin], position[goal])                heapq.heappush(heap, Entry(adjoin, dist, cost, cur_entry))    # 回溯路径    dist = cur_entry.dist    path = []    while cur_entry is not None:        path.append(cur_entry.vertex)        cur_entry = cur_entry.pre_entry    path.reverse()    return path, dist运行测试用例graph = [    [0, 2, inf, 6, inf],    [2, 0, 3, 8, 5],    [inf, 3, 0, inf, 7],    [6, 8, inf, 0, 9],    [inf, 5, 7, 9, 0]]size = len(graph)source = 0goal = 4position = [(0, 0), (2, 0), (2, 2), (0, 3), (3, 3)]for k in range(1, 9):    path, dist = ksp(graph, size, position, source, goal, k)    print(f'第{k}短路: ( path = {path}, dist = {dist} )')    # 运行结果# 第1短路: ( path = [0, 1, 4], dist = 7 )# 第2短路: ( path = [0, 1, 2, 4], dist = 12 )# 第3短路: ( path = [0, 3, 4], dist = 15 )# 第4短路: ( path = [0, 1, 3, 4], dist = 19 )# 第5短路: ( path = [0, 3, 1, 4], dist = 19 )# 第6短路: ( path = [0, 1, 4, 2, 1, 4], dist = 22 )# 第7短路: ( path = [0, 1, 3, 0, 1, 4], dist = 23 )# 第8短路: ( path = [0, 3, 1, 2, 4], dist = 24 )算法应用下面是当时实现的地图应用的截图，背景的地图使用的是高德的地图，地图上的地点以及路线均是通过K短路算法计算得到，再使用高德的API绘制在地图上当前算法在一般情况下的运行效果不错，但当选定的两个地点过近时，计算得到的路径会有环（上面运行的示例结果中有包含环的结果），当前算法没有解决这一点，在应用中实现了一个过滤机制，若某条路径的路程大于等于最短路径路程的两倍，则去除该路径，经过该过滤机制，得出的路径结果已基本满足需求"
  },
  
  {
    "title": "requests库基础",
    "url": "/posts/requests/",
    "categories": "Python, 爬虫",
    "tags": "requests, Python, 爬虫",
    "date": "2024-05-29 22:53:00 +0800",
    





    
    "snippet": "开始requests库是Python中常用的HTTP请求库安装requestspip install requests发送请求requests中支持多种HTTP的请求方法response = requests.get('https://api.github.com/events')  # get方法response = requests.post('http://httpbin.org/po...",
    "content": "开始requests库是Python中常用的HTTP请求库安装requestspip install requests发送请求requests中支持多种HTTP的请求方法response = requests.get('https://api.github.com/events')  # get方法response = requests.post('http://httpbin.org/post', data = {'key':'value'})  # post方法response = requests.put('http://httpbin.org/put', data = {'key':'value'})  # put方法response = requests.delete('http://httpbin.org/delete')  # delete方法response = requests.head('http://httpbin.org/get')  # head方法response = requests.options('http://httpbin.org/get')  # options方法获取响应requests请求方法返回一个Response对象，通过该对象获取响应            常用属性/方法      描述                  text      响应文本内容              content      响应内容的二进制形式              status_code      响应状态码              headers      响应头字典              encoding      响应的编码方式，响应头的Content-Type字段              cookies      响应中包含的cookie字典              reason      响应状态码相对应的描述文本              url      最终响应的url              raw      响应的原始HTTPResponse对象              history      当前请求的响应历史（重定向）              elapsed      从发送请求到响应到达的时间              request      响应的请求对象              json()      若响应中的内容是json字符串时，将json字符串解码为字典类型              raise_for_status()      当状态码为4XX或5XX时，该方法抛出异常      请求设置设置请求头在请求方法的headers参数传入一个字典，字典中可以设置请求头字段url = 'https://api.github.com/some/endpoint'headers = {'user-agent': 'my-app/0.0.1'}response = requests.get(url, headers=headers)参数传递对于get请求，在get方法的params参数传入一个字典，可以传递url参数payload = {'key1': 'value1', 'key2': 'value2'}response = requests.get('http://httpbin.org/get', params=payload)# http://httpbin.org/get?key2=value2&amp;key1=value1对于post请求，在post方法的data参数传入一个字典，可以传递表单数据payload = {'key1': 'value1', 'key2': 'value2'}response = requests.post(\"http://httpbin.org/post\", data=payload)data参数可以接收一个json格式的字符串，自动解码为字典，或json参数可以接收一个字典，自动编码为json字符串import jsonurl = 'https://api.github.com/some/endpoint'payload = {'some': 'data'}r = requests.post(url, data=json.dumps(payload))r = requests.post(url, json=payload)通过files参数上传文件url = 'http://www.example.com/upload'headers = {'Content-Type': 'multipart/form-data'}files = {'file': open('example.txt', 'rb')}  # 设置文件数据response = requests.post(url, files=files, headers=headers)Cookie在请求方法的cookies参数中传入一个字典即可在请求中包含cookieurl = 'http://httpbin.org/cookies'cookies = dict(cookies_are='working')r = requests.get(url, cookies=cookies)cookies参数还可以传入一个RequestsCookieJar对象，类似一个字典，但包含更多接口jar = requests.cookies.RequestsCookieJar()jar.set('tasty_cookie', 'yum', domain='httpbin.org', path='/cookies')jar.set('gross_cookie', 'blech', domain='httpbin.org', path='/elsewhere')url = 'http://httpbin.org/cookies'r = requests.get(url, cookies=jar)通过response对象的cookies属性可以获取响应中的cookie，cookies属性返回一个字典url = 'http://example.com/some/cookie/setting/url'r = requests.get(url)r.cookies['example_cookie_name']超时在请求方法中设置timeout参数来设置超时时间，当请求超时，不再等待响应，抛出Timeout异常requests.get('http://github.com', timeout=0.001)其他异常requests中抛出以下常见异常  遇到网络问题（如：DNS查询失败、拒绝连接等）时，requests会抛出一个ConnectionError异常  如果HTTP请求返回了不成功的状态码，raise_for_status()会抛出一个HTTPError异常  若请求超时，则抛出一个Timeout异常  若请求超过了设定的最大重定向次数，则会抛出一个TooManyRedirects异常"
  },
  
  {
    "title": "Numpy基础",
    "url": "/posts/numpy/",
    "categories": "Python",
    "tags": "Numpy, Python, 数据分析",
    "date": "2024-05-29 18:39:00 +0800",
    





    
    "snippet": "ndarray对象numpy定义了一个ndarray对象，表示一个多维数组，numpy操作都是基于ndarray进行使用np.array方法创建一个ndarray对象np.array(object, dtype = None, copy = True, order = None, ndmin = 0)      object：传入的序列对象，可以是列表或元组        dtype：通过该...",
    "content": "ndarray对象numpy定义了一个ndarray对象，表示一个多维数组，numpy操作都是基于ndarray进行使用np.array方法创建一个ndarray对象np.array(object, dtype = None, copy = True, order = None, ndmin = 0)      object：传入的序列对象，可以是列表或元组        dtype：通过该参数设置数组的数据类型        copy：设置该ndarray对象能否被复制        order：设置数组的存储顺序，可选C(行序列)，F(列序列)，A(默认)        ndim：指定数组的维度  dtype对象dtype对象用于描述数组元素的数据类型，大小和字节顺序使用np.dtype方法创建一个numpy数据类型numpy.dtype(object, align, copy)  object：要转换为的数据类型对象  align：如果为true，则该类型使用字节对齐  copy：复制dtype对象 ，如果为false，则是对内置数据类型对象的引用使用数据类型对象定义结构化数据，可以使ndarray实现字典的索引方式import numpy as npteacher = np.dtype([('name','S20'), ('age', 'i1'), ('salary', 'f4')])#将其应用于ndarray对象b = np.array([('ycs', 32, 6357.50),('jxe', 28, 6856.80)], dtype = teacher)print(b['name']) # 字符串类型只支持ASCII数组属性以下是ndarray对象的一些常用属性      ndarray.shape：返回一个以数组维度大小为元素的元组，从下标0到n，可称为轴0到轴n，可以直接设置该属性或使用reshape函数来改变维度      import numpy as np   a = np.array([[1,2,3],[4,5,6]])   a.shape =  (3,2)    print (a)      # 使用reshape函数，reshape函数不会创建副本，依然使用原来的引用，因此修改b元素，a元素也会改变  b = a.reshape(3,2)    print (b)            ndarray.ndim：返回数组的维度个数，即shape返回值的元素个数，该属性只读        ndarray.itemsize：返回每个元素的字节大小        ndarray.flags：返回数组的内存信息        ndarray.size：数组的元素个数        ndarray.dtype：数组的数据类型  创建数组基本数组      empty    使用np.empty()创建一个未初始化的数组    np.empty(shape, dtype = float, order = 'C')              shape：指定数组的形状，传入一个元组      dtype：指定数组的数据类型      order：指定数组的存储顺序，可选C(行序列)，F(列序列)，A(默认)            zeros    使用np.zeros()创建一个所有值均为0的数组，参数同empty()        ones    使用np.zeros()创建一个所有值均为1的数组，参数同empty()        asarray    从已有的ndarray创建数组，与array()不同的是array()返回的是一个副本，asarray()返回的是一个引用，原数组修改或返回的新数组修改都会改变数据    numpy.asarray(a, dtype = None, order = None)            frombuffer    使用指定的缓冲区创建数组    np.frombuffer(buffer, dtype = float, count = -1, offset = 0)              buffer：将任意对象转换为流的形式读入缓冲区      dtype：数组的数据类型，默认是float32      count：要读取的数据数量，默认为-1表示读取所有数据      offset：读取数据的起始位置，默认为0            fromiter    将可迭代对象转化为ndarray数组，返回一个一维数组    np.fromiter(iterable, dtype, count = -1)              iterable：可迭代对象      dtype：数组的数据类型      count：读取的数据数量，默认为-1，读取所有数据      区间数组      arange    指定一个数值范围创建ndarray      np.arange(start, stop, step, dtype)              start：起始数值      stop：终止值，范围为左闭右开      step：步长值，默认为1      dtype：数据类型            linspace    创建等差数列ndarray      np.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None)              start：数值区间的起始值      stop：数值区间的终止值      num：表示数值区间内要生成多少个均匀的样本。默认值为50      endpoint：默认为True，表示数列包含stop终止值，反之不包含      retstep：默认为False，表示生成的数组中会显示公差（间距），反之不显示      dtype：数组元素值的数据类型            logspace    创建等比数列ndarray      np.logspace(start, stop, num=50, endpoint=True, base=10.0, dtype=None)              start，stop：起始值，终止值      num：生成的数组元素个数，默认为50      endpoint：设置是否包含终止值，默认为True      base：设置对数函数的底数，默认为10      dtype：指定数组的数据类型      索引与切片一维数组使用内置函数slice()创建一个切片对象，再对ndarray切片arr = np.arange(10)s = slice(2, 7, 2)  # 创建切片对象arr[s]  # 访问切片内容# array([2, 4, 6])使用:索引对于一维数组，其基本格式为[start:stop:step]，start和stop为左闭右开arr = np.arange(10)arr# array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])arr[2:7:2]# array([2, 4, 6])arr[2:]  # 从[2]开始之后的所有项# array([2, 3, 4, 5, 6, 7, 8, 9])arr[:7]  # 在[7]之前的所有项，不包括[7]# array([0, 1, 2, 3, 4, 5, 6])arr[:]  # 等价于arr[::]，取当前维度所有项# array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])arr[::2]  # 按步长切片# array([0, 2, 4, 6, 8])多维数组切片使用:索引，按从外到内的顺序，对每一个维度进行切片，基本格式为start:stop:step，不同维度用逗号隔开arr[2:4, :] # 二维，取第三行和第四行arr[:, 2:4] # 取第三列和第四列使用省略号来表示某一维度的全索引，等价于:或::# 二维arr[2:4, ...] # 取第三行和第四行arr[2, ...] # 取第三行arr[..., 1:4] # 取第二列到第四列arr[..., 1] # 取第二列高级索引numpy不止可以通过单个整数索引，也可以通过其他方式来索引，主要有整数数组索引、布尔索引整数数组索引使用一个数组来索引另一个数组x = np.array([[1,  2],  [3,  4],  [5,  6]])# 行维度上访问[0, 1, 2]，列维度上访问[0, 1, 0]# 对应组成坐标(0, 0), (1, 1), (2, 0)x[[0, 1, 2],  [0, 1, 0]]  # [1  4  5]索引数组的维度影响结果的维度x = np.array([[1,  2],  [3,  4],  [5,  6]])# 索引数组为一维，结果是一维x[[0, 1, 2, 2], [0, 1, 0, 1]]  # array([1, 4, 5, 6])# 索引数组为二维，则结果也是二维x[[[0, 1], [2, 2]],  [[0, 1], [0, 1]]]# array([[1, 4],#        [5, 6]])索引数组可以与:或...配合x = np.array([[1,  2],  [3,  4],  [5,  6]])x[1:3, [0, 1]]# array([[3, 4],#        [5, 6]])使用一个索引数组只访问一个维度x = np.array([[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10, 11]])x[[1, 2]]  # 一个数组只访问行维度# array([[3, 4, 5],#        [6, 7, 8]])布尔索引使用逻辑表达式进行索引x = np.array([[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10, 11]]) x[x &gt; 5] # 取数组中大于5的元素# array([ 6,  7,  8,  9, 10, 11])广播机制广播机制用于解决不同形状的数组之间进行运算的问题广播机制经过以下步骤      补齐：以两个数组中的最大ndim值为准，其他数组在高维上（shape元组左侧）补1    例如，a数组的shape为(4, 3)，b数组的shape为(3,)，则b数组补齐为(1, 3)        比较：依次比较两个数组的各个维度大小，若不相等且其中一个维度值不为1，则报错    例如，a数组的shape为(4, 3)，b数组的shape为(3, 1)，比较shape[0]时，不相等且其中一个值不为1，报错    例如，a数组的shape为(4, 3)，b数组的shape为(1, 3)          比较shape[0]，其中一个值为1，通过      比较shape[1]，二者相等，通过            扩展：在比较时，将维度大小为1的维度对应的元素复制多个，使其维度大小与另一数组对应维度大小相等    例如，a数组的shape为(4, 3)，b数组为[[0, 1, 2]]，shape为(1, 3)，维度大小为1维度对应的元素为[0, 1, 2]，复制该元素，将维度大小扩展到4，即b数组变为[[0, 1, 2], [0, 1, 2], [0, 1, 2], [0, 1, 2]]，shape变为(4, 3)        运算：两个数组经过以上处理后，若shape相同，则可以运算  e.g. x = [0, 1, 2], y = [[0], [1], [2]]  x的shape为(1, 3)，扩展为(3, 3)，数组变为[[0, 1, 2], [0, 1, 2], [0, 1, 2]]  y的shape为(3, 1)，扩展为(3, 3)，数组变为[[0, 0, 0], [1, 1, 1], [2, 2, 2]]x = np.array([0, 1, 2])y = np.array([0, 1, 2])y = y.reshape((3, 1))x + y# array([[0, 1, 2],#        [1, 2, 3],#        [2, 3, 4]])遍历数组使用numpy的nditer迭代器对象，配合for进行遍历，迭代器的遍历顺序与数组的存储顺序一致import numpy as npa = np.arange(0, 60, 5)a = a.reshape(3, 4)# 使用nditer迭代器,并使用for进行遍历# 若传入a.T，存储顺序不改变，依然按行序遍历for x in np.nditer(a):   print(x)  order：指定迭代器的遍历顺序  op_flags：表示能否在遍历时修改数据，默认为readonly，可选readwrite，writeonly遍历多个数组时，可以触发广播机制import numpy as npa = np.arange(0, 60, 5)a = a.reshape(3, 4)print (a)b = np.array([1, 2, 3, 4], dtype = int)print (b） # 广播迭代for x,y in np.nditer([a,b]): # 传入两个数组组成的列表    print (\"%d:%d\" % (x,y),end=\",\")# 0:1, 5:2, 10:3, 15:4, 20:1, 25:2, 30:3, 35:4, 40:1, 45:2, 50:3, 55:4数组操作展平            名称      描述                  ndarray.reshape()      在不改变数组元素的条件下，修改数组的形状- arr：输入数组- newshape：元组，新形状              ndarray.flat      返回一个迭代器，可以用for循环遍历其中的每一个元素              ndarray.flatten()      以一维数组的形式返回一份数组的副本- order：指定展开顺序，可选C（按行）、F（按列）、A（原顺序）、K（存储顺序）              np.ravel()      返回一个展开的一维数组视图- arr：输入数组- order：指定展开顺序，可选C（按行）、F（按列）、A（原顺序）、K（存储顺序）      轴操作            名称      描述                  np.transpose()      将数组的维度值进行对换- arr：输入数组- axes：整数数组，指定要对换的轴              ndarray.T      与transpose方法相同              np.rollaxis()      将指定的轴移动到指定位置- arr：输入数组- axis：整数，指定移动的轴- start：整数，指定移动的位置              np.swapaxes()      交换指定的两个轴- arr：输入数组- axis1：整数，指定交换的第一个轴- axis2：整数，指定交换的第二个轴      维度操作            名称      描述                  np.broadcast()      生成一个模拟广播结果的对象- arr1：指定要广播的数组- arr2：指定数组作为广播基准              np.broadcast_to()      将数组广播为新的形状，返回一个只读视图- arr：输入数组- shape：元组，广播目标形状              np.expand_dims()      在数组中插入新的轴- arr：输入数组- axis：整数，指定插入位置              np.squeeze()      默认删除所有维度大小为1的轴- arr：输入数组- axis：整数或整数元组，指定需要删除的轴，指定的轴的维度大小必须为1，否则报错      连接数组            名称      描述                  np.concatenate()      沿指定轴连接数组- arrs：包含数组的元组- axis：整数，指定连接轴，默认为0              np.stack()      生成新的轴堆叠数组，轴的维度大小是输入数组的个数- arrs：包含数组的元组- axis：整数，指定生成轴的位置              np.hstack()      水平堆叠序列中的数组（列方向）- arrs：包含数组的元组              np.vstack()      竖直堆叠序列中的数组（行方向）- arrs：包含数组的元组      分割数组            名称      描述                  np.split()      将数组分割为多个子数组- arr：输入数组- indices_or_sections：整数或数组，输入整数时，表示分割子数组个数，输入数组时，表示分割位置，左开右闭- axis：整数，在指定轴上切分              np.hsplit()      将一个数组水平分割为多个子数组（按列）- arr：输入数组- sections：整数，表示分割子数组个数              np.vsplit()      将一个数组垂直分割为多个子数组（按行）- arr：输入数组- sections：整数，表示分割子数组个数      元素修改            名称      描述                  np.resize()      修改数组大小，返回指定shape的新数组- arr：输入数组- shape：元组，新形状              np.append()      默认将数组展平后，在末尾添加元素值，返回新数组- arr：输入数组- values：插入值，除了axis指定的插入轴，其他轴的维度大小要与arr相等- axis：整数，指定插入轴              np.insert()      默认将数组展平，将值插入到指定数组指定位置，返回新数组- arr：输入数组- index：整数，指定插入位置- values：插入值，可广播为arr形状- axis：整数，指定插入的轴              np.delete()      默认将数组展平后，删除指定位置的元素，返回新数组- arr：输入数组- index：整数，指定删除位置- axis：整数，指定删除的轴              np.unique()      将一个数组展平后，删除数组中重复的元素，返回新数组- arr：输入数组- return_index：若为True，则返回新数组元素在原数组中的索引- return_inverse：若为True，则返回原数组元素在新数组中的索引- return_counts：若为True，则返回去重后的数组元素在原数组中出现的次数      位运算            函数      描述                  np.bitwise_and()      按位与，对数组元素执行位与操作              np.bitwise_or()      按位或，对数组元素执行位或操作              np.bitwise_xor()      按位异或              np.bitwise_not()      按位取反              np.invert()      按位取反              np.left_shift()      左移位运算，向左移动二进制表示的位              np.right_shift()      右移位运算，向右移动二进制表示的位              bin()      返回指定数值的二进制形式      字符串处理字符串处理函数定义在numpy.char类中，函数的处理对象是dtype为string_或unicode_的字符串数组            函数名称      描述                  add()      输入多个字符串数组，对数组中相应位置的字符串做连接操作              multiply()      将一个字符串复制多次后连接，返回连接字符串副本              center()      用于居中字符串，并将指定的字符填充在原字符串的左右两侧              capitalize()      将字符串第一个字母转换为大写              title()      将字符串的每个单词的第一个字母转换为大写形式              lower()      将数组中所有的字符串转换为小写              upper()      将数组中所有的字符串转换为大写              split()      指定分隔符对字符串进行分割，并返回一个数组序列，默认分隔符为空格              splitlines()      以换行符作为分隔符来分割字符串，并返回数组序列              strip()      删除字符串开头和结尾处的指定字符              join()      指定一个分隔符或一个分隔符列表来连接数组中的所有字符串，分隔符列表与每个字符串一一对应              replace()      用新的字符串替换原字符串中指定的子串              decode()      用指定的编码格式对数组中的字符串依次执行解码操作              encode()      用指定的编码格式对数组中的字符串依次执行编码操作      数学函数三角函数            名称      描述                  np.sin()      正弦函数              np.cos()      余弦函数              np.tan()      正切函数              np.arcsin()      反正弦函数              np.arccos()      反余弦函数              np.arctan()      反正切函数              np.degrees()      将弧度值转换为角度值              x * np.pi / 180      将角度值转换为弧度值      舍入函数            名称      描述                  np.around()      返回指定数的四舍五入值，decimals参数指定舍入的小数位数              np.floor()      向下取整              np.ceil()      向上取整      算术运算            名称      描述                  np.add()      两个数组对应元素相加              np.subtract()      两个数组对应元素相减              np.multiple()      两个数组对应元素相乘              np.divide()      两个数组对应元素相除              np.reciprocal()      返回数组元素的倒数              np.power()      返回数组对应元素的幂              np.mod()      返回数组对应元素的取余      统计函数            名称      描述                  np.amin()      返回数组或沿某个轴的最小值- arr：输入数组- axis：整数，指定轴              np.amax()      返回数组或沿某个轴的最大值- arr：输入数组- axis：整数，指定轴              np.ptp()      返回数组或沿某个轴上的极差- arr：输入数组- axis：整数，指定轴              np.percentile()      返回数组中的百分位数- arr：输入数组- q：数值，指定要计算的百分位数- axis：整数，指定轴              np.median()      返回数组或沿某个轴的中位数- arr：输入数组- axis：整数，指定轴              np.mean()      返回数组或沿某一个轴的算术平均值- arr：输入数组- axis：整数，指定轴              np.average()      返回数组或沿某个轴的加权平均值- arr：输入数组- axis：整数，指定轴- weights：数值列表，指定每个元素的权重- returned：若为True，同时返回权重之和              np.var()      返回数组或沿某个轴的方差- arr：输入数组- axis：整数，指定轴              np.std()      返回数组或沿某个轴的标准差- arr：输入数组- axis：整数，指定轴      排序和搜索            名称      描述                  np.sort()      默认将数组展平后排序，返回一个副本- arr：输入数组- axis：沿着指定轴进行排序- kind：默认为quicksort，可选mergesort，heapsort- order：字符串或字符串列表，指定排序字段              np.argsort()      返回沿指定轴上元素升序的索引序列- arr：输入数组- axis：整数，指定轴- kind：默认为quicksort，可选mergesort，heapsort- order：字符串或字符串列表，指定排序字段              np.lexsort()      将多个数组的对应位置元素组成数对，对数对进行排序，返回升序的索引序列- arrs：包含多个数组的元组- axis：整数，指定轴              np.argmin()      返回某个轴上的最大值的索引- arr：输入数组- axis：整数，指定轴              np.argmax()      返回某个轴上的最小值的索引- arr：输入数组- axis：整数，指定轴              np.nonzero()      返回数组中非0元素的索引序列- arr：输入数组              np.where()      返回数组中满足条件的元素的索引序列- condition：使用数组的逻辑表达式              np.extract()      返回数组中满足条件的元素- condition：使用数组的逻辑表达式- arr：输入数组      IO操作numpy中提供了一些IO函数，用于在文件中读写ndarray对象可操作的文件类型  .npy文件  .txt文件  .npz文件            名称      描述                  np.save()      将数组保存.npy文件中- file：字符串，保存后的文件名称，文件后缀为.npy- arr：保存的数组- allow_pickle：若为True，表示允许使用pickle序列化保存数组对象              np.load()      从.npy文件、.npz文件或pickle文件中读入数组- filename：字符串，文件路径- encoding：字符串，指定编码- allow_pickle：若为True，表示允许加载.npy文件中的pickle对象              np.savez()      将多个数组保存到.npz文件中- file：字符串，保存后的文件名称，文件后缀为.npz- args：保存的多个数组，自动命名为arr_0、arr_1等- kwargs：保存的多个数组，通过key为数组value指定名称              np.savetxt()      将数组保存在.txt文件中- filename：字符串，保存后的文件名称，文件后缀为.txt- X：保存的一维或二维数组- fmt：字符串或字符串列表，指定元素的表示格式- delimiter：字符串，指定元素之间的分隔符- newline：字符串，指定换行符- header：字符串，指定文件开头内容- footer：字符串，指定文件末尾内容- comments：字符串，指定注释符号，默认为#- encoding：字符串，指定编码              np.loadtxt()      从.txt文件中读取数组- filename：字符串，文件路径- dtype：dtype对象，指定元素数据类型- comments：字符串，指定注释符号，默认为#- delimiter：字符串，指定元素分隔符- skiprows：整数，指定跳过的行数- usecols：整数或整数序列，指定读取的列- unpack：若为True，表示以解包形式返回数组- ndim：整数，指定返回数组的最低维度，可选0，1，2- encoding：字符串，指定编码- max_rows：整数，指定读取的最大行数，不包含skiprows- converters：函数或字典，对数组的每列执行指定转换函数，或对字典中的指定列数执行对应的转换函数      "
  },
  
  {
    "title": "MongoDB基础指南",
    "url": "/posts/mongodb/",
    "categories": "数据库",
    "tags": "MongoDB, 数据库, Database",
    "date": "2024-05-26 15:39:00 +0800",
    





    
    "snippet": "开始MongoDB是一个基于文档的NoSQL数据库官网：MongoDB官方文档：MongoDB 文档MongoDB使用集合（Collections）来组织文档（Documents），每个文档都是由键值对组成的  数据库（Database）：存储数据的容器，类似于关系型数据库中的数据库  集合（Collection）：数据库中的一个集合，类似于关系型数据库中的表  文档（Document）：集...",
    "content": "开始MongoDB是一个基于文档的NoSQL数据库官网：MongoDB官方文档：MongoDB 文档MongoDB使用集合（Collections）来组织文档（Documents），每个文档都是由键值对组成的  数据库（Database）：存储数据的容器，类似于关系型数据库中的数据库  集合（Collection）：数据库中的一个集合，类似于关系型数据库中的表  文档（Document）：集合中的一个数据记录，操作最小单位，类似于关系型数据库中的行，以BSON格式存储相关术语对比            SQL 术语/概念      MongoDB 术语/概念      解释/说明                  database      database      数据库              table      collection      数据库表/集合              row      document      数据记录行/文档              column      field      数据字段/域              index      index      索引              table joins             表连接,MongoDB不支持              primary key      primary key      主键,MongoDB自动将_id字段设置为主键      基本操作基本命令  show dbs：查看所有数据库  use my_db：使用数据库，MongoDB中的数据库不需要手动创建，当添加文档时，数据库会自动创建  show collections：查看当前数据库的集合  db：表示当前数据库，使用该对象操作当前数据库          db.createCollection(\"myNewCollection\")：在当前数据库中创建集合，当添加文档时才创建      db.myNewCollection.drop()：删除集合      db.dropDatabase()：删除当前数据库      数据库CRUD插入文档插入文档使用以下方法  insertOne()：插入一个文档，传入一个json格式的对象  insertMany()：插入多个文档，传入一个数组db.myCollection.insertOne({    name: \"Alice\",    age: 25,    city: \"New York\"});db.myCollection.insertMany([    { name: \"Bob\", age: 30, city: \"Los Angeles\" },    { name: \"Charlie\", age: 35, city: \"Chicago\" }]);  插入时如果没有指定_id字段，则自动创建唯一的_id作为主键更新文档更新文档使用以下方法  updateOne：更新一个文档  updateMany：更新多个文档  replaceOne：替换一个文档，替换除_id字段之外的文档的所有内容updateOne方法和updateMany方法传入三个参数，分别是fileter，update，options  fileter：传入一个json对象，指定要过滤的key，value为一个值或一个表示条件的json对象  update：传入一个json对象，通过操作符指定更新的行为db.myCollection.updateOne(    { name: \"Alice\" },  // 过滤条件    { $set: { age: 26 } },  // 更新操作，使用set操作符更新值    { upsert: false }  // 可选参数);db.myCollection.updateMany(    { age: { $lt: 30 } },  // 过滤条件，该条件可以匹配多个文档    { $set: { status: \"active\" } },  // 更新操作    { upsert: false }  // 可选参数);db.myCollection.replaceOne(    { name: \"Bob\" },  // 过滤条件    { name: \"Bob\", age: 31 }  // 新文档的内容);删除文档删除文档使用以下方法  deleteOne：删除一个文档  deleteMany：删除多个文档两个方法传入一个fileter参数和一个options参数，filter参数指定过滤条件db.myCollection.deleteOne({ name: \"Alice\" });db.myCollection.deleteMany({ status: \"inactive\" });查询文档查询文档使用以下方法  find：查询多个文档  findOne：查询一个文档两个方法传入一个filter参数和projection参数，filter参数指定过滤条件db.myCollection.find({ age: { $gt: 25 } });db.myCollection.findOne({ name: \"Alice\" });projection参数表示投影，指定返回的字段db.myCollection.find(    { age: { $gt: 25 } },    { name: 1, age: 1, _id: 0 }  // 返回name和age字段，不返回_id，若不指定_id: 0，则默认返回_id);其他查询操作      排序：sort方法    db.myCollection.find().sort({ age: -1 });  // 按age降序db.myCollection.find().sort({ age: 1, name: -1 });  // 按age升序，按name降序            跳过：skip方法    db.myCollection.find().skip(5);  // 跳过前5个文档            限制：limit方法    db.myCollection.find().limit(10);  // 返回前10个文档      条件操作符MongoDB中使用一个json对象表示一个条件，条件操作符作为key比较操作符比较操作符的value为一个值或一个数组            操作符      描述      示例                  $eq      等于      { age: { $eq: 25 } }              $ne      不等于      { age: { $ne: 25 } }              $gt      大于      { age: { $gt: 25 } }              $gte      大于等于      { age: { $gte: 25 } }              $lt      小于      { age: { $lt: 25 } }              $lte      小于等于      { age: { $lte: 25 } }              $in      在指定的数组中      { age: { $in: [25, 30, 35] } }              $nin      不在指定的数组中      { age: { $nin: [25, 30, 35] } }      逻辑操作符逻辑操作符的value为一个数组，其中每个元素是一个条件json对象            操作符      描述      示例                  $and      逻辑与，符合所有条件      { $and: [ { age: { $gt: 25 } }, { city: \"New York\" } ] }              $or      逻辑或，符合任意条件      { $or: [ { age: { $lt: 25 } }, { city: \"New York\" } ] }              $not      取反，不符合条件      { age: { $not: { $gt: 25 } } }              $nor      逻辑与非，均不符合条件      { $nor: [ { age: { $gt: 25 } }, { city: \"New York\" } ] }      元素操作符元素操作符指定元素相关的条件            操作符      描述      示例                  $exists      字段是否存在      { age: { $exists: true } }              $type      字段的BSON类型      { age: { $type: \"int\" } }              $regex      字段值匹配正则表达式      { name: { $regex: /^A/ } }      数组操作符            操作符      描述      示例                  $all      数组包含所有指定的元素      { tags: { $all: [\"red\", \"blue\"] } }              $elemMatch      数组中的元素匹配指定条件      { results: { $elemMatch: { score: { $gt: 80 } } } }              $size      数组的长度等于指定值      { tags: { $size: 3 } }      聚合操作MongoDB的聚合操作使用aggregate方法，传入一个数组，数组中的每个对象表示一个聚合管道，每个管道的返回值会作为下一个管道的输入，管道操作符如下            操作符      描述                  $project      修改输入文档的结构，可以用来重命名、增加或删除域，也可以用于创建计算结果以及嵌套文档              $match      用于过滤数据，只输出符合条件的文档，使用MongoDB的标准查询操作              $limit      用来限制MongoDB聚合管道返回的文档数              $skip      在聚合管道中跳过指定数量的文档，并返回余下的文档              $unwind      将文档中的某一个数组类型字段拆分成多个文档，每个文档的该字段为数组中的一个值              $group      将集合中的文档分组，可用于统计结果              $sort      将输入文档排序后输出      $project将所有文档投影，不返回_id需要显示指定db.article.aggregate([    {        $project : {            _id : 0,            title : 1,            author : 1        }    }]);$match接收一个条件json对象筛选匹配的文档db.article.aggregate([    { $match : { score : { $gt : 70, $lte : 90 } } }]);$skip下一个管道跳过指定数量文档db.article.aggregate([    { $skip : 5 }]);$limit指定输入下一个管道的文档数量db.article.aggregate([    { $limit: 5 }]);$unwind将文档中的某一个数组类型字段拆分成多个文档，每个文档的该字段为数组中的一个值，指定数组字段时在前面加$// ages: [1, 2, 3]db.article.aggregate([    { $unwind: \"$ages\" }])// result[  { _id: ObjectId('66526805ab4236a343cdcdf6'), ages: 1 },  { _id: ObjectId('66526805ab4236a343cdcdf6'), ages: 2 },  { _id: ObjectId('66526805ab4236a343cdcdf6'), ages: 3 }]$sort将文档排序后输出db.article.aggregate([    {        \"$sort\": {            \"pop\": -1,  // 降序            \"city\": 1  // 升序        }    }])$group将集合中的文档分组，可以使用聚合操作符来统计结果，接收的json对象包含两类字段  _id：指定分组的字段，字段前加$  field：自定义聚合结果字段名，接收一个json对象，其中使用聚合操作符作为key，聚合字段作为valuedb.article.aggregate([    {        $group: {            _id: \"$state\",  // 按state字段分组            totalPop: {                $sum: \"$pop\"  // 统计pop字段总和，结果字段为totalPop            },            avgPop: {                $avg: \"$pop\"  // 统计pop字段的平均值，结果字段为avgPop            },            count: {                $sum: 1  // 统计每个分组的文档数量，结果字段为count            }        }    }])常用聚合操作符如下            表达式      描述                  $sum      计算总和              $avg      计算平均值              $min      获取集合中所有文档指定字段的最小值              $max      获取集合中所有文档指定字段的最大值              $push      将值加入一个数组中，不会判断是否有重复的值              $addToSet      将值加入一个数组中，会判断是否有重复的值，若相同的值在数组中已经存在了，则不加入              $first      根据文档的排序获取第一个文档数据              $last      根据文档的排序获取最后一个文档数据      数据库引用mongodb中不支持连接查询，在文档使用三个特殊字段来引用其他文档引用的基本格式{    $ref: \"collection_name\",     $id: ObjectId(\"...\"),     $db: \"db_name\" }e.g. 在user文档中引用address文档{   \"_id\": ObjectId(\"53402597d852426020000002\"),   \"address\": {       \"$ref\": \"address_home\",       \"$id\": ObjectId(\"534009e4d852427820000002\"),       \"$db\": \"runoob\"   },   \"contact\": \"987654321\",   \"dob\": \"01-01-1991\",   \"name\": \"Tom Benzamin\"}在查询时需要分步查询var user = db.users.findOne({\"name\":\"Tom Benzamin\"})var dbRef = user.addressdb[dbRef.$ref].findOne({\"_id\":ObjectId(dbRef.$id)})ObjectIdmongodb中默认使用ObjectId对象来作为_id字段的值，ObjectId是一个12字节BSON类型数据，有以下格式  前4个字节表示时间戳  接下来的3个字节是机器标识码  紧接的2个字节由进程id组成（PID）  最后3个字节是随机数调用ObjectId()创建ObjectId，mongodb会自动生成一个唯一idvar newObjectId = ObjectId()ObjectId中存储了4个字节的时间戳，getTimestamp()来获取时间戳var myId = ObjectId()myId.getTimestamp()"
  },
  
  {
    "title": "PowerJekyll开发记录",
    "url": "/posts/powerjekyll/",
    "categories": "博客开发",
    "tags": "Jekyll, PowerShell, CLI",
    "date": "2024-05-24 16:31:00 +0800",
    





    
    "snippet": "项目背景前段时间写了挺多博客，一直是用jekyll-compose（github）来完成创建、发布等功能，但使用过程中也遇到挺多不满意的地方，比如命令太长、typora-root-url加上引号导致typora预览失效、不能在任意目录执行命令等起初，我使用git bash来代替Windows下的cmd，编写了一个shell脚本来封装compose的命令，解决了命令太长的问题，但功能始终不够强...",
    "content": "项目背景前段时间写了挺多博客，一直是用jekyll-compose（github）来完成创建、发布等功能，但使用过程中也遇到挺多不满意的地方，比如命令太长、typora-root-url加上引号导致typora预览失效、不能在任意目录执行命令等起初，我使用git bash来代替Windows下的cmd，编写了一个shell脚本来封装compose的命令，解决了命令太长的问题，但功能始终不够强大，比如输入文件名时没有自动补全，命令解析太麻烦等于是我使用Python脚本来代替shell脚本，Python脚本可以非常容易地实现强大的功能，借助argparse库和argcomplete库也能轻松做到命令解析和自动补全这里有一个小插曲，argcomplete库在git bash下的支持不好，于是我又灰溜溜地换到了PowerShell，这时候才发现原来系统自带的PowerShell是5.1版本，而现在PowerShell7的功能已经很强了，又是一顿疯狂配置，现在已经用的非常顺手了言归正传，我基于这样的背景开发了PowerJekyll项目，它是一个PowerShell模块，虽然功能简单，但非常实用，基本满足了我的日常使用项目github：Baymax104/PowerJekyll: Jekyll博客的PowerShell命令行工具 (github.com)项目结构项目中主要的代码文件如下PowerJekyll│  config.yml│  PowerJekyll.psd1│  PowerJekyll.psm1│└─core    │  command.py    │  main.py    │  parser.py    │  utils.py    │    ├─commands    │      draft.py    │      list.py    │      open.py    │      post.py    │      publish.py    │      remove.py    │      serve.py    │      unpublish.py    │    └─git_commands            add.py            commit.py            push.py            status.py            __init__.py  PowerJekyll.psm1：PowerShell模块文件，提供启动命令blog以及注册自动补全  PowerJekyll.psd1：PowerShell模块清单，包含模块的元数据  config.yml：配置文件  core：命令脚本及主程序目录  commands：博客的基本命令，包含创建、发布、打开等  git_commands：与git相关命令，执行博客的git部分操作argparse库argparse库用于Python脚本的命令行参数解析，通过配置解析器对象来设置命令的参数、格式等官方文档：argparse — 用于命令行选项、参数和子命令的解析器 — Python 3.12.3 文档基本使用流程  创建argparse.ArgumentParser解析器对象，设置程序名称、帮助文档等  调用add_argument方法来添加参数，设置参数的名称、类型、帮助文档等  调用parse_args方法来解析命令，返回参数对象args  调用args的参数属性来获取参数值实现子命令argparse可以创建多个子命令解析器，每个子命令解析器可以独立添加参数，可直接调用args的子命令的参数属性来获取参数值基本示例# 创建主解析器parser = argparse.ArgumentParser(prog='PROG')# 主解析器独立添加参数parser.add_argument('--foo', action='store_true', help='foo help')# 子命令占位参数subparsers = parser.add_subparsers(dest='command', help='sub-command help')# 创建子命令解析器parser_a = subparsers.add_parser('a', help='a help')# 子命令添加参数parser_a.add_argument('bar', type=int, help='bar help')# 解析参数parser.parse_args()argcomplete库argcomplete库基于argparse库实现参数的自动补全官方github：kislyuk/argcomplete: Python and tab completion, better together. (github.com)基本使用：在调用parse_args方法解析参数之前，调用argcomplete.autocomplete(parser)，argcomplete会自动根据解析器来实现补全自定义补全在设置解析器时，可以设置参数的completer（补全器）来实现自定义补全，库中提供了以下几种completer  ChoicesCompleter：集合补全  DirectoriesCompleter：目录补全  FilesCompleter：文件名补全  SuppressCompleter：抑制特定参数补全使用ChoicesCompleter的基本示例parser = argparse.ArgumentParser(prog='PROG')action = parser.add_argument('--foo', action='store_true', help='foo help')# 自定义集合value_list = [1, 2, 3]# add_argument方法的返回值是一个Action对象，设置Action对象的completer属性action.completer = argcomplete.completers.ChoicesCompleter(value_list)PowerShell模块PowerShell模块是一个自包含的可重用单元，可以包含cmdlet、提供程序、函数、变量等官方文档：关于模块 - PowerShell编写PowerShell模块参考：如何编写 PowerShell 脚本模块 - PowerShell安装PowerShell模块参考：安装 PowerShell 模块 - PowerShell"
  },
  
  {
    "title": "记录使用jekyll-compose的一个坑",
    "url": "/posts/jekyll-compose-bug/",
    "categories": "博客开发",
    "tags": "jekyll-compose, bug",
    "date": "2024-05-24 14:51:00 +0800",
    





    
    "snippet": "问题背景在使用jekyll-compose（github）时，我需要创建好草稿后自动打开，这个功能在README中表述如下auto-open new drafts or posts in your editor  jekyll_compose:    auto_open: trueand make sure that you have EDITOR, VISUAL or JEKYLL_EDI...",
    "content": "问题背景在使用jekyll-compose（github）时，我需要创建好草稿后自动打开，这个功能在README中表述如下auto-open new drafts or posts in your editor  jekyll_compose:    auto_open: trueand make sure that you have EDITOR, VISUAL or JEKYLL_EDITOR environment variable set. For instance if you wish to open newly created Jekyll posts and drafts in Atom editor you can add the following line in your shell configuration:export JEKYLL_EDITOR=atomJEKYLL_EDITOR will override default EDITOR or VISUAL value. VISUAL will override default EDITOR value.大意就是在_config.yml中配置auto_open: true，在通过JEKYLL_EDITOR环境变量指定打开的编辑器，于是我设置JEKYLL_EDITOR=code，用vscode打开，这样可以正常运行但我经常使用typora来编辑md文档，因此我设置JEKYLL_EDITOR=typora，此时文档不能自动打开，设置JEKYLL_EDITOR=D:\\Typora\\Typora.exe，此时文档可以打开，但控制台会卡住并且报错我已经设置了md文件的默认打开方式为typora，因此我希望它按照我设置的默认打开方式打开解决方法要使用编辑器打开，那么源码中必然有执行一条指令调用了编辑器，于是我找到了jekyll-compose包的所在位置，文件树如下D:\\DEVELOPTOOL\\RUBY32-X64\\LIB\\RUBY\\GEMS\\3.2.0\\GEMS\\JEKYLL-COMPOSE-0.12.0└─lib    │  jekyll-compose.rb    │    ├─jekyll    │  └─commands    │          compose.rb    │          draft.rb    │          page.rb    │          post.rb    │          publish.rb    │          rename.rb    │          unpublish.rb    │    └─jekyll-compose            arg_parser.rb            file_creator.rb            file_editor.rb            file_info.rb            file_mover.rb            movement_arg_parser.rb            version.rb可以看到commands目录存放各个子命令的源码，在jekyll-compose目录中有一个file-editor.rb文件，这应该就是处理文件编辑器的源码，代码量不大，如下所示# frozen_string_literal: true## This class is aimed to open the created file in the selected editor.# To use this feature specify at Jekyll config:## ```#  jekyll_compose:#    auto_open: true# ```## And make sure, that you have JEKYLL_EDITOR, VISUAL, or EDITOR environment variables set up.# This will allow to open the file in your default editor automatically.module Jekyll  module Compose    class FileEditor      class &lt;&lt; self        attr_reader  :compose_config        alias_method :jekyll_compose_config, :compose_config        def bootstrap(config)          @compose_config = config[\"jekyll_compose\"] || {}        end        def open_editor(filepath)          run_editor(post_editor, File.expand_path(filepath)) if post_editor        end        def run_editor(editor_name, filepath)          system(\"#{editor_name} #{filepath}\")        end        def post_editor          return unless auto_open?          ENV[\"JEKYLL_EDITOR\"] || ENV[\"VISUAL\"] || ENV[\"EDITOR\"]        end        def auto_open?          compose_config[\"auto_open\"]        end      end    end  endend源码使用ruby语言，我并没有学过ruby语言，但通过命名可以看出一些功能run_editor函数中调用了system(\"#{editor_name} #{filepath}\")，这很明显是通过系统命令行来调用编辑器，那么editor_name就是环境变量指定的编辑器run_editor函数在open_editor函数中调用，传入的editor_name参数通过post_editor函数得到，而post_editor函数中就是读取了JEKYLL_EDITOR环境变量现在，我想使用默认打开方式打开文件，在Windows中打开文件的命令是start，因此就将JEKYLL_EDITOR环境变量设为start，此时文件成功打开并且没有报错，问题解决"
  },
  
  {
    "title": "Vue3基础——其他API",
    "url": "/posts/vue3-%E5%85%B6%E4%BB%96api/",
    "categories": "前端, Vue3",
    "tags": "前端, Vue3",
    "date": "2024-05-21 15:36:00 +0800",
    





    
    "snippet": "shallowRef与shallowReactive对于深层次的对象，shallowRef与shallowReactive只将最外层的对象转换为响应式数据，用于对大型数据结构的性能优化或是与外部的状态管理系统集成  shallowRef：只对.value的访问是响应式的  shallowReactive：内部的ref数据不会被自动解包// shallowRefconst state = sh...",
    "content": "shallowRef与shallowReactive对于深层次的对象，shallowRef与shallowReactive只将最外层的对象转换为响应式数据，用于对大型数据结构的性能优化或是与外部的状态管理系统集成  shallowRef：只对.value的访问是响应式的  shallowReactive：内部的ref数据不会被自动解包// shallowRefconst state = shallowRef({ count: 1 })// 不会触发更改state.value.count = 2// 会触发更改state.value = { count: 2 }// shallowReactiveconst state = shallowReactive({  foo: 1,  nested: {    bar: 2  }})// 更改状态自身的属性是响应式的state.foo++// ...但下层嵌套对象不会被转为响应式isReactive(state.nested) // false// 不是响应式的state.nested.bar++readonly与shallowReadonly  readonly：创建一个响应式数据的只读响应式副本，随原数据变化触发响应式更新  shallowReadonly：只将最外层对象的属性变为了只读// readonlyconst original = reactive({ count: 0 })const copy = readonly(original)watchEffect(() =&gt; {  // 用来做响应性追踪  console.log(copy.count)})// 更改源属性会触发其依赖的侦听器original.count++// 更改该只读副本将会失败，并会得到一个警告copy.count++ // warning!// shallowReadonlyconst state = shallowReadonly({  foo: 1,  nested: {    bar: 2  }})// 更改状态自身的属性会失败state.foo++// ...但可以更改下层嵌套对象isReadonly(state.nested) // false// 这是可以通过的state.nested.bar++toRaw与markRaw  toRaw：返回响应式数据的原始数据  markRaw：将一个对象标记为不可被转为代理，返回该对象本身// toRawconst foo = {}const reactiveFoo = reactive(foo)console.log(toRaw(reactiveFoo) === foo) // true// markRawconst foo = markRaw({})console.log(isReactive(reactive(foo))) // false// 也适用于嵌套在其他响应性对象const bar = reactive({ foo })console.log(isReactive(bar.foo)) // falsecustomRef创建一个自定义的ref，显式声明对其依赖追踪和更新触发的控制方式函数声明function customRef&lt;T&gt;(factory: CustomRefFactory&lt;T&gt;): Ref&lt;T&gt;type CustomRefFactory&lt;T&gt; = (  track: () =&gt; void,  trigger: () =&gt; void) =&gt; {  get: () =&gt; T  set: (value: T) =&gt; void}  customRef接收一个factory函数，返回一个ref数据  factory函数接收track和trigger两个函数作为参数，返回一个带有get方法和set方法的对象防抖ref实现import { customRef } from 'vue'export function useDebouncedRef(value: string, delay: number = 200) {  let timeout: number  return customRef((track, trigger) =&gt; {    return {      // 在数据被读取时调用      get() {        // 标记引用        track()        return value      },      // 在数据被修改时调用      set(newValue) {        clearTimeout(timeout)        timeout = setTimeout(() =&gt; {          value = newValue          // 触发更新          trigger()        }, delay)      }    }  })}Teleport用于改变组件模板内容的实际DOM渲染位置，而不改变组件的逻辑关系，可用于实现模态框等效果e.g. 实现一个模态框一个outer块中包含MyModal组件，在逻辑上为父子关系&lt;div class=\"outer\"&gt;  &lt;h3&gt;Tooltips with Vue 3 Teleport&lt;/h3&gt;  &lt;div&gt;    &lt;MyModal /&gt;  &lt;/div&gt;&lt;/div&gt;在编写css布局时，通常将模态框显示在整个视窗的中间，但由于父子关系，outer块的布局可能会导致MyModal的定位出现问题，MyModal的DOM位置应该脱离outer块，因此使用Teleport实现MyModal，改变实际DOM位置&lt;button @click=\"open = true\"&gt;Open Modal&lt;/button&gt;&lt;!--将模态框内容渲染到body块中--&gt;&lt;Teleport to=\"body\"&gt;  &lt;div v-if=\"open\" class=\"modal\"&gt;    &lt;p&gt;Hello from the modal!&lt;/p&gt;    &lt;button @click=\"open = false\"&gt;Close&lt;/button&gt;  &lt;/div&gt;&lt;/Teleport&gt;"
  },
  
  {
    "title": "Vue3基础——插槽Slots",
    "url": "/posts/vue3-slot/",
    "categories": "前端, Vue3",
    "tags": "前端, Vue3",
    "date": "2024-05-19 15:51:00 +0800",
    





    
    "snippet": "开始使用插槽可以实现动态的模板内容父模板中的插槽内容可以访问到父组件的数据作用域，但不能访问到子组件的数据作用域默认插槽不具有name属性的插槽为默认插槽父组件基本使用&lt;script setup lang=\"ts\"&gt;import {ref} from 'vue';import Inner from \"@/components/Inner.vue\";let value1 = ref...",
    "content": "开始使用插槽可以实现动态的模板内容父模板中的插槽内容可以访问到父组件的数据作用域，但不能访问到子组件的数据作用域默认插槽不具有name属性的插槽为默认插槽父组件基本使用&lt;script setup lang=\"ts\"&gt;import {ref} from 'vue';import Inner from \"@/components/Inner.vue\";let value1 = ref('value1');&lt;/script&gt;&lt;template&gt;  &lt;div&gt;    &lt;Inner&gt;      &lt;!--该部分内容会填充到插槽中--&gt;      &lt;span&gt;{ {value1} }&lt;/span&gt;    &lt;/Inner&gt;  &lt;/div&gt;&lt;/template&gt;子组件基本使用&lt;script setup lang=\"ts\"&gt;&lt;/script&gt;&lt;template&gt;  &lt;div&gt;    &lt;!--slot标签定义默认插槽--&gt;    &lt;slot&gt;&lt;/slot&gt;  &lt;/div&gt;&lt;/template&gt;slot标签中的模板内容为默认填充内容，当父组件未定义插槽内容时，使用默认内容填充&lt;!--子组件--&gt;&lt;template&gt;  &lt;div&gt;    &lt;slot&gt;默认内容&lt;/slot&gt;  &lt;/div&gt;&lt;/template&gt;&lt;!--父组件--&gt;&lt;Inner&gt;&lt;/Inner&gt;具名插槽可以为slot设置名称，指明插槽内容填充的slot  slot标签使用name属性设置名称  使用v-slot指令指明填充的slot，该指令可用于组件标签或template标签上，可简写为#  当同时使用具名插槽和默认插槽时，可使用显式默认插槽或隐式默认插槽      显式默认插槽：使用v-slot:default指明填充到默认插槽    隐式默认插槽：组件标签中所有的直接非template标签将作为默认插槽内容  基本使用&lt;!--子组件--&gt;&lt;template&gt;  &lt;div&gt;    &lt;slot name=\"header\"&gt;&lt;/slot&gt;    &lt;slot name=\"content\"&gt;&lt;/slot&gt;  &lt;/div&gt;&lt;/template&gt;&lt;!--父组件--&gt;&lt;template&gt;  &lt;div&gt;    &lt;Inner&gt;      &lt;template v-slot:header&gt;        &lt;span&gt;这是header&lt;/span&gt;      &lt;/template&gt;      &lt;template #content&gt;        &lt;div&gt;这是content&lt;/div&gt;      &lt;/template&gt;    &lt;/Inner&gt;  &lt;/div&gt;&lt;/template&gt;作用域插槽使用作用域插槽可向插槽内容提供子组件的数据  在子组件的slot标签中传递参数  在父组件中接收参数基本使用&lt;!--子组件--&gt;&lt;div&gt;  &lt;!--通过v-bind传递参数--&gt;  &lt;slot :text=\"greetingMessage\" :count=\"1\"&gt;&lt;/slot&gt;&lt;/div&gt;&lt;!--父组件--&gt;&lt;!--使用一个对象接收参数--&gt;&lt;MyComponent v-slot=\"slotProps\"&gt;  { { slotProps.text } } { { slotProps.count } }&lt;/MyComponent&gt;&lt;!--接收参数时可以使用解构&lt;MyComponent v-slot=\"{ text, count }\"&gt;  { { text } } { { count } }&lt;/MyComponent&gt;--&gt;在同时使用默认插槽和具名插槽时，作用域插槽必须显式指明默认插槽&lt;template&gt;  &lt;MyComponent&gt;    &lt;!-- 使用显式的默认插槽 --&gt;    &lt;template #default=\"{ message }\"&gt;      &lt;p&gt;{ { message } }&lt;/p&gt;    &lt;/template&gt;    &lt;template #footer&gt;      &lt;p&gt;Here's some contact info&lt;/p&gt;    &lt;/template&gt;  &lt;/MyComponent&gt;&lt;/template&gt;其他特性条件插槽$slots对象用于获取父组件传入所有插槽填充内容，配合v-if可实现条件渲染slot标签&lt;template&gt;  &lt;div class=\"card\"&gt;    &lt;div v-if=\"$slots.header\" class=\"card-header\"&gt;      &lt;slot name=\"header\" /&gt;    &lt;/div&gt;        &lt;div v-if=\"$slots.default\" class=\"card-content\"&gt;      &lt;slot /&gt;    &lt;/div&gt;        &lt;div v-if=\"$slots.footer\" class=\"card-footer\"&gt;      &lt;slot name=\"footer\" /&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;动态插槽名在v-slot指令上可使用动态插槽名&lt;base-layout&gt;  &lt;template v-slot:[dynamicSlotName]&gt;    ...  &lt;/template&gt;  &lt;!-- 缩写为 --&gt;  &lt;template #[dynamicSlotName]&gt;    ...  &lt;/template&gt;&lt;/base-layout&gt;"
  },
  
  {
    "title": "Vue3基础——组件通信",
    "url": "/posts/vue3-%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/",
    "categories": "前端, Vue3",
    "tags": "前端, Vue3",
    "date": "2024-05-19 15:50:00 +0800",
    





    
    "snippet": "props传参通常用于父组件和子组件的通信  在子组件中定义props，使用props  在父组件中传递参数  子组件向父组件传递需要使用回调的方式子组件中定义props&lt;script setup lang=\"ts\"&gt;import {ref} from \"vue\";// 定义propsdefineProps(['value1', 'value2', 'getValue3']);l...",
    "content": "props传参通常用于父组件和子组件的通信  在子组件中定义props，使用props  在父组件中传递参数  子组件向父组件传递需要使用回调的方式子组件中定义props&lt;script setup lang=\"ts\"&gt;import {ref} from \"vue\";// 定义propsdefineProps(['value1', 'value2', 'getValue3']);let value3 = ref('value3');&lt;/script&gt;&lt;template&gt;  &lt;div&gt;{ {value1} }&lt;/div&gt;  &lt;div&gt;{ {value2} }&lt;/div&gt;  &lt;!--调用回调，传递value3--&gt;  &lt;button @click=\"getValue3(value3)\"&gt;向父组件传递value3&lt;/button&gt;&lt;/template&gt;在父组件中传递参数&lt;script setup lang=\"ts\"&gt;import {ref} from 'vue';import Inner from \"@/components/Inner.vue\";let value1 = ref('value1');let value2 = ref('value2');let value3 = ref('');// 回调函数function getValue3(value: string) {  value3.value = value;}&lt;/script&gt;&lt;template&gt;  &lt;div&gt;    &lt;div&gt;{ {value3} }&lt;/div&gt;    &lt;!--传参--&gt;    &lt;Inner :value1=\"value1\" :value2=\"value2\" :getValue3=\"getValue3\"&gt;&lt;/Inner&gt;  &lt;/div&gt;&lt;/template&gt;自定义事件主要用于父组件向子组件通信  在子组件中定义自定义事件，触发事件  在父组件中传递事件回调在子组件中定义自定义事件，触发事件&lt;script setup lang=\"ts\"&gt;import {ref} from \"vue\";let value = ref('value');// 通过emit对象触发事件const emit = defineEmits(['get-value']);&lt;/script&gt;&lt;template&gt;  &lt;!--传入触发的事件名和参数--&gt;  &lt;button @click=\"emit('get-value', value)\"&gt;向父组件传递value&lt;/button&gt;&lt;/template&gt;在父组件中传递事件回调&lt;script setup lang=\"ts\"&gt;import {ref} from 'vue';import Inner from \"@/components/Inner.vue\";let value1 = ref('');function getValue(value: string) {  value1.value = value;}&lt;/script&gt;&lt;template&gt;  &lt;div&gt;    &lt;div&gt;{ {value1} }&lt;/div&gt;    &lt;!--自定义事件传入回调--&gt;    &lt;Inner @get-value=\"getValue\"&gt;&lt;/Inner&gt;  &lt;/div&gt;&lt;/template&gt;mitt消息总线使用前安装mitt：npm i mitt初始化消息总线emitterimport mitt from \"mitt\";const emitter = mitt();export default emitter;emitter对象主要使用四个成员  all：获取所有事件，返回事件和对应回调的map  on()：绑定事件  emit()：触发事件  off()：注销事件子组件接收value1，传递value2&lt;script setup lang=\"ts\"&gt;import {ref} from \"vue\";import emitter from \"@/utils/emitter\";let value1 = ref('');emitter.on('get-value1', (value) =&gt; {  if (typeof value === 'string') {    value1.value = value;  }})&lt;/script&gt;&lt;template&gt;  &lt;div&gt;{ {value1} }&lt;/div&gt;  &lt;button @click=\"emitter.emit('get-value2', 'value2')\"&gt;触发get-value2&lt;/button&gt;&lt;/template&gt;父组件接收value2，传递value1&lt;script setup lang=\"ts\"&gt;import {ref} from 'vue';import Inner from \"@/components/Inner.vue\";import emitter from \"@/utils/emitter\";let value2 = ref('');emitter.on('get-value2', (value) =&gt; {  if (typeof value === 'string') {    value2.value = value;  }})&lt;/script&gt;&lt;template&gt;  &lt;div&gt;    &lt;div&gt;{ {value2} }&lt;/div&gt;    &lt;button @click=\"emitter.emit('get-value1', 'value1')\"&gt;触发get-value1&lt;/button&gt;    &lt;Inner&gt;&lt;/Inner&gt;  &lt;/div&gt;&lt;/template&gt;在组件取消挂载时注销事件onUnmounted(() =&gt; {  emitter.off('get-value1')})$attrs用于父组件向子组件通信，在父组件传递参数时，若子组件未定义对应的props，则参数保存在$attrs对象中父组件传递参数&lt;script setup lang=\"ts\"&gt;import {ref} from 'vue';import Inner from \"@/components/Inner.vue\";let value1 = ref('value1')let value2 = ref('value2');&lt;/script&gt;&lt;template&gt;  &lt;div&gt;    &lt;Inner :value1=\"value1\" :value2=\"value2\"&gt;&lt;/Inner&gt;  &lt;/div&gt;&lt;/template&gt;子组件中未定义为props的参数会以键值对的形式保存到$attrs对象中&lt;script setup lang=\"ts\"&gt;// value1定义为props，value2未定义，value2保存在$attrs对象中defineProps(['value1']);&lt;/script&gt;&lt;template&gt;  &lt;!--  value1  { \"value2\": \"value2\" }  --&gt;  &lt;div&gt;{ {value1} }&lt;/div&gt;  &lt;div&gt;{ {$attrs} }&lt;/div&gt;&lt;/template&gt;ref标签属性ref标签属性可以获取组件的实例对象或HTML元素的DOM对象  子组件定义暴露的数据  父组件通过ref属性获取对象，获取暴露的数据$refs和$parent  $refs：以键值对的形式存储所有使用ref属性的元素对象  $parent：当前组件的父组件对象子组件中定义暴露的数据&lt;script setup lang=\"ts\"&gt;import { ref } from 'vue'const name = ref(\"张三\")const sayName = ()=&gt;{  console.log(\"我叫 \" + name.value)}// 使用defineExpose函数定义暴露的数据defineExpose({name, sayName});&lt;/script&gt;&lt;template&gt;  &lt;div&gt;{ {name} }&lt;/div&gt;&lt;/template&gt;父组件通过ref属性获取子组件对象&lt;script setup lang=\"ts\"&gt;import {onMounted, ref} from 'vue';import Inner from \"@/components/Inner.vue\";let inner = ref();// 在父组件挂载完成后使用子组件对象onMounted(() =&gt; {  console.log(inner.value.name);  inner.value.sayName();});&lt;/script&gt;&lt;template&gt;  &lt;div&gt;    &lt;Inner ref=\"inner\"&gt;&lt;/Inner&gt;  &lt;/div&gt;&lt;/template&gt;provide与inject用于祖先组件向子组件提供数据  在祖先组件中使用provide提供数据  在子组件中使用inject获取数据在祖先组件中提供数据&lt;script setup lang=\"ts\"&gt;import {provide, ref} from 'vue';import Inner from \"@/components/Inner.vue\";let value1 = ref('value1');// 传入key和valueprovide('key1', value1);&lt;/script&gt;&lt;template&gt;  &lt;div&gt;    &lt;Inner&gt;&lt;/Inner&gt;  &lt;/div&gt;&lt;/template&gt;在子组件中获取数据&lt;script setup lang=\"ts\"&gt;import {inject} from 'vue';// 第二个参数为默认值，可辅助ts类型推断let value1 = inject('key1', 'defaultValue');&lt;/script&gt;&lt;template&gt;  &lt;div&gt;{ {value1} }&lt;/div&gt;&lt;/template&gt;"
  },
  
  {
    "title": "Vue3基础——Pinia",
    "url": "/posts/vue3-pinia/",
    "categories": "前端, Vue3",
    "tags": "前端, Vue3",
    "date": "2024-05-17 16:30:00 +0800",
    





    
    "snippet": "开始Pinia是Vue3的状态管理库，安装Pinia命令：npm i pinia在main.ts中引入Piniaimport { createApp } from 'vue';import App from './App.vue';import {createPinia} from \"pinia\";const app = createApp(App);const pinia = create...",
    "content": "开始Pinia是Vue3的状态管理库，安装Pinia命令：npm i pinia在main.ts中引入Piniaimport { createApp } from 'vue';import App from './App.vue';import {createPinia} from \"pinia\";const app = createApp(App);const pinia = createPinia();app.use(pinia);app.mount('#app');数据存储在src目录下创建store目录，其中每个组件对应一个.ts文件，存储每个组件的响应式数据定义数据存储storeimport {defineStore} from \"pinia\";// 定义存储// 传入一个字符串id，通常为组件名称// 传入一个配置对象，定义state函数返回响应式数据export const useCountStore = defineStore(\"count\", {    state() {        return {            count: 0        }    },    // 使用箭头函数    // state: () =&gt; ({    //     count: 0    // }),});使用store&lt;script setup lang=\"ts\"&gt;import {ref} from 'vue';import {useCountStore} from \"@/store/count\";const countStore = useCountStore();let n = ref(1);// 使用存储中的ref数据时，不需要访问valuefunction add() {  countStore.count += n.value;}function sub() {  countStore.count -= n.value;}&lt;/script&gt;&lt;template&gt;  &lt;div class=\"count\"&gt;    &lt;h2&gt;当前求和为：{ {countStore.count} }&lt;/h2&gt;    &lt;select v-model='n'&gt;      &lt;option :value=\"1\"&gt;1&lt;/option&gt;      &lt;option :value=\"2\"&gt;2&lt;/option&gt;      &lt;option :value=\"3\"&gt;3&lt;/option&gt;    &lt;/select&gt;    &lt;button @click=\"add\"&gt;加&lt;/button&gt;    &lt;button @click=\"sub\"&gt;减&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;数据修改      直接修改：直接获取数据进行修改    countStore.count += 1;            patch方法：通过$patch方法批量修改    countStore.$patch({  count: 2,})            actions选项：在配置对象中设置actions选项，其中定义修改数据的方法    import {defineStore} from \"pinia\";    export const useCountStore = defineStore(\"count\", {    state() {        return {            count: 0        }    },    actions: {        // 通过this获取数据        setCount(value: number) {            this.count = value;        }    }});    // 外部调用方法// countStore.setCount(2);      storeToRefs将store中的响应式数据解构转换为ref类型import {storeToRefs} from \"pinia\";const {count} = storeToRefs(countStore)getters选项用于定义计算属性import {defineStore} from \"pinia\";export const useCountStore = defineStore(\"count\", {    state() {        return {            count: 0        }    },    getters: {        // 使用state参数获取数据        countPlus(state) {            return state.count + 1;        },        // 使用this获取数据，必须声明返回值类型或具有state形参        countMultiply(): number {            return this.count * 10;        }    }});$subscribe方法$subscribe方法用于监视store中的数据变化// 通过state参数获取变化后数据countStore.$subscribe((mutation, state) =&gt; {  console.log(state.count);})组合式store使用组合式写法定义storeimport {defineStore} from \"pinia\";import {ref} from \"vue\";// 箭头函数为setup函数export const useCountStore = defineStore(\"count\", () =&gt; {    // state    const count = ref(0);    // actions    function setCount(value: number) {        count.value = value;    }        // 返回数据或函数    return {        count,        setCount    }});"
  },
  
  {
    "title": "Vue3基础——路由",
    "url": "/posts/vue3-%E8%B7%AF%E7%94%B1/",
    "categories": "前端, Vue3",
    "tags": "前端, Vue3",
    "date": "2024-05-02 19:24:00 +0800",
    





    
    "snippet": "基本使用使用路由需要安装依赖，使用npm i vue-router安装，在src目录下创建router目录，存放路由的.ts文件使用路由的基本步骤  定义并导出路由，设置路由和工作模式  设置app的路由  设置host和link定义路由定义一个基本的路由文件import {createRouter, createWebHistory} from 'vue-router'// 子组件impo...",
    "content": "基本使用使用路由需要安装依赖，使用npm i vue-router安装，在src目录下创建router目录，存放路由的.ts文件使用路由的基本步骤  定义并导出路由，设置路由和工作模式  设置app的路由  设置host和link定义路由定义一个基本的路由文件import {createRouter, createWebHistory} from 'vue-router'// 子组件import Home from '@/components/Home.vue'import News from '@/components/News.vue'import About from '@/components/About.vue'// 调用createRouter创建路由并导出export const router = createRouter({  // 设置路由的工作模式  history: createWebHistory(),  // 设置路由，每个对象包含path和component两个属性  routes: [    {      path: '/home',      component: Home,    },    {      path: '/news',      component: News,    },    {      path: '/about',      component: About,    }  ]})设置app路由调用use函数设备app路由import { createApp } from 'vue'import App from './App.vue'import { router } from './router'const app = createApp(App)app.use(router)app.mount('#app')设置host和link  RouterView标签设置host  RouterLink标签设置link          to属性：指定路径      active-class属性：设置选中样式类名      replace属性：导航时替换栈顶页面      &lt;div class=\"navigate\"&gt;    &lt;RouterLink to=\"/home\" active-class=\"active\"&gt;首页&lt;/RouterLink&gt;    &lt;RouterLink to=\"/news\" active-class=\"active\"&gt;新闻&lt;/RouterLink&gt;    &lt;!--to属性的对象写法--&gt;    &lt;RouterLink :to=\"{path: '/about'}\" active-class=\"active\"&gt;关于&lt;/RouterLink&gt;&lt;/div&gt;&lt;div class=\"display\"&gt;    &lt;RouterView&gt;&lt;/RouterView&gt;&lt;/div&gt;路由工作模式路由有两种工作模式  history：在URL上以传统路径显示，需要后端处理路径问题  hash：在URL中存在一个#，hash值出现在URL中但不会包含在请求中，对后端无影响两种模式对应两个函数  history：createWebHistory()  hash：createdWebHashHistory()命名路由对routes属性中的路由对象设置name属性，在link时通过name属性绑定路由对象export const router = createRouter({  history: createWebHistory(),  routes: [    {      name: 'home'      path: '/home',      component: Home,    },  ]})在link时使用to属性对象，通过设置name属性设置映射对象&lt;RouterLink :to=\"{name: 'home'}\" active-class=\"active\"&gt;首页&lt;/RouterLink&gt;嵌套路由在定义映射时设置映射对象的children属性，传入子映射export const router = createRouter({  history: createWebHistory(),  routes: [    {      path: '/news',      component: News,      children: [        {          path: 'detail'          component: Detail        }      ]    },  ]})link时设置URL路径&lt;RouterLink to=\"/news/detail\"&gt;新闻&lt;/RouterLink&gt;路由传参路由参数有两种形式  query：直接显示在URL中的参数  params：RESTful风格的路径参数参数在传递时有两种形式  字符串  to属性对象query参数query参数直接写在link路径中&lt;RouterLink to=\"/news/detail?key1=value1&amp;key2=value2\"&gt;新闻1&lt;/RouterLink&gt;子组件接收参数时，需要先获取到route对象，通过route对象获取参数&lt;script setup lang=\"ts\"&gt;import {toRefs} from \"vue\";import {useRoute} from \"vue-router\";const route = useRoute();const {query} = toRefs(route)&lt;/script&gt;&lt;template&gt;&lt;div&gt;{ {query.key1} }&lt;/div&gt;&lt;div&gt;{ {query.key2} }&lt;/div&gt;&lt;/template&gt;当传入列表项数据时，使用模板字符串或to属性对象&lt;!--模板字符串写法--&gt;&lt;li v-for=\"item in news\" :key=\"item.id\"&gt;    &lt;RouterLink :to=\"`/news/detail?id=${item.id}&amp;title=${item.title}&amp;content=${item.content}`\"&gt;        { {item.title} }    &lt;/RouterLink&gt;&lt;/li&gt;&lt;!--对象写法--&gt;&lt;li v-for=\"item in news\" :key=\"item.id\"&gt;    &lt;RouterLink :to=\"{        path: '/news/detail',        query: {            id: item.id,            title: item.title,            content: item.content,        },    }\"&gt;        { {item.title} }    &lt;/RouterLink&gt;&lt;/li&gt;params参数定义路由时，在路径中规定参数的占位export const router = createRouter({  history: createWebHistory(),  routes: [    {      path: '/news',      component: News,      children: [        {          // 使用:param占位，后加?表示可选参数          path: 'detail/:id/:title/:content?',          component: Detail        }      ]    },  ]})在link中以路径形式传递参数&lt;li v-for=\"item in news\" :key=\"item.id\"&gt;    &lt;RouterLink :to=\"`/news/detail/${item.id}/${item.title}/${item.content}`\"&gt;        { {item.title} }    &lt;/RouterLink&gt;&lt;/li&gt;  params参数传递使用to属性对象时，只能使用命名路由，因此使用params参数时最好同时设置name属性通过route对象的params属性获取参数&lt;script setup lang=\"ts\"&gt;import {useRoute} from \"vue-router\";import {toRefs} from \"vue\";const route = useRoute();const {params} = toRefs(route);&lt;/script&gt;&lt;template&gt;&lt;div&gt;{ {params.id} }&lt;/div&gt;&lt;div&gt;{ {params.title} }&lt;/div&gt;&lt;div&gt;{ {params.content} }&lt;/div&gt;&lt;/template&gt;props配置在路由对象中设置props: true，则将params参数以组件元素的属性形式传入子组件接收时使用defineProps函数&lt;script setup lang=\"ts\"&gt;defineProps(['id', 'title', 'content'])&lt;/script&gt;&lt;template&gt;&lt;div&gt;{ {id} }&lt;/div&gt;&lt;div&gt;{ {title} }&lt;/div&gt;&lt;div&gt;{ {content} }&lt;/div&gt;&lt;/template&gt;传递query参数时，使用props函数export const router = createRouter({  history: createWebHistory(),  routes: [    {      path: '/news',      component: News,      children: [        {          path: 'detail',          component: Detail,          props(route) {            // 此处也可返回route.params            return route.query          }        }      ]    },  ]})命令式导航通过router对象导航import {useRouter} from \"vue-router\";const router = useRouter();function navigate() {  // 调用replace方法替换栈顶  router.push(\"/news\");}push方法接收两种传参形式，都同时支持query参数和params参数  path字符串（不能接收name字符串）  to属性对象重定向设置重定向路由对象，将路径重定向到已有路径export const router = createRouter({  history: createWebHistory(),  routes: [    {      path: '/home',      component: Home,    },    {      path: '/',      redirect: '/home',    }  ]})"
  },
  
  {
    "title": "Vue3基础——生命周期",
    "url": "/posts/vue3-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/",
    "categories": "前端, Vue3",
    "tags": "前端, Vue3",
    "date": "2024-05-02 14:39:00 +0800",
    





    
    "snippet": "Vue2生命周期Vue2组件的生命周期有4个，每个周期对应两个生命周期回调  创建：beforeCreate、created，只调用一次  挂载：beforeMount、mounted，只调用一次  更新：beforeUpdate、updated，每次修改数据都会调用  销毁：beforeDestroy、destroyed，只调用一次Vue3生命周期  创建：使用setup替代了before...",
    "content": "Vue2生命周期Vue2组件的生命周期有4个，每个周期对应两个生命周期回调  创建：beforeCreate、created，只调用一次  挂载：beforeMount、mounted，只调用一次  更新：beforeUpdate、updated，每次修改数据都会调用  销毁：beforeDestroy、destroyed，只调用一次Vue3生命周期  创建：使用setup替代了beforeCreated和created，setup函数的执行在beforeCreated函数之前  挂载：onBeforeMount、onMounted  更新：onBeforeUpdate、onUpdated  销毁：onBeforeUnmount、onUnmounted父组件与子组件的生命周期顺序  父组件创建  父组件挂载前  子组件创建  子组件挂载  父组件挂载自定义Hooks将一些可复用的代码封装成一个函数（hook函数），作为模块使用，hook文件用useXXX.ts命名，存放在hooks目录import { ref } from 'vue'export default function () {    let sum = ref(0)        function add(value: number) {        sum.value += value    }        return {        sum,        add    }}在其他模块导入使用import useSum from '@/hooks/useSum'const {sum, add} = useSum()"
  },
  
  {
    "title": "Vue3基础——监视",
    "url": "/posts/vue3-%E7%9B%91%E8%A7%86/",
    "categories": "前端, Vue3",
    "tags": "前端, Vue3",
    "date": "2024-05-01 21:22:00 +0800",
    





    
    "snippet": "开始监视用于监视数据的变化从而执行某些流程Vue3只能监视四种数据  ref响应式数据  reactive响应式数据  返回一个值的getter函数  一个包含上述值的数组监视ref数据watch函数传入ref变量和一个回调函数，返回一个停止函数，调用可停止监视&lt;script setup lang=\"ts\"&gt;import { ref, watch } from 'vue'let ...",
    "content": "开始监视用于监视数据的变化从而执行某些流程Vue3只能监视四种数据  ref响应式数据  reactive响应式数据  返回一个值的getter函数  一个包含上述值的数组监视ref数据watch函数传入ref变量和一个回调函数，返回一个停止函数，调用可停止监视&lt;script setup lang=\"ts\"&gt;import { ref, watch } from 'vue'let age = ref(20)// 回调函数接收一个参数时，参数为newValuelet stop = watch(age, (newValue, oldValue) =&gt; {  console.log(`newValue: ${newValue}, oldValue: ${oldValue}`)  if (newValue &gt;= 40) {    stop()  }})function changeAge() {  age.value += 10}&lt;/script&gt;&lt;template&gt;  &lt;div&gt;{ {age} }&lt;/div&gt;  &lt;button @click=\"changeAge\"&gt;改变年龄&lt;/button&gt;&lt;/template&gt;监视对象时，监视的是对象的地址，若需要监视对象属性，需要开启深度监视开启深度监视后，对象的地址或属性发生变化，都会触发回调  属性变化触发回调时，oldValue不是变化前的属性值，oldValue与newValue相等watch配置对象  deep：是否开启深度监视  immediate：是否首次监视时执行回调，首次监视时oldValue为undefinedimport { ref, watch } from 'vue'let obj = ref({  name: \"Hello\",  age: 20})watch(obj, (newVal, oldVal) =&gt; {  console.log(`oldVal: ${oldVal}, newVal: ${newVal}`)}, {  deep: true})监视reactive数据监视reactive数据时，默认开启深度监视&lt;script setup lang=\"ts\"&gt;import { reactive, watch } from 'vue'let obj = reactive({  name: \"Hello\",  age: 20})watch(obj, (newVal, oldVal) =&gt; {  console.log(`oldVal: ${oldVal}, newVal: ${newVal}`)})function change() {  obj.name = \"My\"  obj.age = 30}&lt;/script&gt;&lt;template&gt;  &lt;div&gt;{ {obj.name} }&lt;/div&gt;  &lt;div&gt;{ {obj.age} }&lt;/div&gt;  &lt;button @click=\"change\"&gt;改变&lt;/button&gt;&lt;/template&gt;监视getter函数watch函数接收一个函数参数，函数返回一个值，可用于对象属性监视或计算值监视&lt;script setup lang=\"ts\"&gt;import { reactive, watch } from 'vue'let obj = reactive({  name: \"Hello\",  age: 20})watch(() =&gt; obj.name, (newVal, oldVal) =&gt; {  console.log(`oldVal: ${oldVal}, newVal: ${newVal}`)})function changeName() {  obj.name = \"My\"}function changeAge() {  obj.age = 30}&lt;/script&gt;&lt;template&gt;  &lt;div&gt;{ {obj.name} }&lt;/div&gt;  &lt;div&gt;{ {obj.age} }&lt;/div&gt;  &lt;button @click=\"changeName\"&gt;改变名称&lt;/button&gt;  &lt;button @click=\"changeAge\"&gt;改变年龄&lt;/button&gt;&lt;/template&gt;当对象属性也是一个对象时，可以直接监视对象中的对象属性，此时该对象属性中的属性发生变化会触发回调，但重新赋值该对象属性不会触发回调使用getter函数监视对象属性，会监视对象地址的变化，若需要监视属性，需要开启深度监视  为了行为统一，无论对象属性是什么类型，推荐使用getter函数监视对象属性let obj = reactive({  name: \"Hello\",  age: 20,  school: {      name: \"Hello\"  }})// 直接监视对象属性// 若对obj.school重新赋值对象，则会失去监视watch(obj.school, (value) =&gt; {  // ...})// getter函数监视对象属性watch(() =&gt; obj.school, (value) =&gt; {  console.log(`value: ${value}`)}, {  deep: true})watchEffectwatchEffect函数接收一个回调函数，自动监视回调函数中使用的响应式数据watchEffect函数会在首次监视时执行一次回调watchEffect(() =&gt; {    // ...})"
  },
  
  {
    "title": "Vue3基础——组合式基础",
    "url": "/posts/vue3-%E7%BB%84%E5%90%88%E5%BC%8F/",
    "categories": "前端, Vue3",
    "tags": "前端, Vue3",
    "date": "2024-04-30 22:16:00 +0800",
    





    
    "snippet": "setup函数setup函数是使用组合式API的位置export default {  name: 'MyVue',  setup() {    // ...  }}setup函数的返回值是一个对象，其中包含模板使用的变量和函数&lt;script lang=\"ts\"&gt;export default {  name: 'MyVue',  setup() {    // 定义data，非响...",
    "content": "setup函数setup函数是使用组合式API的位置export default {  name: 'MyVue',  setup() {    // ...  }}setup函数的返回值是一个对象，其中包含模板使用的变量和函数&lt;script lang=\"ts\"&gt;export default {  name: 'MyVue',  setup() {    // 定义data，非响应式变量    let name = \"Hello\"    let age = 20        // 定义methods    function hello() {      age = 18      alert(age)    }    // 返回一个对象，将变量和函数暴露出去    // 若返回一个函数，则该函数作为渲染函数使用    return {      name,      age,      hello    }  }}&lt;/script&gt;&lt;template&gt;  &lt;div&gt;{ {name} }&lt;/div&gt;  &lt;div&gt;{ {age} }&lt;/div&gt;  &lt;button @click=\"hello\"&gt;你好&lt;/button&gt;&lt;/template&gt;  setup函数的生命周期早于data函数和methods函数，因此在data函数和methods函数中通过this可以获取到setup函数返回的对象中的成员，不推荐在使用setup函数时同时使用data函数和methods函数在script标签上使用setup属性简化，组件名默认为文件名&lt;script setup&gt;// 定义data，非响应式变量let name = \"Hello\"let age = 20    // 定义methodsfunction hello() {  age = 18  alert(age)}&lt;/script&gt;ref函数用于定义响应式数据，ref函数返回一个Ref&lt;*&gt;对象，通过value属性获取或设置数据&lt;script setup lang=\"ts\"&gt;import {ref} from 'vue'// 基本类型与对象类型let age = ref(20)let obj = ref({  name: \"Hello\"})function hello() {  // 修改数据  age.value = 23  obj.value.name = \"My\"}&lt;/script&gt;&lt;template&gt;  &lt;div&gt;{ {age} }&lt;/div&gt;  &lt;button @click=\"hello\"&gt;你好&lt;/button&gt;&lt;/template&gt;reactive函数用于定义响应式对象类型数据，通过Proxy代理实现若需要重新赋值对象，应该使用Object.assign()方法，直接赋值会变为非响应式&lt;script setup lang=\"ts\"&gt;import {reactive} from 'vue'let obj = reactive({  name: \"Hello\"})function hello() {  // 修改对象属性  obj.name = \"My\"}&lt;/script&gt;&lt;template&gt;  &lt;div&gt;{ {obj.name} }&lt;/div&gt;  &lt;button @click=\"hello\"&gt;你好&lt;/button&gt;&lt;/template&gt;toRefs与toReftoRefs函数用于对象解构赋值时，将解构的变量变为响应式数据toRefs函数实际是将对象里的每一个属性都包装为一个ObjectRefImpl对象，修改value属性时会同时修改对象属性let obj = reactive({  name: \"Hello\",  age: 20})let {name, age} = toRefs(obj)// 调用name.value、age.value操作数据值toRef将对象中的一个属性变为响应式数据，返回值为ObjectRefImpl对象，修改value属性时会同时修改对象属性let age = toRef(obj, 'age')计算属性使用computed函数定义一个计算属性，类型为ComputedRef&lt;void&gt;&lt;script setup lang=\"ts\"&gt;import { ref, reactive, computed } from 'vue'let name = ref(\"Hello\")let age = ref(20)// 传入一个函数定义计算过程，返回计算值，该函数称为getterlet total = computed(() =&gt; {  return `${name.value}-${age.value}`})&lt;/script&gt;&lt;template&gt;  &lt;div&gt;    name: &lt;input v-model=\"name\" /&gt;&lt;br/&gt;    age: &lt;input v-model=\"age\" /&gt;&lt;br/&gt;    total: &lt;span&gt;{ {total} }&lt;/span&gt;  &lt;/div&gt;&lt;/template&gt;定义可写计算属性，返回值为WritableComputedRef&lt;void&gt;类型let total = computed({  get() {    // ...  },  set(value) {    // 使用value修改依赖值来修改计算属性    // ...  }})"
  },
  
  {
    "title": "Vue3基础——事件处理",
    "url": "/posts/vue3-%E4%BA%8B%E4%BB%B6/",
    "categories": "前端, Vue3",
    "tags": "前端, Vue3",
    "date": "2024-04-25 21:12:00 +0800",
    





    
    "snippet": "开始通过v-on指令可监听元素的事件，简写为@，指令的value可以是内联的JavaScript语句或者方法调用      内联事件处理器    &lt;button @click=\"count++\"&gt;Add 1&lt;/button&gt;        在内联事件处理器中访问事件参数    &lt;!-- 使用特殊的 $event 变量 --&gt;&lt;button @clic...",
    "content": "开始通过v-on指令可监听元素的事件，简写为@，指令的value可以是内联的JavaScript语句或者方法调用      内联事件处理器    &lt;button @click=\"count++\"&gt;Add 1&lt;/button&gt;        在内联事件处理器中访问事件参数    &lt;!-- 使用特殊的 $event 变量 --&gt;&lt;button @click=\"warn('Form cannot be submitted yet.', $event)\"&gt;  Submit&lt;/button&gt;    &lt;!-- 使用内联箭头函数 --&gt;&lt;button @click=\"(event) =&gt; warn('Form cannot be submitted yet.', event)\"&gt;  Submit&lt;/button&gt;            方法事件处理器    function greet(event) {    // ...}// &lt;button @click=\"greet\"&gt;Greet&lt;/button&gt;      事件修饰符事件修饰符用于事件的后续处理&lt;!-- 单击事件将停止传递 --&gt;&lt;a @click.stop=\"doThis\"&gt;&lt;/a&gt;&lt;!-- 提交事件将不再重新加载页面 --&gt;&lt;form @submit.prevent=\"onSubmit\"&gt;&lt;/form&gt;&lt;!-- 修饰语可以使用链式书写 --&gt;&lt;a @click.stop.prevent=\"doThat\"&gt;&lt;/a&gt;&lt;!-- 也可以只有修饰符 --&gt;&lt;form @submit.prevent&gt;&lt;/form&gt;&lt;!-- 仅当 event.target 是元素本身时才会触发事件处理器 --&gt;&lt;!-- 例如：事件处理器不来自子元素 --&gt;&lt;div @click.self=\"doThat\"&gt;...&lt;/div&gt;&lt;!-- 添加事件监听器时，使用 capture 捕获模式 --&gt;&lt;!-- 例如：指向内部元素的事件，在被内部元素处理前，先被外部处理 --&gt;&lt;div @click.capture=\"doThis\"&gt;...&lt;/div&gt;&lt;!-- 点击事件最多被触发一次 --&gt;&lt;a @click.once=\"doThis\"&gt;&lt;/a&gt;&lt;!-- 滚动事件的默认行为 (scrolling) 将立即发生而非等待 onScroll 完成 --&gt;&lt;!-- 以防其中包含 `event.preventDefault()` --&gt;&lt;div @scroll.passive=\"onScroll\"&gt;...&lt;/div&gt;键盘事件修饰符  .enter  .tab  .delete (捕获“Delete”和“Backspace”两个按键)  .esc  .space  .up  .down  .left  .right  .ctrl  .alt  .shift  .meta鼠标事件修饰符  .left  .right  .middle"
  },
  
  {
    "title": "Vue3基础——模板语法",
    "url": "/posts/vue3-%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95/",
    "categories": "前端, Vue3",
    "tags": "前端, Vue3",
    "date": "2024-04-25 21:08:00 +0800",
    





    
    "snippet": "插值语法适用于元素的文本内容，使用双大括号&lt;div&gt;    { {message} }&lt;/div&gt;若需要仅插值一次，加上v-once指令&lt;div v-once&gt;    { {message} }&lt;/div&gt;指令语法vue中的指令以v-开头，支持HTML元素属性的绑定，使用指令时，引号的部分作为JavaScript表达式处理指令的结构Vue指令的...",
    "content": "插值语法适用于元素的文本内容，使用双大括号&lt;div&gt;    { {message} }&lt;/div&gt;若需要仅插值一次，加上v-once指令&lt;div v-once&gt;    { {message} }&lt;/div&gt;指令语法vue中的指令以v-开头，支持HTML元素属性的绑定，使用指令时，引号的部分作为JavaScript表达式处理指令的结构Vue指令的完整结构由名称、参数、修饰符和值组成      Name：Vue指令以v-开头        Modifier：修饰符，表示该指令通过特殊方式绑定        Argument：指令参数，如v-bind:id的参数为id，v-on:click的参数为click    支持动态参数，即使用表达式指定参数，表达式的结果必须为一个字符串，当结果为null时，该属性不生效    &lt;div v-bind:[attr]=\"value\"&gt;&lt;/div&gt;&lt;a v-on:[eventName]=\"doSomething\"&gt;&lt;/a&gt;    &lt;!--可简写--&gt;&lt;div :[attr]=\"value\"&gt;&lt;/div&gt;&lt;a @[eventName]=\"doSomething\"&gt;&lt;/a&gt;      属性绑定      使用v-bind绑定属性    &lt;div v-bind:id=\"id\"&gt;&lt;/div&gt;            v-bind指令可以简写，使用冒号:开头    &lt;div :id=\"id\"&gt;&lt;/div&gt;            同名简写：当属性名与变量名相同可简写    &lt;div v-bind:id&gt;&lt;/div&gt;            可绑定一个对象，同时绑定多个属性    let obj = {    id: \"myid\",    class: \"my-class\"}    // html// &lt;div v-bind=\"obj\"&gt;&lt;/div&gt;            对class和style属性的绑定增强    value可以传入对象或数组以支持多个值的需求    &lt;!--传入对象--&gt;&lt;!--通过isClass1Active和isClass2Active两个状态，可以控制是否添加class1或class2--&gt;&lt;div :class=\"{class1: isClass1Active, class2: isClass2Active}\"&gt;&lt;/div&gt;&lt;!--通过fontSize状态来修改样式--&gt;&lt;div :style=\"{ 'font-size': fontSize + 'px' }\"&gt;&lt;/div&gt;    &lt;!--传入数组--&gt;&lt;div :class=\"[activeClass, errorClass]\"&gt;&lt;/div&gt;&lt;div :style=\"[baseStyles, overridingStyles]\"&gt;&lt;/div&gt;        传入对象时可以不使用字面量    const classObject = reactive({  active: true,  'text-danger': false})// &lt;div :class=\"classObject\"&gt;&lt;/div&gt;    const styleObject = reactive({  color: 'red',  fontSize: '13px'})// &lt;div :style=\"styleObject\"&gt;&lt;/div&gt;      双向绑定使用v-model指令实现双向绑定&lt;input type=\"text\" v-model=\"value1\"&gt;&lt;!--实际实现--&gt;&lt;input type=\"text\"        :value=\"value1\"        @input=\"value1 = ($event.target as HTMLInputElement).value\"&gt;从用户输入获取的值默认为字符串，通过修饰符可对字符串进行处理  lazy：当输入框失去焦点或按下回车时，才触发数据更新  number：将字符串转换为数字  trim：去除首尾空格"
  },
  
  {
    "title": "Vue3基础——条件渲染与列表渲染",
    "url": "/posts/vue3-%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93%E4%B8%8E%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93/",
    "categories": "前端, Vue3",
    "tags": "前端, Vue3",
    "date": "2024-04-25 21:08:00 +0800",
    





    
    "snippet": "条件渲染条件渲染用于根据条件结果来选择性的渲染HTML中的元素      v-if：当条件为true时，渲染元素    &lt;h1 v-if=\"awesome\"&gt;Vue is awesome!&lt;/h1&gt;            v-else-if：与else if效果相同，必须跟在v-if或v-else-if后面        v-else：与else作用相同，必须跟在v-...",
    "content": "条件渲染条件渲染用于根据条件结果来选择性的渲染HTML中的元素      v-if：当条件为true时，渲染元素    &lt;h1 v-if=\"awesome\"&gt;Vue is awesome!&lt;/h1&gt;            v-else-if：与else if效果相同，必须跟在v-if或v-else-if后面        v-else：与else作用相同，必须跟在v-if或v-else-if后面  v-showv-show同v-if一样根据条件显示一个元素，但v-show依然保留元素的DOM节点，只是改变了CSS的display属性与v-if的优劣  v-if会根据条件完全渲染组件，包括相关的监听器和子组件等，因此它是惰性的，状态切换开销较大  v-show在首次渲染就会渲染出元素，即使value为false，它只修改了display属性，因此状态切换开销小列表渲染使用v-for指令遍历一个数组或对象      遍历数组：第二个参数index可选，key属性绑定列表项的标识    &lt;li v-for=\"(item, index) in items\" :key=\"item.id\"&gt;  { { item.message } }&lt;/li&gt;            遍历对象：第二和第三个参数可选    &lt;!--const myObject = {  title: 'How to do lists in Vue',  author: 'Jane Doe',  publishedAt: '2016-04-10'}--&gt;    &lt;ul&gt;  &lt;li v-for=\"(value, key, index) in myObject\"&gt;    { { value } }  &lt;/li&gt;&lt;/ul&gt;            字面量范围    &lt;span v-for=\"n in 10\"&gt;    { { n } }&lt;/span&gt;      v-for与v-if配合v-if比v-for的优先级高，因此v-if中无法使用v-for的遍历变量，通过使用template标签包装可解决&lt;!-- 这会抛出一个错误，因为属性 todo 此时 没有在该实例上定义--&gt;&lt;li v-for=\"todo in todos\" v-if=\"!todo.isComplete\"&gt;  { { todo.name } }&lt;/li&gt;&lt;!--template标签包装--&gt;&lt;template v-for=\"todo in todos\"&gt;  &lt;li v-if=\"!todo.isComplete\"&gt;    { { todo.name } }  &lt;/li&gt;&lt;/template&gt;数组状态检测通过以下方法修改数组可以触发更新  push()  pop()  shift()  unshift()  splice()  sort()  reverse()"
  },
  
  {
    "title": "Vue3基础——开始",
    "url": "/posts/vue3-%E5%BC%80%E5%A7%8B/",
    "categories": "前端, Vue3",
    "tags": "前端, Vue3",
    "date": "2024-04-25 21:08:00 +0800",
    





    
    "snippet": "开始通过Vite创建Vue项目，命令为npm create vue@latest，再运行npm i安装依赖项目目录结构  public：存放项目公共资源  src：源代码目录  env.d.ts：ts环境文件，识别项目中的文件  index.html：项目入口  package.json：依赖管理文件  tsconfig.app.json、tsconfig.json、tsconfig.nod...",
    "content": "开始通过Vite创建Vue项目，命令为npm create vue@latest，再运行npm i安装依赖项目目录结构  public：存放项目公共资源  src：源代码目录  env.d.ts：ts环境文件，识别项目中的文件  index.html：项目入口  package.json：依赖管理文件  tsconfig.app.json、tsconfig.json、tsconfig.node.json：ts配置文件  vite.config.ts：项目配置文件App组件App.vue是项目的根组件，在main.ts中实现将组件挂载到index.html的元素index.html中包含一个id为app的div元素&lt;body&gt;    &lt;div id=\"app\"&gt;&lt;/div&gt;    &lt;script type=\"module\" src=\"/src/main.ts\"&gt;&lt;/script&gt;&lt;/body&gt;在main.ts中将App组件挂载到app元素上import './assets/main.css'import { createApp } from 'vue'import App from './App.vue'createApp(App).mount('#app')单文件组件Vue的单文件组件是指在一个文件中编写一个组件，文件后缀为.vue，该文件中封装了组件的HTML、CSS和JavaScript代码单文件组件的基本结构&lt;template&gt;&lt;!--编写HTML--&gt;&lt;/template&gt;&lt;script&gt;// 编写JavaScript&lt;/script&gt;&lt;style scoped&gt;/* 编写CSS */&lt;/style&gt;选项式API与组合式API选项式API使用一个对象来描述组件，通过定义对象中的特定名称的方法来配置组件的逻辑&lt;script&gt;// 默认导出一个对象，代表组件实例export default {  // 配置状态  data() {    return {      count: 0    }  },  // 配置方法修改状态  methods: {    increment() {      this.count++    }  },  // 生命周期回调  mounted() {    console.log(`The initial count is ${this.count}.`)  }}&lt;/script&gt;&lt;template&gt;  &lt;button @click=\"increment\"&gt;Count is: { { count } }&lt;/button&gt;&lt;/template&gt;组合式API使用导入的API函数来描述组件逻辑，将相关的逻辑放在一起，更易于维护&lt;script setup&gt;import { ref, onMounted } from 'vue'// 定义状态const count = ref(0)// 用来修改状态、触发更新的函数function increment() {  count.value++}// 生命周期钩子onMounted(() =&gt; {  console.log(`The initial count is ${count.value}.`)})&lt;/script&gt;&lt;template&gt;  &lt;button @click=\"increment\"&gt;Count is: { { count } }&lt;/button&gt;&lt;/template&gt;"
  },
  
  {
    "title": "WPF基础——依赖属性",
    "url": "/posts/wpf-%E4%BE%9D%E8%B5%96%E5%B1%9E%E6%80%A7/",
    "categories": "C#, WPF",
    "tags": "C#, WPF",
    "date": "2024-04-25 15:27:00 +0800",
    





    
    "snippet": "开始依赖属性是WPF中的新概念，相对地，普通的属性被称为CLR属性（Common Language Runtime）依赖属性与CLR属性最大的不同就是依赖属性的属性值可以通过Binding对象绑定到其他对象上，同时节省了UI元素实例的属性内存开销依赖对象：拥有依赖属性的类称为依赖对象，在初始化时并不分配依赖属性的内存空间，只提供获取默认值、借用其他对象数据或实时分配空间的能力，WPF中的所有...",
    "content": "开始依赖属性是WPF中的新概念，相对地，普通的属性被称为CLR属性（Common Language Runtime）依赖属性与CLR属性最大的不同就是依赖属性的属性值可以通过Binding对象绑定到其他对象上，同时节省了UI元素实例的属性内存开销依赖对象：拥有依赖属性的类称为依赖对象，在初始化时并不分配依赖属性的内存空间，只提供获取默认值、借用其他对象数据或实时分配空间的能力，WPF中的所有自带UI控件都是依赖对象使用依赖属性依赖属性的基本使用public class Student : DependencyObject {    public static readonly DependencyProperty NameProperty =        DependencyProperty.Register(nameof(Name), typeof(string), typeof(Student));        // 依赖属性的包装器，便于外界访问依赖属性    // DependencyObject类提供了GetValue方法和SetValue方法，用于访问依赖属性    public string Name {        get =&gt; (string)GetValue(NameProperty);        set =&gt; SetValue(NameProperty, value);    }}Register方法用于注册一个依赖属性  name：指定哪个CLR属性作为依赖属性的包装器  propertyType：依赖属性的值类型  ownerType：依赖对象的类型  typeMetadata：DefaultMetadata类型，表示依赖属性的默认值依赖属性作为数据源单纯的依赖属性通常作为Binding的目标，设置了包装器后，依赖属性可作为Binding的数据源var student = new Student();// 将Text1的Text属性绑定到student的NameProperty上，student作为目标var bindingText1Student = new Binding() {    Source = Text1,    Path = new(\"Text\")};BindingOperations.SetBinding(student, Student.NameProperty, bindingText1Student);// 将student的Name绑定到Text2的TextProperty上，student作为数据源var bindingStudentText2 = new Binding() {    Source = student,    Path = new(\"Name\")};BindingOperations.SetBinding(Text2, TextBlock.TextProperty, bindingStudentText2);依赖属性的存取原理在DependencyObject类中存在一个静态属性PropertyFromNameprivate static Hashtable PropertyFromName = new Hashtable();该哈希表保存了通过Register方法注册的依赖属性  键：传入的CLR属性名和ownerType的hashcode异或运算得到  值：DependencyProperty对象依赖对象中调用GetValue方法获取依赖属性的值，实际上是获取EffectiveValueEntry实例中的值public object GetValue(DependencyProperty dp) {    // ...        // 获取EffectiveValueEntry实例，再获取Value属性    return GetValueEntry(LookupEntry(dp.GlobalIndex), dp, null, RequestFlags.FullyResolved).Value;}附加属性附加属性是指一个对象处于某个环境下，被附加的属性，本质依然是依赖属性附加属性的声明public class Student : DependencyObject {    public static readonly DependencyProperty NameProperty =        DependencyProperty.RegisterAttached(\"Name\", typeof(string), typeof(Student), new UIPropertyMetadata(\"\"));        public static string GetName(DependencyObject obj) {        return (string)obj.GetValue(NameProperty);    }        public static void SetName(DependencyObject obj, string value) {        obj.SetValue(NameProperty, value);    }}与一般依赖属性的不同  使用RegisterAttached方法进行注册  通过方法而不是CLR属性包装依赖属性使用附加属性// Human作为被附加类，继承DependencyObjectpublic class Human : DependencyObject {}var human = new Human();Student.SetName(human, \"hello\");  // 将NameProperty附加到Humanstring name = Student.GetName(human);自定义组件通过UserControl组件可以自定义组件，使用依赖属性为组件添加自定义属性C#类实现  自定义依赖属性和CLR包装属性  在构造器中设置Root组件的DataContext为当前类thisusing System.Windows;using System.Windows.Controls;namespace WpfDemo;public partial class UserControl1 : UserControl {    public static readonly DependencyProperty AgeProPerty =         DependencyProperty.Register(nameof(Age), typeof(int), typeof(UserControl1), new UIPropertyMetadata());    public int Age {        get =&gt; (int)GetValue(AgeProPerty);        set =&gt; SetValue(AgeProPerty, value);    }            public UserControl1() {        InitializeComponent();        Root.DataContext = this;    }}xaml基本实现  使用UserControl组件作为根组件  定义布局组件的id为Root  d:DataContext用于在预览调试时定义DataContext  通过Binding绑定到自定义的CLR包装属性&lt;UserControl x:Class=\"WpfDemo.UserControl1\"             xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"             xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"             xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"             xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"             xmlns:local=\"clr-namespace:WpfDemo\"             mc:Ignorable=\"d\"             d:DesignHeight=\"300\" d:DesignWidth=\"300\"&gt;    &lt;Grid x:Name=\"Root\" d:DataContext=\"{d:DesignInstance local:UserControl1}\"&gt;        &lt;TextBlock Text=\"{Binding Age}\"/&gt;    &lt;/Grid&gt;&lt;/UserControl&gt;外部使用：传入字面量或Binding&lt;local:UserControl1 Age=\"30\"/&gt;"
  },
  
  {
    "title": "Android基础——Service",
    "url": "/posts/android-service/",
    "categories": "Android",
    "tags": "Android",
    "date": "2024-04-25 12:54:00 +0800",
    





    
    "snippet": "开始Service用于在Android中执行一些后台任务，实现多任务或者进程间通信Service依赖于创建时所在的进程，当进程被杀死后，该进程的所有Service均失效使用Service不会自动创建新的线程，若需要去实现一个耗时任务，创建新线程要注意避免Service运行在主线程引起的ANR问题（应用程序无响应）创建Service创建Service：继承Service类，重写方法public...",
    "content": "开始Service用于在Android中执行一些后台任务，实现多任务或者进程间通信Service依赖于创建时所在的进程，当进程被杀死后，该进程的所有Service均失效使用Service不会自动创建新的线程，若需要去实现一个耗时任务，创建新线程要注意避免Service运行在主线程引起的ANR问题（应用程序无响应）创建Service创建Service：继承Service类，重写方法public class TestService extends Service {        @Override    public void onCreate() {                super.onCreate();    }    @Override    public void onDestroy() {                super.onDestroy();    }    @Override    public int onStartCommand(Intent intent, int flags, int startId) {                return super.onStartCommand(intent, flags, startId);    }    @Override    public IBinder onBind(Intent arg0) {                return null;    }}  onCreate：在Service被创建时调用，由系统调用  onDestroy：在Service被销毁时调用，由系统调用  onStartCommand：在Service启动时调用，在该方法中定义任务  onBind：返回IBinder对象，app通过IBinder对象与Service通信onStartCommand方法的返回值决定了系统如何处理该Service  START_STICKY：若系统杀死Service后会重新创建，但不能接收intent  START_NOT_STICKY：系统杀死Service后不会重新创建  START_REDELIVER_INTENT：系统杀死Service后会重新创建，能够接收intent注册Service在AndroidManifest.xml中注册&lt;service android:name=\".TestService\"         android:enabled=\"true\"&gt;    &lt;intent-filter&gt;          &lt;action android:name=\"com.example.service.TEST_SERVICE\"/&gt;      &lt;/intent-filter&gt; &lt;/service&gt;启动和停止Service相关方法  startService：启动一个Service  bindService：绑定一个Service  stopService：停止一个Service几种不同的启动方式，Service内部方法的执行顺序不同      调用startService()启动    依次调用onCreate()、onStartCommand()，若多次调用startService()，则复用创建的Service对象，重新调用onStartCommand()    通过这种方式启动Service，Service的生命周期独立于app，只能调用stopService()来停止        调用bindService()启动    依次调用onCreate()、onBind()，若多次调用bindService()，则复用创建的Service对象，不会重新调用onBind()，直接将IBinder对象返回给调用端，用于与调用端通信    调用unbindService()解除绑定，会调用Service的onUnbind()，当不存在绑定时，调用onDestroy()    通过这种方式启动Service，Service的生命周期与调用端绑定，当调用端销毁，Service也停止        启动后绑定    先调用startService()启动服务，再调用bindService()绑定    Service内部触发的方法依次是onCreate()，onStartCommand()，onBind()，onUnbind()，onRebind()    通过这种方式启动Service，Service的生命周期独立，通过onBind()返回的IBinder与app通信，调用onUnbind时也不会停止，可以反复绑定  ServiceConnection对象：bindService()的参数，可用于监听app与Service的连接情况public class MyServiceConnection extends ServiceConnection {    //Activity与Service断开连接时回调该方法      @Override      public void onServiceDisconnected(ComponentName name) {          System.out.println(\"------Service DisConnected-------\");      }                //Activity与Service连接成功时回调该方法      @Override      public void onServiceConnected(ComponentName name, IBinder service) {         System.out.println(\"------Service Connected-------\");          binder = (MyBinder) service;  // onBind返回的IBinder对象    }  }Activity与Service通信将Activity与Service进行绑定，使Activity可以调用Service中的方法  在MyService类中定义MyBinder类，继承Binder类，在该类中提供执行的方法  在MyService类中创建MyBinder类的实例，在onBind()中返回该对象  在MainActivity中创建ServiceConnection实现类对象，重写方法  通过Intent将Activity与Service绑定，调用bindService()，传入intent和connection对象和值Service.BIND_AUTO_CREATE，表示绑定后自动创建Service，其中会执行MyService的onCreate()，不执行onStartCommand()MyService实现Service类public class TestService extends Service {      private final String TAG = \"TestService\";      private int count;      private boolean quit;            //定义onBinder方法所返回的对象      private MyBinder binder = new MyBinder();          public class MyBinder extends Binder {          public int getCount() {              return count;          }      }            //必须实现的方法,绑定改Service时回调该方法      @Override      public IBinder onBind(Intent intent) {          Log.i(TAG, \"onBind方法被调用!\");          return binder;      }        //Service被创建时回调      @Override      public void onCreate() {          super.onCreate();          Log.i(TAG, \"onCreate方法被调用!\");          //创建一个线程动态地修改count的值          new Thread() {              public void run() {                  while(!quit) {                      try {                          Thread.sleep(1000);                      } catch(InterruptedException e) {                        e.printStackTrace();                    }                      count++;                  }              };          }.start();      }            //Service断开连接时回调      @Override      public boolean onUnbind(Intent intent) {          Log.i(TAG, \"onUnbind方法被调用!\");          return true;      }            //Service被关闭前回调      @Override      public void onDestroy() {          super.onDestroy();          this.quit = true;          Log.i(TAG, \"onDestroyed方法被调用!\");      }            @Override      public void onRebind(Intent intent) {          Log.i(TAG, \"onRebind方法被调用!\");          super.onRebind(intent);      }  } 在Activity中使用Servicepublic class MainActivity extends Activity {      // ...          // IBinder引用    MyBinder binder;          // ServiceConnection实现    private ServiceConnection conn = new ServiceConnection() {                    //Activity与Service断开连接时回调该方法          @Override          public void onServiceDisconnected(ComponentName name) {              System.out.println(\"------Service DisConnected-------\");          }                    //Activity与Service连接成功时回调该方法          @Override          public void onServiceConnected(ComponentName name, IBinder service) {              System.out.println(\"------Service Connected-------\");              binder = (TestService2.MyBinder) service;          }      };            @Override      protected void onCreate(Bundle savedInstanceState) {          super.onCreate(savedInstanceState);          // ...                // 创建intent        final Intent intent = new Intent();          intent.setAction(\"com.example.service.TEST_SERVICE\");                  // 绑定Service        btnbind.setOnClickListener(v -&gt; {            bindService(intent, conn, Service.BIND_AUTO_CREATE);        });                // 解除绑定        btncancel.setOnClickListener(v -&gt; {            unbindService(conn);        });                    btnstatus.setOnClickListener(v- &gt; {            // 调用MyBinder方法，使用前最好判空            int count = binder.getCount()        });      }  }IntentService使用Service进行耗时操作时，容易引发ANR，这是由于Service不会创建线程，它与app处于同一个进程中使用IntentService可以解决该问题，IntentService中存在一个任务队列，将请求的Intent放入队列中，在后台线程进行处理继承IntentService类实现相应方法public class TestService extends IntentService {      private final String TAG = \"hehe\";          //必须实现父类的构造方法      public TestService() {          super(\"TestService\");      }        //必须重写的核心方法，该方法在后台线程中调用    @Override      protected void onHandleIntent(Intent intent) {                //Intent是从Activity发过来的，携带识别参数，根据参数不同执行不同的任务          String action = intent.getExtras().getString(\"param\");          if(action.equals(\"s1\")) {            Log.i(TAG,\"启动service1\");        } else if (action.equals(\"s2\")) {            Log.i(TAG,\"启动service2\");        } else if (action.equals(\"s3\")) {            Log.i(TAG,\"启动service3\");        }                  //让服务休眠2秒          try {              Thread.sleep(2000);          } catch(InterruptedException e) {             e.printStackTrace();        }              }        @Override      public IBinder onBind(Intent intent) {          Log.i(TAG,\"onBind\");          return super.onBind(intent);      }        @Override      public void onCreate() {          Log.i(TAG,\"onCreate\");          super.onCreate();      }        @Override      public int onStartCommand(Intent intent, int flags, int startId) {          Log.i(TAG,\"onStartCommand\");          return super.onStartCommand(intent, flags, startId);      }          @Override      public void setIntentRedelivery(boolean enabled) {          super.setIntentRedelivery(enabled);          Log.i(TAG,\"setIntentRedelivery\");      }            @Override      public void onDestroy() {          Log.i(TAG,\"onDestroy\");          super.onDestroy();      }}"
  },
  
  {
    "title": "Android基础——数据存储与共享",
    "url": "/posts/android-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E4%B8%8E%E5%85%B1%E4%BA%AB/",
    "categories": "Android",
    "tags": "Android",
    "date": "2024-04-24 22:04:00 +0800",
    





    
    "snippet": "文件存储内部存储与外部存储应用的存储区域在逻辑上分为内部存储和外部存储，机身存储和SD卡存储逻辑上都属于外部存储应用在两个存储区域通过包名来标识，当删除应用时，两个存储区域的对应包名文件夹也会删除      内部存储    /data目录，存储SharedPreference和SQLite数据库，包含files和cache目录，非root手机中不可见        外部存储    /stor...",
    "content": "文件存储内部存储与外部存储应用的存储区域在逻辑上分为内部存储和外部存储，机身存储和SD卡存储逻辑上都属于外部存储应用在两个存储区域通过包名来标识，当删除应用时，两个存储区域的对应包名文件夹也会删除      内部存储    /data目录，存储SharedPreference和SQLite数据库，包含files和cache目录，非root手机中不可见        外部存储    /storage目录，可在文件管理器中访问，包名文件夹位于/storage/**/Android/data/下，包名文件夹中包含files和cache目录    读写外部存储时需要添加权限    &lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/&gt;&lt;uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\"/&gt;      内部存储获取方法：通过Context类获取  getDir(name, mode)：在data目录下获取或创建名称为name的目录  getFilesDir()：返回内部存储的files目录  getCacheDir()：返回内部存储的cache目录  Environment.getDataDirectory()：返回data目录（内部存储根目录）外部存储获取方法：通过Context类获取  Environment.getExternalStorageDirectory()：获取外部存储根目录  Environment.getExternalStoragePublicDirectory(\"\")：获取外部存储根目录  getExternalFilesDir()：获取外部存储的files目录及其子目录  getExternalCacheDir()：获取外部存储的cache目录其他目录  Environment.getDownloadCacheDirectory()：获取/cache目录  Environment.getRootDirectory()：获取/system目录文件基本操作文件的操作模式  MODE_PRIVATE：默认模式，表示该文件只能被应用本身访问，重新写入会覆盖原内容  MODE_APPEND：追加模式  MODE_WORLD_READABLE：当前文件可被其他应用读取  MODE_WORLD_WRITEABLE：当前文件可被其他应用写入内部存储文件操作方法：Context类方法，流操作同Java  openFileOutput(filename, mode)：打开文件输出流，文件位于内部存储files目录中  openFileInput(filename)：打开文件输入流，文件位于内部存储files目录中外部存储文件操作：获取外部存储目录后，通过文件名获取File对象，操作文件流SharedPreferencesSharedPreferences使用键值对进行存储，存储在内部存储中，使用XML格式管理文件，通常用于配置信息存储获取SharedPreferences对象      context.getSharedPreferences(name, mode)    mode参数只选MODE_PRIVATE，表示只有当前应用程序对该对象进行读写        activity.getSharedPreferences(mode)    文件名默认为当前Activity的类名  存储数据  调用SharedPreferences对象的edit()，获取Editor对象  调用Editor对象的putString,putBoolean等方法添加数据，参数为键值对  调用commit()提交数据SharedPreferences sp = context.getSharedPreferences(\"my_sp\", MODE_PRIVATE);Editor editor = sp.edit();editor.putString(\"username\", \"value1\");editor.putString(\"password\", \"value2\");editor.commit();读取数据：调用SharedPreferences对象的getString，getInt等方法SharedPreferences sp = context.getSharedPreferences(\"my_sp\", MODE_PRIVATE);String username = sp.getString(\"username\", \"default_value\");String password = sp.getString(\"password\", \"default_value\");SQLite数据库SQLite是一个轻量级关系型数据库，数据库文件存放在/data/data/&lt;packagename&gt;/databases/目录下SQLite中的三个核心类  SQLiteOpenHelper：用于管理数据库，使用时继承该类，重写它的onCreate()和onUpgrade()方法，定义数据库创建和更新的操作  SQLiteDatabase：数据库访问类，通过该类方法操作数据库  Cursor：数据库记录指针，可用于遍历结果集数据库管理通过SQLiteOpenHelper类的实例方法可获取SQLiteDatabase数据库对象，首次调用时会调用onCreate()  getReadableDatabase()：以只读方式打开数据库  getWritableDatabase()：以可写方式打开数据库，当数据库不可写入时，调用会抛出异常继承SQLiteOpenHelper示例public class MyDBOpenHelper extends SQLiteOpenHelper {    public MyDBOpenHelper(Context context, String name, CursorFactory factory, int version) {        // factory参数用于自定义cursor        // 定义数据库名称和版本号        super(context, \"my.db\", null, 1);     }        @Override    public void onCreate(SQLiteDatabase db) {        // 通过SQL语句操作数据库        db.execSQL(\"CREATE TABLE person(personid INTEGER PRIMARY KEY AUTOINCREMENT,name VARCHAR(20))\");    }        //软件版本号发生改变时调用    @Override    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {        db.execSQL(\"ALTER TABLE person ADD phone VARCHAR(12) NULL\");    }}数据库操作调用SQLiteDatabase对象方法来操作数据库SQL语句  execSQL：执行SQL语句，传入SQL语句字符串和占位符参数，SQL语句中占位符是?问号  rawQuery：执行SQL语句查询，传入SQL语句字符串和占位符参数，返回一个Cursor对象，用于遍历结果集添加数据调用insert()，第一个参数为表名，第二个参数为将未指定数据的可空列自动赋值为null，第三个参数为一个ContentValues对象，表示一个键值对ContentValues values = new ContentValues();values.put(\"name\", \"hello\");db.insert(\"person\", null, values);更新数据调用update()，第一个参数为表名，第二个参数是ContentValues对象，表示修改后的数据，第三、四个参数用于where约束，不指定默认更新所有行ContentValues values = new ContentValues();values.put(\"name\", \"world\");db.update(\"person\", values, \"name = ?\", new String[]{\"hello\"});删除数据调用delete()，第一个参数为表名，第二、三个参数指定约束，不指定默认删除所有行db.delete(\"person\", \"personid = ?\", new String[]{\"3\"});查询操作调用query()，传入参数指定子句或约束，声明如下public Cursor query(    String table,     String[] columns,     String selection,     String[] selectionArgs,    String groupBy,     String having,     String orderBy,     String limit);  table：指定表名  columns：指定列名  selection：指定where条件  selectionArgs：为where条件的占位符提供值  groupBy：指定需要groupby的列  having：having子句  orderby：指定排序的列  limit：指定limit子句Cursor指针query方法和rawQuery方法返回一个Cursor对象，通过该对象获取数据  move(offset)：向前或向后移动指定行数，负数表示向前移动  moveToFirst()：使cursor移动到第一行，返回true表示有数据  moveToLast()：使cursor移动到最后一行，返回true  moveToNext()：使cursor移动到下一行，返回true表示下一行有数据  moveToPrevious()：使cursor移动到上一行  getCount()：返回总行数  isFirst()：是否是第一行  isLast()：是否是最后一行  moveToPosition(int)：移动到指定行  getColumnIndex(String)：获取指定列的列索引  getXXX(int)：返回当前行的指定列索引的数据使用事务事务可以使一组操作变为原子操作  beginTransaction()：开启事务  endTransaction()：关闭事务SQliteDatabase db = helper.getWritableDatabase();db.beginTransaction();try {    // ...} catch (Exception e) {    // ...} finally {    db.endTransaction();  // 最终关闭事务}ContentProvider数据共享Android应用通过ContentProvider来实现应用间共享数据URIURI为统一资源标识符，主要由scheme、authority和path组成，使用ContentProvider时，authority通常为packagename.providerAndroid常用的scheme  content：本地资源  file：本地文件  http：网络资源  tel：打电话  smsto：发送短信URI通配符  *表示匹配任意长度的任意字符  #表示匹配任意长度的数字  Uri.parse()方法可以将URI字符串解析为Uri对象访问ContentProvider通过ContentResolver类访问其他程序的ContentProvider，调用Context的getContentResolver()获取实例基本操作方法      添加数据    Uri insert(Uri uri, ContentValues values)            删除数据：通过where子句添加约束    int delete(Uri uri, String where, String[] args)            查询数据    Cursor query(    Uri uri,     String[] projection,     String selection,     String[] selectionArgs,     String sortOrder)            更新数据    int update(Uri uri, ContentValues values, String where, String[] selectionArgs)      Android11后，在访问其他程序的ContentProvider需要在AndroidManifest.xml中声明queries标签&lt;queries&gt;    &lt;package android:name=\"com.example.databasetest\"/&gt;&lt;/queries&gt;自定义ContentProvider自定义ContentProvider用于给其他程序提供数据访问接口实现ContentProvider自定义继承ContentProvider的类，重写六个方法，也可默认空实现      onCreate()：在初始化时调用，用于创建数据库或升级数据库，返回初始化是否成功        query()：查询，结果放入Cursor对象返回        insert()：添加数据，返回这条新纪录的URI        update()：更新数据，返回受影响的行数        delete()：删除数据，返回被删除的行数        getType()：返回传入的URI对应的MIME类型  自定义ContentProvider需要在AndroidManifest.xml中注册&lt;provider      android:name=\"com.example.bean.MyContentProvider\"      android:authorities=\"com.example.providers.myprovider\"      android:exported=\"true\"&gt;&lt;/provider&gt;URI注册在ContentProvider中需要借助UriMatcher类注册特定的URI调用addURI(authority, path, code)，该方法将URI与一个自定义编码code绑定起来，调用match(uri)时返回code，即URI为content://authority/path时，match方法返回注册的codeUriMatcher matcher = new UriMatcher(UriMatcher.NO_MATCH);matcher.addURI(\"com.example.myprovider\", \"user1\", 1);matcher.addURI(\"com.example.myprovider\", \"user2\", 2);switch (matcher.match(uri)) {    case 1:        // ...        break;    case 2:        // ...        break;    default:        break;}其他工具类ContentUris类：URI相关处理  withAppendedId(uri, int)：在URI后追加一个id  parseId(uri)：解析URI中的idContentObserver类：用于将ContentProvider内的数据变化通知给ContentResolverresolver.registerContentObserver(uri);  // resolver注册观察者，观察URI的数据变化public class MyProvider extends ContentProvider {        public Uri insert(Uri uri, ContentValues values) {         // ...        getContext().getContentResolver().notifyChange(uri, null);  // 通知访问者    }}resolver.unregisterContentObserver(uri);  // 注销观察者"
  },
  
  {
    "title": "Android基础——广播",
    "url": "/posts/android-%E5%B9%BF%E6%92%AD/",
    "categories": "Android",
    "tags": "Android",
    "date": "2024-04-19 12:29:00 +0800",
    





    
    "snippet": "开始广播机制在程序之间的交互中使用，每个程序都可以发送和接收广播，在程序内也可通过广播实现Activity通信广播的类型      标准广播    标准广播是一种异步执行的广播，广播发出后，所有Receiver都会同时接收到这条广播，该类型的广播无法被截断        有序广播    有序广播是一种同步执行的广播，广播的接收按Receiver的优先级决定，同时每个Receiver可以决定该...",
    "content": "开始广播机制在程序之间的交互中使用，每个程序都可以发送和接收广播，在程序内也可通过广播实现Activity通信广播的类型      标准广播    标准广播是一种异步执行的广播，广播发出后，所有Receiver都会同时接收到这条广播，该类型的广播无法被截断        有序广播    有序广播是一种同步执行的广播，广播的接收按Receiver的优先级决定，同时每个Receiver可以决定该广播是否继续传播        显式广播    显式广播是指定了要发送的应用程序的广播        隐式广播    隐式广播没有指定发送的应用程序，指定了一些信息，发送给符合信息的应用程序  广播的注册广播注册分为动态注册和静态注册两种，动态注册可以实现灵活的广播注册和注销，但必须要程序启动后才能接收到广播。若要在程序未启动时，比如刚开机的情况下接受到系统的开机广播，就需要使用静态注册，但静态注册长期监听，消耗更多资源，因此大部分情况建议优先使用动态注册解决问题定义广播接收器：自定义类继承BroadcastReceiver，重写onReceive方法public class MyReceiver extends BroadcastReceiver {    @Override    public void onReceive(Context context, Intent intent) {        // ...    }}动态注册在Activity运行时将一个BroadcastReceiver注册为接收器  构造IntentFilter对象，调用addAction()添加action，指定Receiver接收的广播类型  构造接收器对象  调用registerReceiver()，传入接收器和IntentFilter  调用unregisterReceiver()注销接收器IntentFilter filter = new IntentFilter();filter.addAction(Intent.ACTION_SCREEN_ON);  // 监听屏幕亮起filter.addAction(Intent.ACTION_SCREEN_OFF);  // 监听屏幕熄灭MyReceiver receiver = new MyReceiver();registerReceiver(receiver, filter);  // 注册广播接收器unregisterReceiver(receiver);  // 注销广播接收器静态注册在AndroidManifest.xml中application标签中的receiver标签中注册receiver标签  name：指定自定义广播接收器类  exported：是否允许该Receiver接收本程序以外的广播  enabled：是否启用该Receiver  intent-filter：在该标签中添加action标签来指定接收的广播类型  静态接收器由于会消耗资源一直监听，因此许多系统广播不允许静态接收器监听，允许监听的系统广播需要添加权限  静态接收器不能接收隐式广播发送自定义广播发送标准广播构造Intent对象，传入自定义广播的action值，所有监听该action值的Receiver就会收到消息// 发送广播Intent intent = new Intent(\"com.example.myapplication.MY_BROADCAST\");// 对于静态接收器，不能接收隐式广播，因此需要设置广播发送的应用程序// intent.setPackage(getPackageName())sendBroadcast(intent);  // 发送广播// 注册接收器MyReceiver receiver = new MyReceiver();IntentFilter filter = new IntentFilter();filter.addAction(\"com.example.myapplication.MY_BROADCAST\");registerReceiver(receiver, filter);发送有序广播在发送广播时调用sendOrderedBroadcast()发送有序广播，传入intent和关于权限的字符串，设为null即可调用abortBroadcast()可将广播截断// 发送广播Intent intent = new Intent(\"com.example.myapplication.MY_BROADCAST\");sendOrderedBroadcast(intent);  // 发送有序广播// 注册接收器MyReceiver receiver = new MyReceiver();IntentFilter filter = new IntentFilter();filter.addAction(\"com.example.myapplication.MY_BROADCAST\");filter.setPriority(1000);  // 设置接收器的优先级registerReceiver(receiver, filter);// 接收广播public class MyReceiver extends BroadcastReceiver {    @Override    public void onReceive(Context context, Intent intent) {        // ...        abortBroadcast();  // 截断广播    }}本地广播本地广播是指只在本应用程序内发送和接收的广播，其他程序不能接收本程序的本地广播通过LocalBroadcastManager来发送广播// 获取LocalBroadcastManager实例LocalBroadcastManager manager = LocalBroadcastManager.getInstance(this);// 创建Receiver和IntentFilter...manager.registerReceiver(receiver, intentFilter);  // 注册本地接收器manager.unregisterReceiver(receiver);  // 注销本地接收器manager.sendBroadcast(intent);  // 发送广播"
  },
  
  {
    "title": "Android基础——Activity",
    "url": "/posts/android-activity/",
    "categories": "Android",
    "tags": "Android",
    "date": "2024-04-18 13:22:00 +0800",
    





    
    "snippet": "开始Activity是四大组件之一，是一个包含用户界面的组件，用于和用户进行交互一个程序可以存在多个Activity，每个Activity必须重写onCreate方法，在onCreate方法中设置布局文件，setContentView(R.layout.l)Activity需要在AndroidManifest.xml中注册才能生效在AndroidManifest中在activity标签中注册...",
    "content": "开始Activity是四大组件之一，是一个包含用户界面的组件，用于和用户进行交互一个程序可以存在多个Activity，每个Activity必须重写onCreate方法，在onCreate方法中设置布局文件，setContentView(R.layout.l)Activity需要在AndroidManifest.xml中注册才能生效在AndroidManifest中在activity标签中注册，android:name属性指明注册的Activityactivity标签中的intent-filter标签中指定该标签为主Activity&lt;intent-filter&gt;\t&lt;action android:name=\"android.intent.action.MAIN\"/&gt;    &lt;category android:name=\"android.intent.category.LAUNCHER\"/&gt;&lt;/intent-filter&gt;Activity销毁：销毁Activity表示退出当前界面，调用finish()销毁当前ActivityActivity交互Intent是各个组件交互的方式，通过Intent在不同Activity间进行跳转，它指明了改组件想要执行的动作或者在组件间传递数据  注意多个Activity都需要在AndroidManifest中进行注册显式Intent通过构造函数构造一个Intent对象，传入启动Activity的上下文和想要启动的目标Activity.class，在调用startActivity(intent)启动ActivityIntent intent = new Intent(context, Activity.class);context.startActivity(intent);隐式Intent在AndroidManifest.xml指定action和category等信息，由系统去分析信息，启动能够响应这些信息的Activity，通过隐式Intent可以也启动其他程序的Activity基本步骤      通过intent-filter标签下的action和category标签指定信息    &lt;!--设置Activity能够响应的action和category--&gt;&lt;activity android:name=\".Activity\"&gt;\t&lt;intent-filter&gt;\t\t&lt;action android:name=\"com.example.activitytest.ACTION_START\"/&gt;        &lt;category android:name=\"android.intent.category.DEFAULT\"/&gt;    &lt;/intent-filter&gt;&lt;/activity&gt;            构造Intent对象时传入相应的信息字符串，即可启动相应的Activity    Intent intent = new Intent(\"com.example.activitytest.ACTION_START\");context.startActivity(intent);            每个Intent对象只能指定一个action信息，但可以指定多个category信息，通过addCategory()添加  data标签：在intent-filter标签中设置data标签，可以指明该Activity可以响应什么类型的数据data标签属性  scheme:指定协议部分，https协议，geo地理位置，tel拨打电话  host:指定数据的主机名  port:指定数据的端口  path:指定数据域名后的路径  mimeType:指定可以处理的数据类型启动系统浏览器Intent intent = new Intent();intent.setAction(\"android.intent.action.VIEW\");Uri url = Uri.parse(\"https://www.baidu.com/\");intent.setData(url);startActivity(intent);启动Activity的最佳实践当启动一个Activity时，可能需要向Activity传递参数，但可能并不知道参数是什么在该Activity中定义一个静态方法actionStart()，传入启动该Activity的上下文和需要的参数，在该方法中构造Intent对象完成数据传递，同时简化了启动代码public static void actionStart(Context context,String data1,String data2){\tIntent intent = new Intent(context,SecondActivity.class);\tintent.putExtra(\"param1\",\"data1\");\tintent.putExtra(\"param2\",\"data2\");\tcontext.startActivity(intent);}// 使用时，参数直接在参数列表中体现SecondActivity.actionStart(FirstActivity.this,\"data1\",\"data2\");向Activity传递数据将数据存储在Intent中，在下一个Activity中将数据中Intent中取出调用Intent.putExtra(key, value)将数据存储到Intent中，采用键值对存储在下一个Activity中调用getIntent()获取Intent对象调用intent.getStringExtra(key)获取value，根据value的类型来调用getStringExtra()、getIntExtra()等返回数据给Activity  startActivityForResult方法已弃用，仅记录最新方法在新版Android中，将两个Activity的数据交互作了对象封装，使用一个ActivityResultLauncher对象封装返回数据的回调操作，同时通过它来启动Activity// 调用registerForActivityResult注册一个launcher// 传入Activity返回结果的协定，即StartActivityForResult// 传入返回数据回调ActivityResultLauncher&lt;Intent&gt; intentActivityResultLauncher = registerForActivityResult(        new ActivityResultContracts.StartActivityForResult(),        result -&gt; {            if (result.getResultCode() == RESULT_OK) {                //获取返回的结果                String data = result.getData().getStringExtra(\"data\");            }        }); // 通过launcher启动ActivityIntent intent = new Intent(context, Activity.class);intent.putExtra(\"data\", \"xxx\");intentActivityResultLauncher.launch(intent);Activity的生命周期Activity的层叠结构为栈Activity的四种状态  运行状态：当前正在操作的Activity处于运行状态  暂停状态：Activity不再处于栈顶，但仍然可见(栈顶Activity大小没有占满屏幕)  停止状态：Activity不处于栈顶也不可见  销毁状态：Activity从栈移除后处于销毁状态，系统会回收该ActivityActivity的状态缓存：Activity被回收后重建，保存输入的临时数据Activity在被回收前会调用onSaveInstanceState()方法，可以重写该方法添加自定义的临时数据，以便在Activity重建时，通过onCreate的bundle参数获取临时数据onSaveInstanceState()方法传入一个Bundle类型的参数，其中包含了当前Activity的临时数据，调用putString()、putInt()等方法通过键值对保存数据在OnCreate()中判断Bundle参数是否为null，调用getString()、getInt()等方法获取保存的数据public class MainActivity extends AppCompatActivity {    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        String myString = \"\";        // 获取状态缓存        if (savedInstanceState != null) {            myString = savedInstanceState.getString(\"MyString\");        }    }        @Override    public void onSaveInstanceState(Bundle savedInstanceState) {        // 缓存状态        savedInstanceState.putString(\"MyString\", \"Welcome back to Android\");        super.onSaveInstanceState(savedInstanceState);    }}  在手机屏幕旋转时会重新创建Activity，调用onCreate()，可以使用onSaveInstanceState()保存临时数据或通过ViewModel保存Activity的启动模式Activity的启动模式有四种：standard, singleTop, singleTask, singleInstance，通过activity标签的launchMode属性指定启动模式  standard：在Activity处于栈顶时依然会创建该Activity的新的实例  singleTop：在Activity处于栈顶时不会重复创建实例，直接使用栈顶Activity，处于其他位置时会重复创建  singleTask：当启动某个Activity时会检查整个栈，若已存在相同实例，则直接使用该实例并将在其之上的其他实例出栈，使其成为栈顶，若没有，则创建新的实例  singleInstance：使用一个新的栈来管理启动的Activity，该返回栈独立于当前程序的返回栈，当其他程序访问该Activity时，会共用这个返回栈，当程序处理返回栈时，优先处理程序本身的返回栈，最后处理独立的返回栈Activity相关工具Toast弹出提示调用Toast的静态方法makeText，返回一个Toast对象，再调用show()显示提示Toast.makeText(this, \"Tip\", Toast.LENGTH_SHORT).show();makeText()传入三个参数  Toast所处的上下文，传入this即可  Toast显示的内容  Toast显示的时长，可选Toast.LENGTH_SHORT,Toast.LENGTH_LONGLog日志工具使用Log类进行日志记录打印日志方法  Log.v()：对应级别verbose，打印级别最低的日志  Log.d()：对应级别debug，打印调试信息  Log.i()：对应级别info，打印一般信息  Log.w()：对应级别warn，打印警告信息  Log.e()：对应级别error，打印错误信息方法传入两个参数，tag和msg，tag用于对日志信息进行过滤，msg为打印的日志内容添加自定义过滤器，tag参数输入过滤器的日志标签，可打印对应标签的的日志FragmentFragment是一种可以嵌入在Activity中的UI片段，可以充分利用大屏幕空间，用于在一个Activity中显示不同布局，当切换布局时只需引入fragment静态添加Fragment  编写Fragment的布局  自定义Fragment类继承AndroidX的Fragment类  重写onCreateView，动态加载Fragment的布局  在Activity布局中添加fragment控件，name属性指定要在该控件处实例化的Fragment类动态添加Fragment  在Activity布局中添加一个布局容器，不添加内容  创建要添加的Fragment实例  调用getSupportFragmentManager()获取FragmentManager对象  开启一个事务，调用manger.beginTransaction()，返回一个FragmentTransaction对象  调用transaction.replace()，传入布局容器的id和要添加的Fragment实例  若要返回时不退出Activity而返回上一个Fragment，调用transaction.addToBackStack(null)  调用transaction.commit()提交事务Fragment与Activity交互      Activity中调用Fragment    使用FragmentManager中的findFragmentById(R.id.frag)获取该布局的Fragment类实例        Fragment中调用Activity    调用getActivity()获取与该类实例相关联的Activity，Activity是Context类型，可供Fragment使用  Fragment的生命周期与Activity类似，被回收时也可通过onSaveInstanceState()保存数据动态加载布局根据设备的不同属性来自动选择资源中的布局资源中的子文件夹命名使用限定符可以指定该资源提供给哪一类设备屏幕特征对应的设备  大小          small：小设备      normal：中等设备      latge：大设备      xlarge：超大设备        分辨率          ldpi：低分辨率      mdpi：中分辨率      hdpi：高分辨率      xhdpi：超高分辨率      xxhdpi：超超高分辨率        方向          land：横屏      port：竖屏      最小宽度限定符：对屏幕宽度设定一个最小值(单位dp)，大于该值加载一个布局，小于该值加载另一个布局文件夹命名后缀：_sw600dp，最小宽度为600dp"
  },
  
  {
    "title": "Android基础——UI控件",
    "url": "/posts/android-ui%E6%8E%A7%E4%BB%B6/",
    "categories": "Android",
    "tags": "Android",
    "date": "2024-04-16 13:57:00 +0800",
    





    
    "snippet": "开始Android中的组件都是由View和ViewGroup组成，是一个树形结构，View就代表了一个界面控件，ViewGroup是存放多个View对象的布局容器布局LinearLayout线性布局表示一个横向或纵向的布局      orientation:设置布局的排列方式，有horizontal(水平)、vertical(垂直，默认)两种方式                       ...",
    "content": "开始Android中的组件都是由View和ViewGroup组成，是一个树形结构，View就代表了一个界面控件，ViewGroup是存放多个View对象的布局容器布局LinearLayout线性布局表示一个横向或纵向的布局      orientation:设置布局的排列方式，有horizontal(水平)、vertical(垂直，默认)两种方式                                gravity:控制子元素中内容对齐方式，可多种组合(left          bottom)                          layout_gravity:控制组件的显示内容在父容器中的对齐方式    线性布局中以排列方向上最大的组件的内容位置决定对齐标准    线性布局水平排列，button2最大，layout_gravity=bottom，则该组件的内容所在的位置为bottom，button3随之与button2的内容平行        layout_width:通常用wrap_content(匹配内容)，match_parent(填满父容器)        layout_height        id:为组件设置一个资源ID        background:设置组件的背景或背景颜色        weight:用于等比例划分区域，该属性设置后排列方向上的长度/宽度设置为0dp    在多个组件中设置该属性，使得设置的组件按比例设置大小，比例为weight值在所有组件的weight值之和的占比    需要一个组件的大小依据另一组件的大小而定时，将该组件的大小设为0，weight设为1，该组件会依据另一组件的大小占满剩余的屏幕        divider分割线          divider:设置分割线的图片      showDividers:设置分割线所在位置，可选none,middle,beginning,end      dividerPadding:设置分割线的padding      RelativeLayout相对布局表示一个控件相对于其他控件设置位置的布局      gravity:设置容器内组件内容的对齐方式        IgnoreGravity：设置该属性为true的组件不受gravity属性的影响        根据父容器定位          layout_centerHrizontal:水平居中      layout_centerVertical:垂直居中      layout_centerInparent:相对于父元素完全居中      layout_alignParentLeft:左对齐      layout_alignParentRight:右对齐      layout_alignParentTop:顶部对齐      layout_alignParentBottom:底部对齐                根据兄弟组件(处于同一布局的组件)定位，指定组件ID来定位          layout_toLeftOf：参考组件的内容      layout_toRightOf      layout_above      layout_below      layout_alignTop:参考组件的上边界      layout_alignBottom:参考组件的下边界      layout_alignLeft:同上      layout_alignRight:同上      FrameLayout帧布局所有控件默认摆放在左上角，控件之间可覆盖，通过layout_gravity设置在布局中的对齐方式UI控件TextView表示一个简单文本常用属性  id  layout_width  layout_height  gravity:设置控件中文字的对齐方向  text:设置文本显示的内容，一般将字符串写到string.xml中  textColor:设置文本的颜色，一般将颜色写到colors.xml中  textStyle:设置文字的风格，可选normal,bold,italic  textSize:设置字体大小，单位使用sp  background:设置控件的背景设置字体阴影  shadowColor:设置阴影颜色，需要与shadowRadius配合使用  shadowRadius:设置阴影的模糊程度，通常为3.0  shadowDx:设置阴影水平方向的偏移  shadowDy:设置阴影竖直方向的偏移带边框的TextView需要编写一个shapeDrawable，将TextView的background属性设置为该shapeDrawable资源shapeDrawable资源的节点及属性  &lt;solid android:color = \"xxx\"&gt; 这个是设置背景颜色的  &lt;stroke android:width = \"xdp\" android:color=\"xxx\"&gt; 这个是设置边框的粗细,以及边框颜色的  &lt;padding androidLbottom = \"xdp\"...&gt; 这个是设置边距的  &lt;corners android:topLeftRadius=\"10px\"...&gt; 这个是设置圆角的  &lt;gradient&gt; 这个是设置渐变色的,可选属性有          startColor:起始颜色      endColor:结束颜色      centerColor:中间颜色      angle:方向角度,等于0时,从左到右,然后逆时针方向转,当angle = 90度时从下往上      type:设置渐变的类型      带图片的TextView在文字的上下左右添加图片，传入drawable资源ID  drawableLeft  drawableRight  drawableBottom  drawableTop若需要改变图片大小，在java代码中修改autoLink链接：当文字是一个链接或一段电话号码，可使文字链接到对应网址或应用EditView表示一个文本编辑框      设置默认提示文本                  hint:默认提示文本                    textColorHint:提示文本颜色                  获得焦点后全选组件内的文本          selectAllOnFocus            限制EditText输入类型：inputType          文本：text,textUri,textPassword,textVisiblePassword,textMultiLine,textEmailAddress      数值：number,phone,date,time, datetime,numberSigned            限制输入行数：默认为多行显示，能够自动换行                  minLines:设置最小行数                    maxLines:设置最大行数，超过最大行数时会自动向上滚动                    singleLine:只允许单行输入，且不能滚动                  设置文字间隔，设置英文字母大写类型                  textScaleX:设置水平间隔                    textScaleY:设置数之间各竖直间隔                    capitalize:设置英文字母大写类型                  sentences:第一个字母大写          words:每个单词首字母大写，用空格分隔          characters:每个字母都大写                          获取输入文本：editText.getText().toString()    获取的值不会为null，但可能为空字符串  StateListDrawableStateListDrawable可根据不同的状态设置不同的图片效果，根节点为&lt;selector&gt;  drawable:引用的Drawable位图,我们可以把他放到最前面,就表示组件的正常状态~  state_focused:是否获得焦点  state_window_focused:是否获得窗口焦点  state_enabled:控件是否可用  state_checkable:控件可否被勾选,eg:checkbox  state_checked:控件是否被勾选  state_selected:控件是否被选择,针对有滚轮的情况  state_pressed:控件是否被按下  state_active:控件是否处于活动状态,eg:slidingTab  state_single:控件包含多个子控件时,确定是否只显示一个子控件  state_first:控件包含多个子控件时,确定第一个子控件是否处于显示状态  state_middle:控件包含多个子控件时,确定中间一个子控件是否处于显示状态  state_last:控件包含多个子控件时,确定最后一个子控件是否处于显示状态Button表示一个按钮继承了TextView，属性基本同TextView，text属性的文字会默认转换为大写，可设置textAllCaps=false取消注册监听器：调用button.setOnClickListener()，传入一个lambda表达式ImageView表示一张图片，src指定drawable中的图片资源，图片一般放在xxhdpi分辨率下在代码中可以动态的更改图片，调用imageView.setImageResource(R.drawable.pic)ProgressBar用于显示一个进度条，表示程序正在加载数据      style属性设置进度条的样式    水平进度条：style=\"?android:attr/progressBarStyleHorizontal\"        max属性设置进度条最大值    在代码中progressBar.progress属性可动态设置进度条进度    通过visibility属性设置控件可见或不可见，可选visible,invisible,gone  visible和invisible表示控件可见或不可见，控件还占据原来的位置，gone表示控件消失，不占据空间，Android控件均有这一属性  在代码中调用控件的setVisibility()可动态控制控件的可见状态，getVisibility()返回控件可见状态AlertDialog在当前界面弹出一个提示框，能够屏蔽所有控件，置顶于所有界面元素之上  对话框类型为AlertDialog，创建对象类型为AlertDialog.Builder  创建AlertDialog.Builder对象  调用setIcon()设置图标，setTitle()或setCustomTitle()设置标题  设置对话框的内容：setMessage()还有其他方法来指定显示的内容  调用setPositive/Negative/NeutralButton()设置：确定，取消，中立按钮  调用create()方法创建这个对象，再调用show()方法将对话框显示出来            [2.5.9 AlertDialog(对话框)详解      菜鸟教程 (runoob.com)](https://www.runoob.com/w3cnote/android-tutorial-alertdialog.html)      自定义控件引入布局编写一个自定义的局部布局，如标题栏布局，在主布局中使用include标签引入&lt;include layout=\"@layout/title\"/&gt;自定义控件为布局中的控件注册事件，使其封装为一个控件      新建布局类，继承小布局使用的布局(线性布局等)        类中构造器传入Context和AttributeSet两个参数，动态加载布局类      public class TitleLayout extends LinearLayout {      public TitleLayout(Context context, @Nullable AttributeSet attrs) {          super(context, attrs);          // inflate()的第一个参数为要加载的布局文件id，第二个参数为加载的布局添加一个父布局          LayoutInflater.from(context).inflate(R.layout.title,TitleLayout.this);      }  }            为布局中的控件注册事件  ListView允许用户上下滑动浏览列表将data传入ListView：使用适配器(常用ArrayAdapter)，构造一个适配器，指定泛型，传入Activity实例，ListView子项的布局id和数据源data，最后将ListView控件的适配器设置为构造的适配器自定义ListView子项自定义ListView子项的界面      编写子项的实体类存储显示的信息        编写子项布局        自定义实例类的适配器，继承ArrayAdapter，指定泛型    适配器的构造器传入Activity的实例，ListView子项布局id和数据源        重写getView()，该方法在子项被滚动到屏幕中时调用                  getView方法中使用LayoutInflator动态加载布局，设置inflate第三个参数为false，表示只让父布局的layout属性生效，而不添加父布局，通过调用getItem(position)获取当前项的Fruit实例，findViewById获取控件，设置当前子项的显示内容                    convertView参数用于将加载好的布局进行缓存，在上下滚动时可以重用        判断convertView是否为空，为空则动态加载，不为空令view=convertView                    ViewHolder可用于对获取控件进行优化        在Adapter类中定义一个ViewHolder内部类，类中存储布局中的控件，构造ViewHolder类对象，对加载的控件进行缓存，传入构造器中，再调用view的setTag()将ViewHolder存储在view中，convertView不为空时，调用getTag()获取ViewHolder对象            点击事件调用listView.setOnItemClickListener()注册监听器，传入parent，view，position，通过position获取子项的实例RecyclerViewRecyclerView为新增库，用于表示一个列表，可以替代ListView，在老版本Android运行需要在build.gradle添加RecyclerView的依赖  自定义适配器使用RecyclerView，继承RecyclerView.Adapter，指定泛型为class.ViewHolder，class为自定义的适配器类，重写其中的方法，ViewHolder内部类需要继承RecyclerView.ViewHolder          重写的方法                  onCreateViewHolder()：用于创建ViewHolder实例，加载子项布局（子项的布局高度需要调整为自适应），将布局传入构造器中，返回ViewHolder实例                      onBindViewHolder()：用于对RecyclerView子项赋值                    getItemCount()：返回数据源长度                      在onCreate()中构造一个布局管理器对象(线性布局LinearLayoutManager)，传入RecyclerView的setLayoutManager()中onBindViewHolder中position不准的问题调用notifyItemXXX方法时不会调用onBindViewHolder重新绑定，因此修改后每个holder的position不会改变例：数据项0,1,2对应列表项0,1,2数据索引：[0]0,[1]1,[2]2列表索引：[0]0,[1]1,[2]2修改后数据索引：[0]1,[1]2列表索引：[1]1,[2]2点击1时，position依然是1，数据中下标1的数据是2，数据与列表不对应调用holder.getAbsoluteAdapterPosition获取绝对位置横向滚动和瀑布流布局  横向滚动          修改子项布局的排列方式为vertical，固定宽度，设置控件的对齐方式      设置LinearLayoutManager对象的orientation为HORIZONTAL        瀑布流布局          RecyclerView内置GridLayoutManager网格布局和StaggeredGridLayoutManager瀑布流布局      构造StaggeredGridLayoutManager对象，传入显示的列数和排列方向      子项布局的宽度根据列数自动适配，设为match_parent即可      点击事件需要为每个子项View注册点击事件在适配器的onCreateViewHolder()中使用ViewHolder可以为最外层布局(itemView)或者布局内控件注册事件调用getAdapterPosition()获取position，进而获取对象9-patch图片9-patch图片可以指定那些区域可以被拉伸，哪些区域填充内容在Android Studio中可以从.png图片创建.9.png图片，创建后将原图片删除或重命名，在边框填充小黑点指定区域左边框和上边框的黑点区域表示拉伸的区域，右边框和下边框的黑点区域表示内容允许放置的位置"
  },
  
  {
    "title": "Android基础——开始",
    "url": "/posts/android-%E5%BC%80%E5%A7%8B/",
    "categories": "Android",
    "tags": "Android",
    "date": "2024-04-16 13:56:00 +0800",
    





    
    "snippet": "XMLXML是一种可扩展的数据标记语言，被用于传输数据基本语法  XML的标签为自定义标签，标签必须成对  XML结构为树结构，需要有一个根标签，通常具有头声明  xml属性必须用引号包围，单引号或双引号都可以，若属性值包含双引号，则可以用单引号包围属性值，或者使用实体引用&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;root&gt;\t&lt...",
    "content": "XMLXML是一种可扩展的数据标记语言，被用于传输数据基本语法  XML的标签为自定义标签，标签必须成对  XML结构为树结构，需要有一个根标签，通常具有头声明  xml属性必须用引号包围，单引号或双引号都可以，若属性值包含双引号，则可以用单引号包围属性值，或者使用实体引用&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;root&gt;\t&lt;name&gt;&lt;/name&gt;    &lt;author&gt;&lt;/author&gt;    &lt;msg&gt;        &lt;price&gt;&lt;/price&gt;    &lt;/msg&gt;&lt;/root&gt;常用实体引用            \\&lt;      &lt;      小于                  \\&gt;      &gt;      大于              \\&amp;      &amp;      和号              \\'      ’      单引号              \\\"      ”      引号      xml的样式表语言为XSLT，也可使用css设置样式样式链接声明：&lt;?xml-stylesheet type=\"text/xsl\" href=\"simple.xsl\"?&gt;命名空间用于解决不同xml文档中相同标签的冲突      使用前缀解决冲突：&lt;h:table&gt;&lt;/h:table&gt;        使用默认命名空间    在冲突标签中加入xmlns属性，&lt;table xmlns=\"namespaceURL\"&gt;&lt;/table&gt;        使用前缀+命名空间    在冲突标签中加入前缀和xmlns属性，&lt;h:table xmlns:h=\"namespaceURL\"&gt;&lt;/h:table&gt;  CDATA标签当标签内使用大量不需要解析的字符，如使用大量实体引用或代码，可以使用CDATA标签&lt;![CDATA[\tcontent]]&gt;工程项目结构使用Android Studio创建Android工程得到如下项目结构编程时主要使用java和res两个文件夹  java:业务代码存放的地方  res:存放资源文件的地方，如图片，音频，动画和其他xml文件资源文件资源文件放在res文件夹中  drawable：存放各种位图文件，(.png，.jpg，.9png，.gif等)除此之外可能是一些其他的drawable类型的XML文件  mipmap-hdpi：高分辨率，一般我们把图片丢这里  mipmap-mdpi：中等分辨率，很少，除非兼容的的手机很旧  mipmap-xhdpi：超高分辨率，手机屏幕材质越来越好，以后估计会慢慢往这里过渡  mipmap-xxhdpi：超超高分辨率，这个在高端机上有所体现  layout：该目录存放布局文件  values目录          demens.xml：定义尺寸资源      string.xml：定义字符串资源，在代码中通过R.string.string_name或者在xml中通过@string/string_name获取      styles.xml：定义样式资源      colors.xml：定义颜色资源      arrays.xml：定义数组资源      attrs.xml：自定义控件时用的较多，自定义控件的属性！      theme主题文件，和styles很相似，但是会对整个应用中的Actvitiy或指定Activity起作用，一般是改变窗口外观的，可在Java代码中通过setTheme使用，或者在Androidmanifest.xml中为添加theme的属性        raw目录：存放音频视频等  动画          animator：存放属性动画的XML文件      anim：存放补间动画的XML文件      三大文件解析      MainActivity.java：程序的主页面，可在AndroidManifest.xml中修改      package jay.com.example.firstapp;      import android.support.v7.app.AppCompatActivity;  import android.os.Bundle;      public class MainActivity extends AppCompatActivity {      @Override      protected void onCreate(Bundle savedInstanceState) {          super.onCreate(savedInstanceState);          setContentView(R.layout.activity_main);      }  }                activity_main.xml：MainActivity.java对应的布局文件      &lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"      xmlns:tools=\"http://schemas.android.com/tools\"      android:layout_width=\"match_parent\"      android:layout_height=\"match_parent\"      tools:context=\".MainActivity\"&gt;          &lt;TextView          android:layout_width=\"wrap_content\"          android:layout_height=\"wrap_content\"          android:text=\"@string/hello_world\" /&gt;      &lt;/LinearLayout&gt;                AndroidManifest.xml：Android项目的主配置文件，可配置应用所用的Activity、Service、Broadcast和ContentProvider，以及声明权限      &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;  &lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"      package=\"jay.com.example.firstapp\" &gt;          &lt;application          android:allowBackup=\"true\"          android:icon=\"@mipmap/ic_launcher\"          android:label=\"@string/app_name\"          android:theme=\"@style/AppTheme\" &gt;          &lt;activity              android:name=\".MainActivity\"              android:label=\"@string/app_name\" &gt;              &lt;intent-filter&gt;                  &lt;action android:name=\"android.intent.action.MAIN\" /&gt;                      &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt;              &lt;/intent-filter&gt;          &lt;/activity&gt;      &lt;/application&gt;      &lt;/manifest&gt;          "
  },
  
  {
    "title": "TypeScript基础",
    "url": "/posts/typescript%E5%9F%BA%E7%A1%80/",
    "categories": "前端",
    "tags": "TypeScript, 前端",
    "date": "2024-04-14 23:18:00 +0800",
    





    
    "snippet": "开始TypeScript是JavaScript的超集，扩展了JavaScript的语法，在JavaScript的基础上增加了编译期的类型检查全局安装TypeScript命令：npm i -g typescriptTypeScript需要先编译为JavaScript才能工作，编译命令为tsc xxx.ts类型类型声明TS中声明变量，在变量名后加上类型let a: number = 10;若变量...",
    "content": "开始TypeScript是JavaScript的超集，扩展了JavaScript的语法，在JavaScript的基础上增加了编译期的类型检查全局安装TypeScript命令：npm i -g typescriptTypeScript需要先编译为JavaScript才能工作，编译命令为tsc xxx.ts类型类型声明TS中声明变量，在变量名后加上类型let a: number = 10;若变量在声明时初始化，则进行类型推断，若未初始化且未声明类型，则默认为Any类型// 未初始化且未声明类型，默认类型为Anylet a;a = 10;a = \"Hello\";TS支持字面量类型声明let a: 10;  // a的值只能是10类型声明支持同时声明多个类型（联合类型）let a: number | string;  // a只能是number类型或string类型let b: \"a\" | \"b\";  // 配合字面量类型声明实现枚举函数类型声明  支持参数类型声明  支持返回值类型声明  支持限定参数个数function func(a: number, b: number): number {    return a + b;}基本类型      number        string        boolean        any：任意类型        unknown：类型转换安全的any，在赋值给其他类型时要显式类型检查    let a: unknown;let s: string;if (typeof a === \"string\") {    s = a;}    // 强制类型转换s = a as string;            void：函数无返回值        never：函数永远不会返回，类似kotlin的nothing        object：对象类型    一个对象类型是通过属性名和属性类型确定    let obj: { name: string, age: number }        支持可选属性    let obj: { name: string, age?: number }        动态任意属性    // property为任意属性名，属性声明为any类型let obj: { name: string, [property: string]: any }        不同对象的属性混合    // obj是个既有name属性又有age属性的对象类型let obj: { name: string } &amp; { age: number };            函数类型    使用类似kotlin的语法声明一个函数类型    let f: (a: number, b: number) =&gt; number;    // 函数赋值function fun(a: number, b: number): number {    return a + b;}f = fun;f = (a, b) =&gt; a + b;  // 使用lambda表达式            array    let arr: number[] = [1, 2, 3, 4];let arr1: Array&lt;number&gt; = [1, 2, 3, 4];            tuple：看做固定长度数组    let t: [string, number] = [\"Hello\", 123];            enum：枚举类型    enum Gender {    Male,    Female}      类型别名type MyType = string;type MyType1 = 1 | 2 | 3;tsc编译使用tsc --init命令创建tsconfig.json文件，用于配置tsc编译默认配置如下{  \"compilerOptions\": {    \"target\": \"es2016\",    \"module\": \"commonjs\",    \"esModuleInterop\": true,    \"forceConsistentCasingInFileNames\": true,    \"strict\": true,    \"skipLibCheck\": true  }}根对象配置            配置名      描述                  include: []      选择被编译的文件              exclude: []      选择排除编译的文件      compilerOptions配置            配置名      描述                  target      指定编译的JS版本              module      指定模块化方案              lib:[]      指定项目使用的库，一般不自定义设置              outDir      指定编译输出目录              outFile      将编译结果输出为一个文件              allowJs      是否允许编译js文件              checkJs      是否检查js代码              removeComments      是否去除注释              noEmit      不输出编译文件              noEmitOnError      当编译错误时，不输出编译文件              alwaysStrict      编译结果是否使用严格模式              noImplicitAny      是否不允许隐式any类型              noImplicitThis      是否不允许不明确this              strictNullChecks      是否严格空检查              strict      是否启用所有严格检查      面向对象类与js类相似，基本声明如下class Person {        // 实例字段    name: string;    age: number = 20;        // 静态字段    static count: number = 0;        // 只读字段    readonly hello: number = 10;        // 构造器    constructor(name: string, age: number) {        this.name = name;        this.age = age;    }        // 实例方法    say() {        // ...    }}字段封装      字段支持访问级别设置：public、private、protected        getter与setter方法与js相同    // 可提供getter和settergetName() {    return this.name}setName(name) {    this.name = name}// 简化语法糖，可简化为属性访问形式get name() {    return this.name}set name(name) {    this.name = name}      继承class Animal {    name: string = \"\";        sayHello() {        // ...    }}class Dog extends Animal {    // 字段子类重写    name: string = \"Hello\";        constructor() {        // 父类构造        super();    }        // 方法子类重写    sayHello() {        // ...        super.sayHello();  // 通过super引用父类    }}抽象类abstract class Person {    // 抽象字段    abstract name: string;        // 抽象方法    abstract say(): void;}接口interface MyInterface {    // 接口字段    name: string;        // 接口方法    method(): void;}// 实现接口class Person implements MyInterface {    name: string = \"\";    method(): void {    }}泛型泛型函数泛型函数声明function func&lt;T&gt;(a: T): T {    return a;}限定泛型参数上界function func&lt;T extends A&gt;() {    // ...}泛型类class Person&lt;T&gt; {    name: T;    constructor(name: T) {        this.name = name;    }}"
  },
  
  {
    "title": "JDBC基础",
    "url": "/posts/jdbc/",
    "categories": "Java",
    "tags": "Java, JDBC",
    "date": "2024-04-14 18:40:00 +0800",
    





    
    "snippet": "开始JDBC是java操作数据库的一组APIJDBC只是java操作数据库的接口，具体的实现由数据库厂商实现各自的驱动数据库连接使用数据库首先要与数据库进行连接，JDBC有多种方式可以连接到数据库Driver通过java的Driver抽象类连接，使用具体数据库驱动的driver对象实例化传入url，properties，调用connect返回连接对象url格式：jdbc:mysql://ip...",
    "content": "开始JDBC是java操作数据库的一组APIJDBC只是java操作数据库的接口，具体的实现由数据库厂商实现各自的驱动数据库连接使用数据库首先要与数据库进行连接，JDBC有多种方式可以连接到数据库Driver通过java的Driver抽象类连接，使用具体数据库驱动的driver对象实例化传入url，properties，调用connect返回连接对象url格式：jdbc:mysql://ip:3306/database_nameproperties对象调用setProperties()，传入账号密码的键值对反射连接使用反射将连接过程封装Class&lt;?&gt; cl = Class.forName(\"com.mysql.cj.jdbc.Driver\");Driver driver = (Driver) cl.getDeclaredConstructor().newInstance();DriverManagerDriverManager可以管理多个Driver对象，可以通过DriverManager获取连接DriverManager.registerDriver(driver);Connection connection = DriverManager.getConnection(url, properties);类加载driver对象在类加载时，会自动注册Class.forname(\"com.mysql.cj.jdbc.Driver\"); // 加载类Connection connection = DriverManager.getConnection(url, properties); // 直接获取连接操作数据库jdbc中有三个接口定义了数据库的调用  Statement：执行静态的SQL语句，容易产生SQL注入问题  PreparedStatement：将SQL语句预编译后存储在对象中，可用于多次高效地调用  CallableStatement：用于执行SQL存储过程ORM思想  一张表对应一个Java类  一条记录对应一个Java对象  一个字段对应一个Java对象的属性PreparedStatement调connection.preparedStatement(sql)获取preparedStatement对象传入的sql语句支持动态参数，使用?占位调用preparedStatement.setXXX(index, value)设置动态参数，index从1开始，再调用execute()执行在sql语句中若表名为关键字，则使用``着重符将表名括起来查询结果操作调用executeQuery()返回一个ResultSet对象处理结果集  resultSet.next()：判断下一条是否有数据  resultSet.getXXX(index)：获取字段  resultSet.getMetaData()：返回结果集的元数据，可以获取列数、列名对于一个任意字段数量的对象的查询public static Book queryBook(String sql, Object... args) {    Book book = null;    try {        // 设置查询        PreparedStatement statement = connection.prepareStatement(sql);        for (int i = 0; i &lt; args.length; i++) {            statement.setObject(i + 1, args[i]);        }        // 查询并处理结果集        ResultSet resultSet = statement.executeQuery();        ResultSetMetaData metaData = resultSet.getMetaData();        int col = metaData.getColumnCount();        if (resultSet.next()) {            book = new Book(); // 不知道book的字段            for (int i = 0; i &lt; col; i++) {                Object value = resultSet.getObject(i + 1);                // 数据库列名与book字段名相同                // 若不相同，在查询的SQL语句中使用as给查询的字段取别名                // 在获取列名时，调用getColumnLabel()返回别名                // String label = metaData.getColumnName(i + 1);                String label = metaData.getColumnLabel(i + 1);                Field field = Book.class.getDeclaredField(label);                field.setAccessible(true);                field.set(book, value);            }        }    } catch (SQLException | NoSuchFieldException | IllegalAccessException e) {        throw new RuntimeException(e);    }    return book;}操作BLOB类型字段BLOB类型为二进制长文本数据mysql支持四种容量的BLOB  TinyBlob：255B  Blob：65KB  MediumBlob：16MB  LongBlob：4GBBlob类型的参数需要传入一个InputStream对象，即需要存入的图片的输入流读取Blob类型String type = metaData.getColumnTypeName(i + 1);// 在通用类型中判断Blob类型if (\"BLOB\".equals(type) ||    \"MEDIUMBLOB\".equals(type) ||    \"TINYBLOB\".equals(type)) {\t    // 构造文件名并向对象的filename字段写入文件名    int id = resultSet.getInt(\"id\");    String filename = \"p\" + id + \".jpg\";    Field field = cl.getDeclaredField(\"filename\");    field.setAccessible(true);    field.set(t, filename);    // 读取文件，下载到本地    Blob value = resultSet.getBlob(i + 1);    InputStream inputStream = value.getBinaryStream();    // 使用Lombok注解@Cleanup    try (FileOutputStream outputStream = new FileOutputStream(filename)) {        byte[] buffer = new byte[1024];        int len;        while ((len = inputStream.read(buffer)) != -1) {            outputStream.write(buffer, 0, len);        }    }}批量插入mysql默认不支持批处理，需要在URL中传入参数开启批处理jdbc:mysql://localhost:3306/db?rewriteBatchedStatements=true批处理相当于构造多条语句并执行操作流程  在构造完一条语句后(设置完动态参数后)，调用preparedStatement.addBatch()将该语句存入一批中  调用preparedStatement.executeBatch()执行当前批  调用preparedStatement.clearBatch()清空当前批  在循环中可以控制批数  在数据库层面可以关闭自动提交，构成一层缓存，调用connection.setAutoCommit(false)  在语句全部执行完后，调用connection.commit()提交到数据库事务基本概念事务是数据库的一组操作，具有ACID属性  原子性：事务要么全部操作成功，要么全部失败  一致性：事务提交前后，数据库的状态必须保持一致  隔离性：多个事务并发时，事务操作之间互不干扰  持久性：一旦事务提交，事务造成的数据库变化是持久的数据库自动提交  DDL：对表结构的增删改，一定会提交  DML：对记录的增删改，默认自动提交，可设置autocommit = false取消自动提交  默认在关闭连接时自动提交设置事务  取消自动提交，connection.setAutoCommit(false);  在捕获异常中调用connection.rollback();回滚  在所有操作执行成功后调用connection.commit();提交  在操作结束后，若连接没有关闭则应该重新设置自动提交connection.setAutoCommit(true);基本流程connection.setAutoCommit(false);try {    executeStatements;    connection.commit();} catch (Exception e) {    connection.rollback();}数据库并发设两个事务T1，T2  脏读：T1读取了T2已经更新但未提交的数据，此时T2回滚，T1读取的数据无效(脏数据)  不可重复读：T1读取了一个字段，此时T2更新了该字段，T1再读取该字段，前后读取数据不一致  幻读：T1读取一个表，此时T2向该表插入了记录，T1再读取该表，结果多了几条记录隔离级别  READ UNCOMMITTED：允许读取未被其他事物提交的变更，安全性最低  READ COMMITTED：只允许事物读取其他事物已经提交的变更  REPEATABLE READ：在事务执行期间，禁止其他事务对当前事务读取的字段进行更新  SERIALIZABLE：类似同步，性能最低相关API  调用connection.getTransactionIsolation()获取隔离级别  调用connection.setTransactionIsolation()设置隔离级别DAODAO是Data Access Object，数据库操作对象，里面封装了操作数据库的方法DAO操作规范  定义抽象父类BaseDAO，实现一个通用的DAO对象  对于具体的表，定义相应的DAO接口，指明需要实现的方法  实现相应的DAO接口并继承BaseDAO，将对象转换到SQL并调用BaseDAO  中间的实现类DAO层将对象与SQL语句隔离开，调用方只考虑操作对象，BaseDAO只考虑操作SQL数据库连接池为所有数据库连接建立一个缓冲池，需要建立连接时，从连接池中取出连接使用，允许程序重复使用连接，降低建立连接开销Druid连接池配置文件jdbc.propertiesurl=jdbc:mysql://localhost:3306/maxdb?rewriteBatchedStatements=true&amp;useUnicode=true&amp;characterEncoding=utf8username=rootpassword=020411driverClassName=com.mysql.cj.jdbc.DriverinitialSize=5在JDBCUtils中创建连接池private static DataSource source;static {    Properties properties = new Properties();    try {        @Cleanup        InputStream is = ClassLoader.getSystemClassLoader().getResourceAsStream(\"jdbc.properties\");        properties.load(is);        source = DruidDataSourceFactory.createDataSource(properties);    } catch (Exception e) {        e.printStackTrace();    }}Connection connection = source.getConnection();Apache-DBUtilsApache封装的数据库操作库###QueryRunnerQueryRunner中一共有6种方法  execute（执行SQL语句）  batch（批量处理语句）  insert（执行INSERT语句）  insertBatch（批量处理INSERT语句）  query（SQL中SELECT语句）  update（SQL中INSERT,UPDATE或DELETE语句）ResultSetHandlerResultSetHandler是处理查询结果的处理器  BeanHandler：将一条结果封装为对象，若查询结果有多条，则返回第一条记录的对象  BeanListHandler：将多条结果封装为对象列表  ArrayHandler：将一条结果的字段作为数组元素，一条结果作为一个数组返回  ArrayListHandler：将多条结果封装为数组列表  MapHandler：将一条结果的标签作为key，字段值作为value，返回一条结果的构成的map  MapListHandler：返回多条结果的map列表  ScalerHandler：用于封装特殊值，如count，max关闭资源DBUtils.close(connection);// 等效于if (connection != null) {    connection.close();}DBUtils.closeQuietly(connection);// 等效于try {    DBUtils.close(connection);} catch(SQLException e) {    // quiet}"
  },
  
  {
    "title": "Jetpack Compose基础",
    "url": "/posts/jetpack-compose/",
    "categories": "Android",
    "tags": "Android, Jetpack Compose",
    "date": "2024-04-14 15:12:00 +0800",
    





    
    "snippet": "开始Compose设计原则      一切组件都是函数    Compose组件通过可组合函数表示，使用Composable注解标识函数        组合优于继承    所有组件之间没有继承关系，Composable函数可以任意嵌套，而不会损失性能        单一数据源    所有组件只能通过一个参数来改变状态，当组件的状态需要改变时，只能通过该参数来改变    视图树一旦生成不可改变...",
    "content": "开始Compose设计原则      一切组件都是函数    Compose组件通过可组合函数表示，使用Composable注解标识函数        组合优于继承    所有组件之间没有继承关系，Composable函数可以任意嵌套，而不会损失性能        单一数据源    所有组件只能通过一个参数来改变状态，当组件的状态需要改变时，只能通过该参数来改变    视图树一旦生成不可改变，当视图树中的参数改变时，整个视图树基于新数据刷新，称为重组    单一数据源决定了数据流的的单向流动，数据总是自上而下流动，事件总是自下而上传递      Compose与View的关系：Compose树中的视图节点是LayoutNode，Compose树可以通过一个挂载点挂载到View树中，挂载点通过AbstractComposeView实现，AbstractComposeView有三个子类，分别用于适配Activity、Dialog和PopupWindow，它的子节点AndroidComposeView持有Compose树，同时它也是一个ViewGroup，实现了Compose树和View树的连接UI组件Compose提供了基本UI组件以及Row、Column、Box三种布局，父组件默认适应子组件大小Modifier基本Modifier每个组件都有一个modifier参数，可以传入一个Modifier对象，Modifier对象可以设置组件的基本样式，如边距、大小、背景等      size：设置组件大小，可分别设置width和height参数，也可调用width和height函数分别设置        background：设置组件背景颜色、形状，通过Color对象设置纯色，通过Brush对象设置渐变色        fillMaxSize：使组件充满父组件          fillMaxWidth      fillMaxHeight            border：设置组件边框，可设置粗细、颜色等        padding：设置组件的边距，在Compose中没有margin，与background共同作用来实现内边距，在background之前调用padding表示外边距        offset：设置组件的偏移量，需要注意该函数的调用顺序  Modifier中包含了许多关于手势的修饰符  clickable：使组件变为可点击，也可通过状态控制enable参数  CombinedClickable：复合点击，可设置单击、长按、双击等  Draggable：拖动，可对水平和垂直方向的拖动偏移进行监听  Swipeable：滑动，需要设置锚点，可对水平和垂直方向的拖动偏移进行监听  Scrollable：滚动，支持水平和垂直滚动，需要scrollState参数，使用rememberScrollState创建  NestedScroll：嵌套滚动，需要NestedScrollConnection参数，其中包含父组件使用子组件的滚动事件回调作用域Modifier使用作用域Modifier可以使得modifier函数被安全调用，减少不必要的调用Compose中的作用域不允许跨层调用，若需要跨层调用，需要显示指明Receiver  BoxScope          matchParentSize：使内部组件与Box大小相同        RowScope、ColumnScope          weight：通过百分比设置内部组件大小      Modifier原理Modifier是一个接口，每个修饰符函数实现了Modifier.Element接口，Modifier包含一个伴生对象，在起始位置通过Modifier伴生对象调用第一个修饰符函数后，会创建相应修饰符的Modifier实例对象，修饰符函数之间通过then函数连接，Modifier对象在其中传递then函数返回一个CombinedModifierclass CombinedModifier(    private val outer: Modifier,    private val inner: Modifier) : Modifierouter指向当前修饰符的前一个Modifier对象，inner指向当前修饰符的Modifier对象Compose在绘制UI时，会遍历Modifier链，使用foldIn和foldOut函数进行遍历foldIn进行正向遍历，foldOut进行反向遍历fun &lt;R&gt; foldIn(initial: R, operation: (R, Element) -&gt; R): Rfun &lt;R&gt; foldOut(initial: R, operation: (Element, R) -&gt; R): R  Modifier的详细介绍参考：图解 Modifier基本UI组件文本组件      Text：基于Material Design规范设计，使用BasicText则脱离Material Design规范              关于资源：Compose提供了获取不同类型资源的函数              stringResource：获取文本资源        colorResource：获取颜色资源        integerResource：通过资源id获取        painterResource：获取Drawable资源                  TextStyle：文字样式，使用TextStyle构造器构造，传入相应样式属性    若重复设置Text与TextStyle，则Text属性会覆盖TextStyle属性        AnnotatedString：多样式文字    使用buildAnnotatedString函数构造AnnotatedString    其中可调用withStyle函数传入一个SpanStyle对象或ParagraphStyle对象和子串DSL，SpanStyle表示子串的样式，ParagraphStyle表示段落样式，子串DSL中调用append添加子串文本        SelectionContainer：使组件可被选中        TextField：输入框，BasicTextField不使用Material Design规范    BasicTextField比TextField多一个decorationBox属性，通过该属性可设置更多样式    两种风格：filled(无边框填充)，Outlined(有边框无填充)      图像组件      Icon：图标组件，支持矢量图对象、位图对象和Canvas画笔对象，矢量图通过ImageVector加载，位图通过ImageBitmap加载    Icons包预置了一些图标，它们拥有5种风格：Outlined、Filled、Rounded、Sharp、Two Tone    更多图标implementation(\"androidx.compose.material:material-icons-extended:$compose_version\")        Image：图像组件，contentScale参数指定图片的伸缩样式，类似ScaleType  点击组件      Button：按钮，Button只是响应点击的容器，content参数传入ComposableDSL，使用其他组件填充内容，作用域为RowScope    interactionSource参数传入一个MutableInteractionSource状态          collectPressedAsState：判断是否是按下状态      collectFocusedAsState：判断是否获取焦点      collectDraggedAsState：判断是否拖动        调用以上函数可获取对应的状态对象，其value属性为判断的boolean值    其他组件可通过调用Modifier.clickable变为可点击组件，响应事件        IconButton：一个图标按钮，内部需要提供Icon组件        FloatingActionButton：悬浮按钮，内部提供Icon组件        ExtendedFloatingActionButton：可带文字的悬浮按钮  选择组件  CheckBox：复选框  TriStateCheckBox：三态选择框  Switch：单选框  Slider：滑竿组件对话框  Dialog：传入三个属性，onDismissRequest(关闭回调)、DialogProperties(设置其他特殊属性)、content(CompossableDSL)，对话框的显示和隐藏通过设置状态实现，当状态为true则渲染Dialog  AlertDialog：基于Dialog封装，添加了title、text、confirmButton、dismissButton布局组件基本布局Compose只有三种布局，Row、Column、Box对齐：verticalArrangement、horizontalAlignment，只有在设置了Column的大小时才能使用对齐子组件对齐：布局内的组件可以通过Modifier.align设置自己的对齐，Column中只能设置子组件水平对齐，Row中只能设置子组件垂直对齐  Column：垂直线性布局  Row：水平线性布局帧布局  Box：子组件可堆叠，类似FrameLayout  Surface：一个组件容器，可设置边框、圆角、颜色等，当需要设置布局总体样式时，可使用Surface  Spacer：空白，在布局中占位  ConstraintLayoutScaffold脚手架Scaffold组件实现了一个基于Material Design的基本UI布局包含多个特定位置参数和content，设置组件，组件自动位于相应的位置，content为ComposableDSL  topBar  bottomBar  drawerContentScaffold拥有一个状态，包含了特定位置组件的相关状态，如侧边栏是否打开等，通过rememberScaffoldState()获取变量，设置到Scaffold的scaffoldState参数  BackHandler：监听返回键组件，设置enable参数和onBack回调列表调用Modifier.horizontalScroll()或Modifier.verticalScroll()可以实现滚动，但对于长列表，不需要将全部数据加载到内存中，可以使用LazyRow或LazyColumn组件实现列表LazyComposables内是LazyListScope作用域，调用item或items函数创建一个子项，这两个函数需要传入子项的ComposableDSLitems还可接收List参数，调用itemsIndexed可同时获取索引  contentPadding：设置子项内容外边距  verticalArrangement=Arrangement.spacedBy：设置子项布局外边距主题基本主题项目的ui/theme目录下存放项目主题配置  Color.kt：颜色配置  Shape.kt：形状配置  Theme.kt：主题配置  Type.kt：字体配置Material Design颜色字段CompositionLocalCompositionLocal用于在视图树中共享数据，CompositionLocal可被定义在任何一棵子树中，数据在该子树中共享，若子树的子树重新定义CompositionLocal，则会覆盖原定义创建CompositionLocal      compositionLocalOf    若提供给CompositionLocal的值是一个状态，当状态发生变化时，CompositionLocal子树中读取了CompositionLocal.current值的Composable层级会发生重组        staticCompositionLocalOf    若提供给CompositionLocal的值是一个状态，当状态发生变化时，整个CompositionLocal子树发生重组  CompositionLocalProvider方法可以为compositionLocal提供一个值，该值在当前子树内覆盖compositionLocal的原值val localString = staticCompositionLocalOf { \"Hello in level1\" }Column {    Text(localString.current)  // Hello in level1    CompositionLocalProvider(    \tlocalString provides \"Hello in level2\"    ) {        Text(localString.current)  // Hello in level2    }}状态管理Compose通过重组来进行UI刷新  Stateless：一个Composable中不包含自己的状态，所有状态通过函数参数传递  Stateful：一个Composable中包含自己的状态，也包含函数参数传递的状态状态定义  State：不可变状态  MutableState：可变状态创建MutableStateval state: MutableState&lt;Int&gt; = mutableStateOf(0)  // 调用value属性进行读写val (state, setter) = mutableStateOf(0)  // state为属性值，调用setter设置属性值val state by mutableStateOf(0)  // 属性代理状态缓存：使用remember { state }，在Composable中记录状态状态提升将Stateful改造为Stateless，将Composable内部数据通过函数参数传入，将响应事件也作为函数对象参数传入状态提升的作用域最好提升到使用的Composable的最小共同父Composable状态持久化remember无法实现在Activity等重建或跨进程中缓存状态，需要使用rememberSavable，rememberSavable仅支持Bundle中的数据类型，对于类，需要添加@Parcelize注解，实现Parcelable接口  使用@Parcelize注解需要添加gradle插件kotlin-parcelize，@Parcelize自动添加了一套Parcelable接口的实现对于需要自定义序列化时，可定义Saver实现序列化和反序列化，在调用rememberSavable时传入自定义Saver自定义Saver实现Saver接口object PersonSaver : Saver&lt;Person, Bundle&gt; {    override fun restore(value: Bundle): Person? {        // ...    }    override fun SaverScope.save(value: Person): Bundle? {        // ...    }}Compose提供了MapSaver和ListSaver  MapSaver：将对象转换为Map&lt;String, Any&gt;  ListSaver：将对象转换为List&lt;Any&gt;  若只需要状态可以在因配置改变导致Activity等重建时保存，只需要在AndroidManifest.xml中设置android:configChanges，使用remember即可状态管理有三种方式可以管理状态Stateful使用一个Stateful Composable统一存储Stateless的状态，适用于简单的UI逻辑StateHolder定义一个StateHolder类统一管理Stateless状态，定义相应的remember函数，在Composable中通过remember函数获取StateHolder，适用于复杂的UI逻辑ViewModel将Stateless的状态放到ViewModel中进行管理，在Composable中可直接调用viewModel()获取，该函数从最近的ViewModelStore中获取ViewModel实例ViewModel方式可以支持Hilt依赖注入，适用于长期的业务逻辑  viewModel函数需要添加依赖  androidx.lifecycle:lifecycle-viewmodel-compose:$lifecycle_version状态分层策略状态重组      只有状态发生更新的Composable才发生重组        Composable会以任意顺序执行    根据各个组件的渲染顺序执行而不是代码的顺序        Composable是并发执行的    Composable之间使用同一个变量时，会产生线程安全问题        Composable的执行是不可预期的    除了重组造成Composable的执行外，动画中每一帧的变化也会引起Composable的执行，因此Composable的执行次数是不可预期的，应该避免在Composable中执行耗时操作或数据操作        Composable的执行是乐观的    Composable总是使用最新的状态完成重组，可能会丢弃中间状态  重组原理      经过Compose编译器处理后的Composable代码在对State进行读取的同时，能够自动建立关联，在运行过程中当State变化时，Compose会找到关联的代码块标记为Invalid        在下一渲染帧到来之前，Compose会触发重组并执行invalid代码块，Invalid代码块即下一次重组的范围，能够被标记为Invalid的代码必须是非inline且无返回值的Composable函数或lambda                  inline函数会在调用处展开，会与调用方共享重组范围        Column是inline的高阶函数，因此Column内部组件会在Column中展开，Column内部组件重组时，Column也处于重组范围内，也会发生重组        若是其他非inline的Composable函数，内部组件重组时，外部不处于重组范围内                    由于返回值的变化会影响调用方，所以必须连同调用方一同参与重组，因此Composable函数不应该有返回值            列表重组Compose视图树中每个节点(LayoutNode)都具有一个索引，当发生重组时，根据索引在SlotTable中查找，若节点不存在则创建节点，节点存在则更新等节点的比较依赖于编译期建立的索引，在运行时进行比较会发生错误，编译期索引由代码编写的位置决定对于列表数据，其数据项在运行时确定，无法在编译时确定数据项，因此需要为每个数据项手动建立索引若不手动建立索引，当在list[0]添加数据时，新数据会与[0]上的原数据进行比较，从而导致整个列表进行节点更新，手动建立索引后，重组时只会对新数据创建节点Column {    for (e in list) {        key(e.id) {            MovieItem(e)        }    }}Composition生命周期Compose视图树称为Composition生命周期  onActive：Composable首次执行，创建Composition  onUpdate：Composable由于重组不断执行，更新Composition节点  onDispose：Composable不再执行，Composition节点销毁Composable副作用Composable中影响外界的操作称为副作用，Compose提供了一系列副作用API，保证这些操作在特定的阶段执行      DisposableEffect：可以感知Composable的onActive和onDispose    DisposableEffect(key) {    // 当key改变(onUpdate)或onActive时执行这部分代码    // 当key为常量时，只在onActive执行一次    onDispose {        // 当Composable进入onDispose时执行    }}            SideEffect：在每次重组成功时执行        LaunchedEffect：在副作用中执行异步操作    当Composable进行onActive时，LaunchedEffect中开启一个协程，同时也可以为该副作用指定key，当key改变时，原协程结束，新协程开启，Composable进入onDiapose时，协程自动结束    rememberCoroutineScope：获取一个与Composable同生命周期的协程作用域        rememberUpdatedState    每次状态改变会发生重组，导致副作用也进行重组，如LaunchedEffect会开启一个新协程    若副作用的重组开销大，则应该使副作用在多次重组之间持续存在，当副作用内部引用了Composable中保存的状态时(状态使用remember保存)，状态改变只会使得Composable重组，但同时副作用内部无法获取状态的最新值，即无法使副作用内部响应    此时应该使用rememberUpdatedState来保存状态，当状态改变时，Composable重组，同时通知副作用内部        snapshotFlow：在副作用内部使用FLow处理State，同时使持续存在的副作用内部可以实时感知State的变化    Best Practice：当副作用依赖的状态频繁变化时，应该使用状态对象本身作为副作用的Key，而在副作用内部使用snapshotFlow感知状态值的变化"
  },
  
  {
    "title": "WPF基础——XAML语言",
    "url": "/posts/wpf-xaml%E8%AF%AD%E8%A8%80/",
    "categories": "C#, WPF",
    "tags": "C#, WPF",
    "date": "2024-04-13 21:53:00 +0800",
    





    
    "snippet": "开始xaml用于编写WPF的UI，其中每一个元素都是一个类的实例对象，标签内的属性赋值就是对该对象的属性进行赋值xaml支持多种形式的属性设置，主要有以下三种方式      键值对赋值    &lt;Button Content=\"Hello\"/&gt;            属性标签：每个标签看做一个对象，可嵌套它的属性标签设置属性，适用于复杂对象属性赋值    &lt;Button&gt...",
    "content": "开始xaml用于编写WPF的UI，其中每一个元素都是一个类的实例对象，标签内的属性赋值就是对该对象的属性进行赋值xaml支持多种形式的属性设置，主要有以下三种方式      键值对赋值    &lt;Button Content=\"Hello\"/&gt;            属性标签：每个标签看做一个对象，可嵌套它的属性标签设置属性，适用于复杂对象属性赋值    &lt;Button&gt;    &lt;Button.Content&gt;        &lt;TextBlock Text=\"Hello\"/&gt;    &lt;/Button.Content&gt;&lt;/Button&gt;            标签扩展：在attr=value形式上，使用{}包裹value部分，在其中构造中介对象，通过中介对象赋予属性值，类名后跟的键值对是对中介对象的属性赋值，只有MarkupExtension类的子类才支持标签扩展    &lt;!--在{}中构造对象，如构造Binding对象使用绑定，构造StaticResource使用静态资源等--&gt;&lt;TextBlock Text=\"{Binding ElementName=obj, Path=Value, Mode=OneWay}\"/&gt;        实际上，使用标签扩展是调用了类的构造器，因此可不指定属性名，按顺序赋值    &lt;!--将Path赋值为Value--&gt;&lt;TextBlock Text=\"{Binding Value}\"/&gt;      X命名空间X命名空间中包含解析xaml文件的内容，通常使用其中的元素和属性来标记xaml标签      x:Class：指定编译生成的界面类合并到哪个后台类，只能用于根标签        x:ClassModifier：指定xaml界面类的访问级别，应与后台类的访问级别相同        x:Name    xaml中每个元素都是一个实例对象，x:Name为xaml元素实例生成引用（类似创建id），若元素自带Name属性，则同时将x:Name赋值给Name属性    若元素有Name属性，则设置Name属性也能引用到元素实例，但有些元素没有Name属性，此时只能使用x:Name，为了统一，推荐仅使用x:Name引用元素        x:FieldModifier：设置元素实例的访问级别，作为元素的属性使用        x:Key：用于标识资源字典中的资源，在C#中使用FindResource方法获取        x:Shared：与x:Key配合使用，值为true时，获取到的资源是同一个对象，否则是该资源的副本        x:Type：标签扩展，用于访问Type类型对象，传入TypeName属性        x:Null：标签扩展，用于将对象的某个属性设为null        x:Array：标签扩展，可以构造一个数组，Type属性指定数组元素的类型        x:Static：标签扩展，用于访问类的静态成员，传入类的静态成员  事件处理器标签对象中有些属性接收一个处理函数，这种函数称为事件处理器，实现一个事件处理主要定义三个要素  指定事件  实现事件处理器  建立订阅以Button点击为例      指定事件    &lt;!--在x命名空间的Name属性指定控件的id，准备为MyButton的Click事件赋值--&gt;&lt;Button x:Name=\"MyButton\" Click=\"\"/&gt;            实现事件处理器    namespace App {    public partial class MainWindow : Window {        // ...                    // 实现事件处理器        private void MyButton_Click(object sender, RoutedEventArgs e) {            // statements;        }    }}            建立订阅：有两种方式，通过xaml设置或者通过C#代码设置                  通过xaml设置        &lt;Button x:Name=\"MyButton\" Click=\"MyButton_Click\"/&gt;                            通过C#代码设置        // Click是一个委托，将Click的功能委托到MyButton_Clickthis.MyButton.Click += new RoutedEventHandler(MyButton_Click);                    引用类库将类库引入到xaml的语法如下xmlns:{自定义名称}=\"clr-namespace:{类库命名空间}\";assembly={类库文件名}\"使用命名空间中的类&lt;自定义名称:类&gt;&lt;自定义名称:类/&gt;"
  },
  
  {
    "title": "WPF基础——Binding",
    "url": "/posts/wpf-Binding/",
    "categories": "C#, WPF",
    "tags": "C#, WPF",
    "date": "2024-04-13 21:53:00 +0800",
    





    
    "snippet": "开始Binding对象是实现数据和界面双向绑定的基础在数据部分，数据源需要实现INotifyPropertyChanged接口，其中包含一个PropertyChangedEventHandler类型的PropertyChanged属性，该属性是一个事件，当数据源内的属性变化时，需要调用PropertyChanged来触发属性变化事件，从而能够通知到UI改变数据数据源的基本实现如下public...",
    "content": "开始Binding对象是实现数据和界面双向绑定的基础在数据部分，数据源需要实现INotifyPropertyChanged接口，其中包含一个PropertyChangedEventHandler类型的PropertyChanged属性，该属性是一个事件，当数据源内的属性变化时，需要调用PropertyChanged来触发属性变化事件，从而能够通知到UI改变数据数据源的基本实现如下public class Student : INotifyPropertyChanged {    public event PropertyChangedEventHandler? PropertyChanged;    private string name = \"\";    public string Name {        get =&gt; name;        set {            name = value;            // 当Name被修改时，触发事件            // 注意这里传入Name属性而不是name字段，因为外部通过Name属性来访问name字段            PropertyChanged?.Invoke(this, new(\"Name\"));        }    }}编写一个简单布局，在后台类中通过C#代码的方式将Student类的Name属性绑定到文本框中（也可使用标签扩展），xaml布局如下&lt;StackPanel     Orientation=\"Vertical\"    VerticalAlignment=\"Center\"&gt;    &lt;TextBlock    \tWidth=\"250\"        Height=\"50\"        Margin=\"30, 0\"        x:Name=\"MyText\"/&gt;    &lt;Button        Width=\"250\"        Height=\"50\"        Margin=\"30, 0\"        x:Name=\"Button\"        Content=\"Click Me\"/&gt;&lt;/StackPanel&gt;后台类如下public partial class MainWindow : Window {    public MainWindow() {        InitializeComponent();        var student = new Student();        // 数据源就是Student对象，路径Path就是属性的访问器，即Name属性        var binding = new Binding() {            Source = student,            Path = new PropertyPath(\"Name\")        };        // 将Student的Name属性绑定到TextBlock的Text属性上        BindingOperations.SetBinding(MyText, TextBlock.TextProperty, binding);        // 基于FrameworkElement的元素也就是基本元素对SetBinding进行了封装，也拥有SetBinding方法        // MyText.SetBinding(TextBlock.TextProperty, binding);        // 设置Click事件        Button.Click += (_, _) =&gt; student.Name = \"Hello\";    }}  上述Binding对象的Source属性可以接收任何对象，若对象没有实现INotifyPropertyChanged接口，则无法向Binding通知自身的状态变化，INotifyPropertyChanged提供了对象向Binding通知自身变化的能力Binding属性Binding对象的常用属性如下            属性名      描述                  AsyncState      获取或设置传递给异步数据调度程序的不透明数据。              BindingGroupName      获取或设置此绑定所属的BindingGroup的名称              Converter      获取或设置要使用的转换器              ConverterParameter      获取或设置要传递给Converter的参数              Delay      获取或设置更新位于目标更改上的值之后的绑定源前要等待的时间（毫秒）              ElementName      获取或设置要用作绑定源对象的控件元素的名称              FallbackValue      获取或设置当绑定无法返回值时要使用的值              IsAsync      获取或设置一个值，该值表示Binding是否应异步获取和设置值              Mode      获取或设置一个值，该值指示绑定的数据流方向              Path      获取或设置绑定源属性的路径              RelativeSource      通过指定绑定源相对于绑定目标位置的位置，获取或设置此绑定源              Source      获取或设置要用作绑定源的对象              StringFormat      获取或设置一个字符串，该字符串指定如果绑定值显示为字符串时如何设置该绑定的格式              TargetNullValue      获取或设置当源的值为 null 时在目标中使用的值      数据流向通过设置Binding对象的Mode属性可以改变Binding数据的流向，Mode属性是BindingMode类型，拥有四个枚举值  OneWay：单向流动  TwoWay：双向流动，默认值  OnTime  OneWayToSource  Default：根据控件的读写属性确定单向或双向Path路径Path属性指定绑定的数据源属性      直接路径：直接指定属性名    &lt;!--通过标签扩展引用其他元素的属性--&gt;&lt;TextBlock Text=\"Hello World\" x:Name=\"MyText\"&gt;&lt;/TextBlock&gt;&lt;TextBlock Text=\"{Binding ElementName=MyText, Path=Text}\"&gt;&lt;/TextBlock&gt;            多级路径：可以获取属性的属性    &lt;!--通过标签扩展引用其他元素的属性--&gt;&lt;TextBlock Text=\"Hello World\" x:Name=\"MyText\"&gt;&lt;/TextBlock&gt;&lt;!--Path指向Text的Length属性--&gt;&lt;TextBlock Text=\"{Binding ElementName=MyText, Path=Text.Length}\"&gt;&lt;/TextBlock&gt;&lt;!--使用Text的索引器，点.可以省略--&gt;&lt;TextBlock Text=\"{Binding ElementName=MyText, Path=Text.[0]}\"&gt;&lt;/TextBlock&gt;            默认路径：当绑定的数据源自身就是数据值时，使用默认路径    当数据源是一个集合时，使用/表示第一个元素的默认路径    &lt;Window.Resources&gt;    &lt;sys:String x:Key=\"MyValue\"&gt;Hello&lt;/sys:String&gt;&lt;/Window.Resources&gt;&lt;TextBlock Text=\"{Binding ., Source={StaticResource MyValue}}\"/&gt;&lt;!--等价于--&gt;&lt;TextBlock Text=\"{Binding Path=., Source={StaticResource ResourceKey=MyValue}}\"/&gt;      数据源Binding指定数据源主要通过Source属性，下面介绍通过不同的途径设置Binding数据源CLR属性和依赖属性CLR属性就是普通对象的普通属性，与依赖对象的依赖属性区分依赖对象继承了DependencyObject类，依赖属性为DependencyProterty类型，命名后缀通常是Property，在xaml中引用时会省略该后缀。依赖属性是依赖其他属性的属性，如控件的可绑定属性，通常作为Binding的目标同时依赖对象也可作为Binding的源，当作为Binding源时，该依赖对象可能是其他Binding的目标，从而形成依赖链DataContextBinding将DataContext的值作为数据源，Path属性指定数据源中的属性&lt;!--可以省略点.--&gt;&lt;Label Content=\"{Binding Path=.}\"&gt;    &lt;Label.DataContext&gt;        Hello    &lt;/Label.DataContext&gt;&lt;/Label&gt;DataContext是FrameworkElement的属性，是object类型，每个控件都拥有自己的DataContext，DataContext是一个依赖属性，当控件的DataContext没有显式赋值时，会依赖父控件的DataContext，因此当Binding指定路径时，可以自动获取到父控件或祖先控件的DataContext中的属性 &lt;StackPanel&gt;    &lt;StackPanel.DataContext&gt;        &lt;sys:Int32&gt;32&lt;/sys:Int32&gt;    &lt;/StackPanel.DataContext&gt;    &lt;Label Content=\"{Binding Path=.}\"&gt;&lt;/Label&gt;&lt;/StackPanel&gt;集合类型ItemsControl控件拥有ItemsSource属性，接收一个实现IEnumerable接口的对象作为数据源DataTemplate类定义了单个子项数据通过哪些控件展示，DataTemplateSelector类的子类重写了SelectTemplate方法，实现了子项数据与控件的绑定（创建Binding对象），再使用DataTemplate将添加Binding的控件对象包装起来返回public virtual DataTemplate SelectTemplate(object item, DependencyObject container) {    // ...}默认的DataTemplateSelector是DisplayMemberTemplateSelector，它的DisplayMemberPath属性指定了数据源成员的路径，简单地将数据源成员通过TextBlock控件展示为一个字符串，其核心代码如下// 初始化DataTemplate和控件对象_clrNodeContentTemplate = new DataTemplate();FrameworkElementFactory text = ContentPresenter.CreateTextBlockFactory();// 创建Binding并设置Binding binding = new Binding();binding.Path = new PropertyPath(_displayMemberPath);binding.StringFormat = _stringFormat;text.SetBinding(TextBlock.TextProperty, binding);// 由DataTemplate包装后返回_clrNodeContentTemplate.VisualTree = text;_clrNodeContentTemplate.Seal();在xaml中可以给ItemsControl自定义DataTemplate，赋值给ItemTemplate属性&lt;ListBox\tx:Name=\"StudentList\"\tHeight=\"Auto\"&gt;\t&lt;ListBox.ItemTemplate&gt;\t\t&lt;DataTemplate&gt;\t\t\t&lt;Label Content=\"{Binding Path=Name}\"/&gt;\t\t&lt;/DataTemplate&gt;\t&lt;/ListBox.ItemTemplate&gt;&lt;/ListBox&gt;&lt;!--在C#中指定ItemsSource--&gt;&lt;!--StudentList.ItemsSource = list;--&gt;ElementNameElementName设置为其他控件的x:Name，将被引用的控件对象作为Binding源&lt;TextBlock Text=\"Hello\" x:Name=\"Hello\"/&gt;&lt;Label Content=\"{Binding ElementName=Hello, Path=Text}\"&gt;&lt;/Label&gt;RelativeResource相对于当前元素，查找其他元素的属性构造RelativeSource对象赋值给Binding的RelativeSource属性，将RelativeSource查找的元素作为源  Mode：查找模式，FindAncestor查找祖先，Self查找自身  AncestorLevel：确定祖先相对层级  AncestorType：确定祖先控件类型，通过x:Type获取Type类型&lt;StackPanel     Orientation=\"Vertical\"    VerticalAlignment=\"Center\"    Background=\"Red\"&gt;    &lt;TextBlock        Text=\"{            Binding                 RelativeSource={                RelativeSource                 Mode=FindAncestor,                    AncestorLevel=1,                     AncestorType={x:Type StackPanel}                },             Path=Background        }\"/&gt;&lt;/StackPanel&gt;其他数据源      ADO.NET类型对象    DataTable、DataView等        XML数据    通过XmlDataProvider将xml中的数据传递给集合控件数据源属性        ObjectDataProvider    当数据通过方法获取时，使用ObjectDataProvider包装数据源，再赋给Source  数据校验基本使用Binding对象包含一个ValidationRules属性，类型为Collection&lt;ValidationRule&gt;，表示可以对一个Binding设置多个校验条件ValidationRule是一个抽象类，包含一个Validate抽象方法，返回ValidationResult对象public class RangeValidation : ValidationRule {    public override ValidationResult Validate(object? value, CultureInfo cultureInfo) {        var num = (int)(value ?? throw new ArgumentNullException(nameof(value)));        if (num &gt; 0) {            // 第二个参数为错误信息            return new ValidationResult(true, null);        } else {            return new ValidationResult(false, \"num &lt; 10\");        }    }}// 添加到ValidationRules中binding.ValidationRules.Add(new RangeValidation());  Binding校验默认只校验通过外部方法改变Target导致Source改变，不会校验Source改变导致Target改变，设置ValidatesOnTargetUpdated属性为true，校验Source导致的改变校验错误事件若需要Binding在校验错误时发出一个事件，需要设置NotifyOnValidationError属性为true校验错误事件会沿着元素树传播，当遇到一个元素设置了校验错误事件处理器，则该元素处理该事件，处理后可继续传播，也可立即停止// 定义事件处理器void ValidateError(object sender, RoutedEventArgs e) {    // 判断是否有校验错误    if (Validation.GetHasError(MyText)) {        // 获取校验错误信息        var message = Validation.GetErrors(MyText)[0].ErrorContent.ToString();     }}// 设置事件处理器MyTextBlock.AddHandler(Validation.ErrorEvent, new RoutedEventHandler(ValidateError));数据转换数据转换通过IValueConverter实现类实现public class MyConverter : IValueConverter {    public object Convert(object? value,                           Type targetType,                           object? parameter,                           CultureInfo culture) {        // Source转换为Target    }    public object ConvertBack(object? value,                               Type targetType,                               object? parameter,                               CultureInfo culture) {        // Target转换为Source    }}MultiBindingMultiBinding组合多个Binding的Source，绑定到一个TargetMultiBinding支持Binding的基本属性，如StringFormat、Mode、Converter等组合字符串的基本使用，xaml标签扩展&lt;TextBlock x:Name=\"MyText\"&gt;    &lt;TextBlock.Text&gt;        &lt;MultiBinding StringFormat=\"Binding1：{}，Binding2：{}\"&gt;            &lt;Binding /&gt;            &lt;!--other bindings--&gt;        &lt;/MultiBinding&gt;    &lt;/TextBlock.Text&gt;&lt;/TextBlock&gt;多值转换：实现IMultiValueConverter转换多个Sourcepublic class MultiConverter : IMultiValueConverter {    public object Convert(object[] values, Type targetType, object parameter, CultureInfo culture) {        // Sources转换为Target    }    public object[] ConvertBack(object value, Type[] targetTypes, object parameter, CultureInfo culture) {        // Target转换为Sources    }}"
  },
  
  {
    "title": "WPF基础——控件",
    "url": "/posts/wpf-%E6%8E%A7%E4%BB%B6/",
    "categories": "C#, WPF",
    "tags": "C#, WPF",
    "date": "2024-04-13 21:52:00 +0800",
    





    
    "snippet": "开始WPF中的控件主要分为6类控件，分别是布局控件、内容控件、带标题内容控件、集合控件、带标题集合控件、特殊内容控件，这些控件类的继承关系如下  ContentControl：单一内容控件  HeaderedContentControl：带标题单一内容控件  ItemsControl：以集合为内容的控件  HeaderedItemsControl：带标题的以条目集合为内容的控件  Decor...",
    "content": "开始WPF中的控件主要分为6类控件，分别是布局控件、内容控件、带标题内容控件、集合控件、带标题集合控件、特殊内容控件，这些控件类的继承关系如下  ContentControl：单一内容控件  HeaderedContentControl：带标题单一内容控件  ItemsControl：以集合为内容的控件  HeaderedItemsControl：带标题的以条目集合为内容的控件  Decorator：控件装饰元素  Panel：面板类控件  TextBox：文本输入框  TextBlock：静态多行文本  Shape：图形元素每个控件都有一个属性用于引用内部的子控件对象，该属性称为内容属性，有些控件内容属性是Content，有些是Children，有些是Items，控件标签内部区域专门映射了控件的内容属性&lt;Button&gt;    Hello&lt;/Button&gt;&lt;!--相当于--&gt;&lt;Button Content=\"Hello\"&gt;&lt;/Button&gt;控件族ContentControl内容属性是Content，内容只能包含一个子元素，若需要包含多个元素，可以使用一个容器元素包装多个元素放入内容  Button：简单按钮  ButtonBase：所有按钮类控件的父类  CheckBox：复选框  ComboBoxItem：下拉列表项，ComboBox的子项容器  Frame：支持导航的内容控件，可导航到其他xaml窗口  GridViewColumnHeader：GridViewColumn的标题  GroupItem：GroupBox子项容器  Label：简单文本标签  ListBoxItem：ListBox子项容器  ListViewItem：ListView子项容器  NavigationWindow：支持导航的Window，继承自Window  RadioButton：单选框  RepeatButton：在按下时重复触发事件的按钮  ScrollViewer：包含其他元素的可滚动区域  StatusBarItem：StatusBar子项容器  ToggleButton：可切换状态的按钮父类  ToolTip：工具信息提示  UserControl：继承该类自定义控件  Window：窗口区域HeaderedContentControl该族继承自ContentControl，除了Content属性还包含Header属性用于显示标题，Header只能接收一个子元素主要包含以下元素  Expander：带标题的可折叠内容区域  GroupBox：带标题和边框的内容区域  TabItem：TabControl的子项容器ItemsControl内容属性为Items或ItemsSource，每个集合容器都有对应的子项容器，如ListBoxItem、ListViewItem主要包含以下元素  Menu：菜单  MenuBase：菜单父类  ContextMenu：右键上下文菜单  ComboBox：下拉列表  ListBox：可选项列表  ListView：数据项列表，相比ListBox提供更多自定义选项  TabControl：包含多个标签页  TreeView：树形结构列表  Selector：包含多个子元素，为子元素提供可选择能力  StatusBar：状态栏ItemsControl会对内容中的单个元素自动使用子项容器进行包装&lt;ListBox&gt;    &lt;Button&gt;&lt;/Button&gt;    &lt;Button&gt;&lt;/Button&gt;&lt;/ListBox&gt;&lt;!--相当于--&gt;&lt;ListBox&gt;    &lt;ListBoxItem&gt;        &lt;Button&gt;&lt;/Button&gt;    &lt;/ListBoxItem&gt;    &lt;ListBoxItem&gt;        &lt;Button&gt;&lt;/Button&gt;    &lt;/ListBoxItem&gt;&lt;/ListBox&gt;ItemsControl对应的子项容器如下            ItemsControl      Item Container                  ComboBox      ComboBoxItem              ContextMenu      MenuItem              ListBox      ListBoxItem              ListView      ListViewItem              Menu      MenuItem              StatusBar      StatusBarItem              TabControl      TabItem              TreeView      TreeViewItem      HeaderedItemsControl内容属性为Items、ItemsSource、Header主要包含以下元素  MenuItem：菜单项  TreeViewItem：树形列表项  ToolBar：工具栏Decorator内容属性为Child，对元素起装饰作用，只能有一个元素作为内容主要有以下元素  ButtonChrome  ClassicBorderDecorator  ListBoxChrome  SystemDropShadowChrome  Border  InkPresenter  BulletDecorator  Viewbox  AdornerDecoratorPanel内容属性为Children，内容可包含多个元素主要有以下元素  Canvas：画布  DockPanel：停靠布局  Grid：网格布局  TabPanel：标签页布局  ToolBarOverflowPanel：可溢出的ToolBar布局  StackPanel：栈式布局  ToolBarPanel：ToolBar布局  UniformGrid：均分网格布局  WrapPanel：换行布局控件通用属性      基本属性          Width      Height      Visibility：控件是否可见        Width和Height支持px、in、cm、pt四种单位，支持三种方式赋值          绝对值：默认单位为px      比例值：在数值后加一个*，数值为占用比例      自适应：Auto            颜色样式          Foreground：控件文本颜色      Background：控件背景色      Opacity：不透明度      Clip：用于定义控件的裁剪区域的几何形状            字体          FontFamily      FontSize      FontStretch      FontStyle      FontWeight            边框          BorderBrush：边框颜色      BorderThickness：边框宽度            布局          Margin      Padding      HorizontalAlignment：在父容器中的水平对齐方式      VerticalAlignment：在父容器中的垂直对齐方式            交互          IsEnabled：是否允许控件响应      Name：控件唯一标识符      Focusable：是否可获取焦点      ContextMenu：右键点击时的上下文菜单      ToolTip：当鼠标悬停在控件上时显示的提示信息      Cursor：当鼠标悬停在控件上时显示的鼠标光标类型      布局控件  Grid网格布局                  可以定义任意数量的行列                    行列大小可以使用绝对数值、自适应、相对比例                    行列可以设置跨行跨列，使用RowSpan或ColumnSpan附加属性            可设置Children元素的对齐方向      结合GridSplitter可实现拖拽分隔栏动态改变行高列宽        StackPanel栈式布局                  支持水平、垂直方向布局                    Orientation：设置布局方向                    HorizontalAlignment：设置子元素的水平对齐                    VerticalAlignment：设置子元素的垂直对齐              Canvas画布          为子元素附加X、Y属性，支持子元素的绝对点定位        DockPanel停靠布局          为子元素附加Dock属性，拥有Left、Top、Right、Bottom四个值，子元素会根据Dock属性停靠到对应的边界      由于LastChildFill属性默认值为True，因此最后一个子元素会填满DockPanel中的剩余空间        WrapPanel流式布局          与StackPanel类似，当子元素超过一行或一列时，会自动换行换列      "
  },
  
  {
    "title": "WPF基础——开始",
    "url": "/posts/wpf-%E5%BC%80%E5%A7%8B/",
    "categories": "C#, WPF",
    "tags": "C#, WPF",
    "date": "2024-04-13 21:52:00 +0800",
    





    
    "snippet": "开始WPF是Windows平台的UI框架，使用C#和xaml语言编写，xaml语言是xml语言的扩展使用Visual Studio创建WPF应用程序，生成如下文件      依赖项中NETCore.App是.NET平台应用程序的依赖，WindowDeskTop.App.WPF是WPF框架的依赖        App.xaml：描述整个应用程序          StartupUri：指明主页...",
    "content": "开始WPF是Windows平台的UI框架，使用C#和xaml语言编写，xaml语言是xml语言的扩展使用Visual Studio创建WPF应用程序，生成如下文件      依赖项中NETCore.App是.NET平台应用程序的依赖，WindowDeskTop.App.WPF是WPF框架的依赖        App.xaml：描述整个应用程序          StartupUri：指明主页面      xmlns:local：将项目代码的命名空间引入到xaml中      Application.Resources：声明当前应用中使用的资源（自定义类等）        &lt;Application x:Class=\"frontend.App\"             xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"             xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"             xmlns:local=\"clr-namespace:frontend\"             StartupUri=\"MainWindow.xaml\"&gt;    &lt;Application.Resources&gt;     &lt;/Application.Resources&gt;&lt;/Application&gt;            MainWindow.xaml：描述主页面布局                  x:Class：指明该布局编译生成的类        一个界面后台类通常使用partial关键字声明，表示将该类的定义拆分，如后台C#类是MainWindow，使用partial声明，xaml中x:Class=\"MainWindow\"，表示该xaml编译生成一个界面类，在编译时会合并到MainWindow类中                    xmlns:local：将项目代码的命名空间引入到xaml中                    Window.Resources：声明当前窗口中的资源              &lt;Window x:Class=\"frontend.MainWindow\"        xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"        xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"        xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"        xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"        xmlns:local=\"clr-namespace:frontend\"        mc:Ignorable=\"d\"        Title=\"MainWindow\" Height=\"450\" Width=\"800\"&gt;    &lt;Window.Resources&gt;    &lt;/Window.Resources&gt;    &lt;Grid&gt;    &lt;/Grid&gt;&lt;/Window&gt;      "
  },
  
  {
    "title": "Kotlin高级——协程",
    "url": "/posts/kotlin%E9%AB%98%E7%BA%A7-%E5%8D%8F%E7%A8%8B/",
    "categories": "Kotlin, 高级篇",
    "tags": "Kotlin, Android",
    "date": "2024-04-13 19:45:00 +0800",
    





    
    "snippet": "开始对于Kotlin，协程就是一个线程框架，将一段代码以挂起的方式运行在后台，这段代码称为协程suspend关键字：表示该函数是可挂起的，称为挂起函数，该函数需要在直接或间接协程内调用，因此一个挂起函数只能在协程或另一个挂起函数中调用添加核心库和平台库// 公共APIimplementation 'org.jetbrains.kotlinx:kotlinx-coroutines-core:1...",
    "content": "开始对于Kotlin，协程就是一个线程框架，将一段代码以挂起的方式运行在后台，这段代码称为协程suspend关键字：表示该函数是可挂起的，称为挂起函数，该函数需要在直接或间接协程内调用，因此一个挂起函数只能在协程或另一个挂起函数中调用添加核心库和平台库// 公共APIimplementation 'org.jetbrains.kotlinx:kotlinx-coroutines-core:1.5.2'// 平台具体实现implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-android:1.5.2'基本协程创建协程协程需要一个作用域对象创建协程，协程的作用域对象为CoroutineScope，需要一个CoroutineContext参数，通过三个顶层函数获取CoroutineScope  runBlocking：默认为EmptyCoroutineContext，传入CoroutineScope接收者闭包，可以使用CoroutineScope中的函数，会使当前线程阻塞  GlobalScope：全局单例对象，全局存在  CoroutineScope：传入CoroutineContext构造launch函数调用CoroutineScope的launch函数开启一个协程，传入CoroutineScope接收者闭包，其中进行协程操作，该闭包是suspend的，没有返回值launch函数定义public fun CoroutineScope.launch(    context: CoroutineContext = EmptyCoroutineContext,    start: CoroutineStart = CoroutineStart.DEFAULT,    block: suspend CoroutineScope.() -&gt; Unit): Joblaunch函数中可以调用挂起函数也可以调用非挂起函数将Dispatcher对象的Main字段、IO字段等设置到context参数可以指定协程在哪个线程运行launch(Dispatcher.Main) {    // 在主线程执行}launch(Dispatcher.IO) {    // 在IO线程执行}launch函数返回一个Job对象，表示一个协程任务，可以通过该对象获取协程信息、控制等待等  join：suspend修饰，调用者协程等待该协程直到该协程完成  cancel：取消该协程，同时递归地取消该协程调用的所有子协程  cancelAndJoin：cancel和join的连续调用  Job是协程任务的抽象，表示该协程执行的任务，每个协程都有一个Job对象，当创建子协程时，子协程会继承父协程的Job对象，形成一个协程树，当父协程的Job被取消时，它的所有子协程也会被取消协程取消所有kotlinx.coroutines中的挂起函数都检查了取消行为，在取消时抛出CancellationException，这些函数都是可取消的，若挂起函数中没有检查取消行为，则是不可取消的，会一直执行直到完成cancel() 函数只是向协程发送一个取消信号，实际上协程并不会立即停止执行，而是需要在协程内部进行判断并处理取消请求有两种方式可以使挂起函数可被取消      yield    yield函数会暂停当前协程，允许同一调度器的协程的运行，当当前协程被取消时，调用yield函数会抛出CancellationException，可以捕获该异常进行取消行为        isActive    在协程中可以使用isActive属性，当协程被取消时，isActive为false  当挂起函数对取消请求进行处理时需要抛出CancellationException，外部进行捕获，可以在finally中进行关闭资源操作不可取消的协程：使用withContext函数，传入NonCancellable对象作为Context，开启一个不可取消的协程协程超时使用withTimeout函数开启一个超时协程，指定超时时间，协程在超时后会抛出TimeoutCancellationException使用withTimeoutOrNull开启超时协程，在超时后，withTimeoutOrNull判断超时产生的异常属于协程是否为当前协程，若是当前协程，则返回null，不抛出异常超时协程是异步的，应该在捕获TimeoutCancellationException后进行资源关闭协程挂起协程的挂起和恢复是由CoroutineDispatcher调度器来实现，一个协程中的挂起函数称为挂起点，当协程遇到一个挂起点时，会保存协程当前状态，将控制权交回给调度器，协程则进入等待队列，当调度器恢复协程时，协程会从之前的状态继续执行async并发基本使用用async函数也可以创建一个协程，并且有返回值，相当于有返回值的launch函数，同样传入context,start,block三个参数async函数返回Deferred对象，表示一个在将来会返回结果的promise，调用它的await函数，在协程结束后返回值launch {    val async: Deferred&lt;Int&gt; = async {        delay(2000L)        5    }    val value = async.await() // 5}Deferred继承了Job接口，同样可以进行取消和等待惰性Async设置async函数的start参数为CoroutineStart.LAZY，在调用Deferred的await函数或调用Job的start函数后才启动协程若多个Deferred不在协程中调用，则async协程将顺序执行若多个Deferred中抛出了异常，则所有async协程和父协程都会被取消CoroutineContextCoroutineContext是一个协程上下文，是一个接口类型，存储了一个协程的相关信息和组件，如调度器、异常处理器、协程名称等，CoroutineContext与组件之间是继承关系，通过CoroutineContext的get操作符和组件子类的伴生对象实现context关联组件的索引CoroutineContext中有一个内部接口Element，Element接口中包含一个Key字段(Key是声明在CoroutineContext中的接口类型)协程组件继承了Element接口，包含一个伴生对象Key实现了CoroutineContext.Key，Element接口中提供了get操作符的默认实现public override operator fun &lt;E : Element&gt; get(key: Key&lt;E&gt;): E? =\t@Suppress(\"UNCHECKED_CAST\")\tif (this.key == key) this as E else null在CoroutineContext的get操作符中传入组件的伴生对象Key，返回该context的组件对象，伴生对象Key可以通过类名引用CoroutineContext[Job] // 使用类名引用伴生对象，获取Job组件CoroutineContext[Job.Key] // 直接引用伴生对象CoroutineContext对象支持plus操作符，可以将多个组件使用plus操作符组合，构成一个CoroutineContextJob + Dispatcher.IO // 协程任务+调度器CoroutineScopeCoroutineScope是一个描述协程作用域的对象，是比CoroutineContext更基础的对象，提供了协程创建和管理的函数，一个CoroutineScope包含一个CoroutineContext字段CoroutineScope.kt中包含了CoroutineScope的定义以及一些重要的函数// CoroutineScope定义，其中包含一个CoroutineContext字段public interface CoroutineScope {    public val coroutineContext: CoroutineContext}// plus操作符，将当前context与参数context组合，通过ContextScope构造函数构造一个新的scope对象public operator fun CoroutineScope.plus(context: CoroutineContext): CoroutineScope =    ContextScope(coroutineContext + context)// 构造一个scope对象，运行在主线程且启动异常监督@Suppress(\"FunctionName\")public fun MainScope(): CoroutineScope = ContextScope(SupervisorJob() + Dispatchers.Main)// 查看Job组件是否在活动中@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")public val CoroutineScope.isActive: Boolean    get() = coroutineContext[Job]?.isActive ?: true// 全局scope对象@DelicateCoroutinesApipublic object GlobalScope : CoroutineScope {    override val coroutineContext: CoroutineContext        get() = EmptyCoroutineContext}// 使用构造器创建一个ScopeCoroutine对象，继承父协程的context但覆盖其Job组件，并使用该对象来执行闭包public suspend fun &lt;R&gt; coroutineScope(block: suspend CoroutineScope.() -&gt; R): R {    contract {        callsInPlace(block, InvocationKind.EXACTLY_ONCE)    }    return suspendCoroutineUninterceptedOrReturn { uCont -&gt;        val coroutine = ScopeCoroutine(uCont.context, uCont)        coroutine.startUndispatchedOrReturn(coroutine, block)    }}// 使用指定的context构造一个scope对象，若context中不存在Job组件，则添加一个默认的Job@Suppress(\"FunctionName\")public fun CoroutineScope(context: CoroutineContext): CoroutineScope =    ContextScope(if (context[Job] != null) context else context + Job())// 查看Job是否存在并取消当前context的Job，同时会取消它的所有子协程的Jobpublic fun CoroutineScope.cancel(cause: CancellationException? = null) {    val job = coroutineContext[Job] ?: error(\"Scope cannot be cancelled because it does not have a job: $this\")    job.cancel(cause)}// cancel函数增加message参数public fun CoroutineScope.cancel(message: String, cause: Throwable? = null): Unit = cancel(CancellationException(message, cause))// 调用context对象的ensureActive函数，底层获取了Job组件，调用了Job的ensureActive// Job的ensureActive判断isActive字段，若为false则抛出CancellationExceptionpublic fun CoroutineScope.ensureActive(): Unit = coroutineContext.ensureActive()// 获取当前context对象，可以避免与CoroutineScope.coroutineContext字段重名冲突public suspend inline fun currentCoroutineContext(): CoroutineContext = coroutineContextScopes.kt中包含ContextScope类，实现了CoroutineScope接口，添加了构造函数internal class ContextScope(context: CoroutineContext) : CoroutineScope {    override val coroutineContext: CoroutineContext = context    // CoroutineScope is used intentionally for user-friendly representation    override fun toString(): String = \"CoroutineScope(coroutineContext=$coroutineContext)\"}Dispatcher指定协程在指定调度器的协程中执行，当不指定调度器时，使用父协程的调度器      Main：主线程，依赖于平台库提供MainDispatcher，在测试中，可以通过kotlinx-coroutines-test包中的扩展函数设置一个Dispatcher作为MainDispatcher    // kotlinx-coroutines-test包中的扩展函数setMainDispatchers.setMain(Dispatchers.Default)            IO：IO线程        Default：由默认调度器调度，使用共享后台线程池        Unconfined：非受限调度器  非受限调度器：默认使用父协程的调度器，在协程执行过程中不会强制协程在某个线程或协程中工作，而是可以自由切换，在协程被挂起时，协程不保留当前线程的信息，当协程恢复时，调度器会在某个线程上重新调度协程上下文切换一个协程可以拥有不同的上下文，使用CoroutineScope的withContext函数切换协程的上下文，传入一个CoroutineContext和一个CoroutineScope接收者闭包withContext是一个挂起函数，因此协程会被挂起，调度器开启一个新的协程执行闭包，当新协程执行结束，原协程继续执行，闭包可以有返回值，返回到withContext函数suspend fun method() = withContext(Dispatchers.IO) {    // statement    return 2 // returnValue}  launch函数不是挂起函数，不会使当前协程被挂起，withContext是挂起函数，会使当前协程被挂起子协程子协程默认继承父协程的context，当父协程被取消时，子协程将被递归取消，父协程默认等待所有的子协程结束有两种方法可以使子协程独立于父协程  使用不同的CoroutineContext创建子协程  使用新的Job创建子协程fun main() {    val coroutineScope = CoroutineScope(Dispatchers.Default)    val job = coroutineScope.launch {        println(\"这里是父协程\")        CoroutineScope(Dispatchers.IO).launch {            println(\"这里是独立的子协程1\")            delay(1000)            println(\"子协程1独立\")        }        launch(Job()) {            println(\"这里是独立的子协程2\")            delay(1000)            println(\"子协程2独立\")        }        launch {            println(\"这里是继承父协程的子协程\")            delay(1000)            println(\"子协程会不会执行\") // 继承的子协程随着父协程取消，不会执行        }    }    Thread.sleep(500)    job.cancel()    println(\"cancel\")    Thread.sleep(1000)}/* 运行结果这里是父协程这里是独立的子协程1这里是独立的子协程2这里是继承父协程的子协程cancel子协程2独立子协程1独立*/协程异常处理异常传播：当子协程产生异常时，会向上抛出到父协程，直到根协程  通过launch和actor创建的根协程，异常会作为未捕获异常直接抛出  通过async和produce创建的根协程，当调用await函数时才抛出异常，依赖用户捕获CoroutineExceptionHandler用于处理未捕获异常，该组件继承了CoroutineContext，可以直接作为context对象使用  向上传播异常的子协程和async根协程不会使用该组件  调用cancel函数取消子协程时会抛出CancellationException，父协程会自动忽略该类型的异常，不会取消父协程，当抛出了其他类型的异常，父协程会被同时取消，引起其他子协程的递归取消  当父协程的所有子协程全部结束后，父协程才会使用ExceptionHandler处理异常，处理异常并不会阻止父协程因为异常而被取消  若多个子协程都产生异常，则只抛出第一个异常，其他异常作为受抑制异常绑定到第一个异常监督父协程可以使用监督检测子协程的异常抛出，从而不影响其他的子协程，同时防止父协程因为异常而被取消      SupervisorJob：继承于Job，可以使用SupervisorJob创建子协程或设置为父协程的context，当子协程抛出异常时，同样会向上抛出到根协程，由根协程的ExceptionHandler处理，但不会引起父协程的取消        SupervisorScope：类似于coroutineScope函数，使用构造器构造一个SupervisorCoroutine对象，由该对象来执行闭包，SupervisorScope中的子协程不会向上抛出异常，因此每个子协程应该设置ExceptionHandler来处理自身的异常    SupervisorCoroutine继承了ScopeCoroutine，重写了childCancelled方法    该方法的原始实现    // 在子协程抛出异常时，父协程决定是否取消自己public open fun childCancelled(cause: Throwable): Boolean {    // 当异常是CancellationException时取消自己    if (cause is CancellationException) return true    return cancelImpl(cause) &amp;&amp; handlesException}        SupervisorCoroutine重写了childCancelled方法，直接返回false，表示当子协程抛出异常时，父协程不会取消自己  异步流kotlin使用Flow表示异步计算的流，类似Sequence，Sequence是同步计算，Flow是异步计算，两者都是惰性计算，Flow支持Sequence的集合操作      构造：flow函数——sequence函数，flow函数的闭包是suspend的且可被取消    其他构造函数有flowOf和asFlow        生成：emit函数——yield函数        收集：collect函数——forEach函数，collect函数是suspend的    由于flow在收集时才进行计算，因此在构造时可以不进行挂起，在收集时才挂起  FLow有冷流和热流两种，冷流必须包含消费者，热流不一定需要消费者，可以独立存在  冷流：FLow  热流：StateFlow，SharedFLow          StateFlow：类似LiveData，在状态改变时响应      SharedFLow：类似消息总线，在值发送时响应      上下文Flow的协程上下文由Flow收集器所在的context决定，在构造Flow时所处的上下文也是收集器所在的上下文flowOn操作用于更改Flow的协程上下文，传入一个CoroutineContext对象，在flowOn操作之前的操作都将处于这个context对象表示的上下文中扩展操作Flow扩展了一些集合操作，可以提高处理速度      缓冲    当生成值的速度快于处理值的速度时，可以在处理操作之前使用buffer操作缓存生成的值，提高整体速度        合并    当生成值的速度快于处理值的速度时，在处理操作之前使用conflate操作，可以使处理操作跳过中间值    可以理解为生成的值被压入一个栈中，当处理操作结束后会取栈顶元素处理，剩下的元素被丢弃        取最新值    对Flow的每个集合操作xxx，都存在一个xxxLatest操作，当构造器生成新值时，会取消当前操作接收新值  展平流由于flow是异步的，所以存在特殊的展平操作用于特殊处理  flatMapConcat：将接收到的流串行  flatMapMerge：将接收到的流并行  flatMapLatest：当接收到新流时，取消当前的流操作异常在Flow的终止操作处捕获操作，可以捕获到整个操作过程中的所有异常，在捕获异常后，构造器停止生成值使用catch操作符可以封装异常处理操作flow.catch { e -&gt;    println(e) // 可以打印异常    throw e // 可以重新抛出异常    emit(value) // 可以重新生成值，但生成后流依然会停止，重新生成的值类型与流的值类型要相同}.collect { value -&gt; println(value) }catch只会捕获catch之前的操作产生的异常，需要捕获所有异常时使用声明式捕获flow    // 使用onEach代替collect，将collect的操作代码提前    .onEach { value -&gt;        check(value &lt;= 1) { \"Collected $value\" }        // collect操作        println(value)     }    // catch只捕获上游异常    .catch { e -&gt; println(\"Caught $e\") }    .collect()  // collect只作为启动流计算的终止操作完成使用onCompletion操作指定Flow完成时进行的操作，onCompletion是一个中间操作，onCompletion传入一个cause参数，表示Flow处理时产生的异常(包括收集器中的异常)，若Flow成功完成，则cause参数为nullonCompletion不处理异常，异常依然会传递到下游flow    .catch { ... }  // catch1    .onCompletion { cause -&gt;        println(\"completion\")        if (cause != null) println(\"Flow completed exceptionally\")    }    .catch { ... }  // catch2    .collect { ... }// 传递顺序// catch1 --&gt; collect --&gt; onCompletion --&gt; catch2取消在处于协程中的Flow操作中可以使用cancel函数取消当前Flow任务，cancel函数是CoroutineScope对象的cancel函数在取消前需要检测是否可以取消，使用onEach操作进行检查flow    .onEach {        // 获取当前协程上下文进行检查        currentCoroutineContext().ensureActive()    }cancellable操作符封装了上述检查flow.cancellable()通道Channel是一个并发安全的队列，可以实现多协程之间的通信基本操作  send：发送消息  receive：接收消息val channel = Channel&lt;Int&gt;()  // 创建channel时可以指定缓冲区大小launch {    channel.send(2)}launch {    val i = channel.receive()    println(i)}Channel支持遍历管道中的数据，直到管道被关闭val channel = Channel&lt;Int&gt;()launch {    for (i in 1..5) {        channel.send(i)    }    channel.close() // close关闭管道}launch {    for (i in channel) {        println(i)    }}使用Channel可以将协程构造为生产者协程和消费者协程  produce函数：构造一个生产者协程，返回一个ReceiveChannel  actor函数：构造一个消费者协程，返回一个SendChannel扇入、扇出  当channel有多个消费者时，每次发送一个消息，由其中一个消费者进行处理  channel支持多个生产者并发地发送消息"
  },
  
  {
    "title": "JavaScript异步编程",
    "url": "/posts/javascript%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/",
    "categories": "前端",
    "tags": "JavaScript, 前端",
    "date": "2024-04-13 19:19:00 +0800",
    





    
    "snippet": "PromisePromise是ES6引入的异步解决方案，一个Promise对象表示一个异步操作，链式调用相关方法处理成功或失败结果Promise有三个状态，完成和拒绝状态有相应的回调函数，指定多个回调时，所有回调都执行  等待（pending）：可以转换到完成和拒绝  完成（fulfilled）：到达该状态后不可修改  拒绝（rejected）：到达该状态后不可修改创建和使用  Promis...",
    "content": "PromisePromise是ES6引入的异步解决方案，一个Promise对象表示一个异步操作，链式调用相关方法处理成功或失败结果Promise有三个状态，完成和拒绝状态有相应的回调函数，指定多个回调时，所有回调都执行  等待（pending）：可以转换到完成和拒绝  完成（fulfilled）：到达该状态后不可修改  拒绝（rejected）：到达该状态后不可修改创建和使用  Promise()：构造函数，传入一个回调函数表示异步操作  then()：包含两个回调函数参数，表示OnResolved和OnRejected，可以只传OnResolvedconst p = new Promise((resolve, reject) =&gt; {    // async operation    // 在成功时调用resolve(value)    // 在失败时调用reject(err)}).then(    value =&gt; {        // on fulfilled        // then可以仅传入成功回调    },    reason =&gt; {        // on rejected    })then的返回值在then方法的回调上可以返回一个值，then方法的返回值为Promise  返回非Promise值：then返回的Promise状态为resolved状态  返回Promise值：返回的Promise的状态就是then方法的状态  抛出异常：then返回的Promise状态为rejected状态const result = p.then(    value =&gt; {        // ...    },    reason =&gt; {        // ...    })其他方法  catch方法：用于处理Promise的rejected状态  Promise.all：组合多个Promise，全部执行，当所有Promise执行成功时，返回成功状态，value是一个数组，包含各个Promise的value  Promise.allSettled：组合多个Promise，全部执行，只返回成功状态的Promise，value包含各个Promise的状态的value  Promise.race：传入多个Promise，取第一个改变状态的Promise作为返回的Promiseasync和awaitasync和await在ES8中引入，用于简化Promise编写async函数使用async关键字声明，返回的任何值都包装为Promise对象  返回非Promise对象：返回一个成功的Promise  抛出异常：返回一个失败的Promise  返回Promise：返回的Promise的状态就是async返回的Promise的状态async function method() {    // ...}await语句必须写在async函数中，后接一个表达式，表达式的结果一般为Promise对象await的返回值为Promise成功的值，若失败则抛出异常，通过try-catch处理"
  },
  
  {
    "title": "JavaScript基础",
    "url": "/posts/javascript%E5%9F%BA%E7%A1%80/",
    "categories": "前端",
    "tags": "JavaScript, 前端",
    "date": "2024-04-13 19:19:00 +0800",
    





    
    "snippet": "开始各个厂商对JavaScript都有自己的实现，都遵循ES标准JavaScript的实现包含三个部分  ES标准  DOM：文档对象模型  BOM：浏览器对象模型编写位置  HTML文档的script标签  标签属性  通过scrtip标签的src属性引入.js文件，引入后标签内的代码无效注释// 单行注释/* 多行注释 */使用严格模式：\"use strict\";属性访问空安全：obj?...",
    "content": "开始各个厂商对JavaScript都有自己的实现，都遵循ES标准JavaScript的实现包含三个部分  ES标准  DOM：文档对象模型  BOM：浏览器对象模型编写位置  HTML文档的script标签  标签属性  通过scrtip标签的src属性引入.js文件，引入后标签内的代码无效注释// 单行注释/* 多行注释 */使用严格模式：\"use strict\";属性访问空安全：obj?.nameglobalThis：对全局对象的抽象，始终指向全局对象变量变量声明var variable;let variable;常量声明const variable;获取变量类型：typeof variable数据类型      String：双引号，单引号都可以        Number    Number.MAX_VALUE获取JS表示的最大值，超过最大值表示为字面量Infinity，类型Number    不可计算的结果表示为字面量NaN，类型Number    十六进制以0x开头，八进制以0开头，二进制表示0b开头    大整数：数字后跟字符n，通过BigInt()转换        Boolean        Null    null值用于表示为空的Object，null值的类型是Object        Undefined    undefined值表示未定义的值，类型为undefined        Object：Object属于引用类型，其他都属于基本类型  类型强转      String()        Number()：非法数字转换为NaN    字符串解析为数字          parseInt()，可以指定进制      parseFloat()            Boolean()          0和NaN为false，其余都为true      空字符串为false，其余都为true      null和undefined为false      Object都为true      SymbolSymbol数据类型表示一个唯一不重复的值，不能进行运算Symbol创建let s = Symbol();let s1 = Symbol(\"Hello\");let s2 = Symbol.for(\"Hello\");var与let、const的区别      变量的作用域不同          var声明的变量只有全局作用域和函数作用域      let声明的变量具有块作用域，全局作用域和函数作用域      const声明的变量和let作用域相同            const    const声明的是常量，必须在声明时进行初始化，此后变量的值不变    当const声明的是对象时，对象为引用类型，变量获取的实际是对象的常量指针，因此变量只能指向该对象，该对象的属性可变  解构赋值      数组解构赋值    const arr = [1, 2, 3, 4];let [i1, i2, i3, i4] = arr;            对象解构赋值    const obj = {\tname: 'Hello',    age: 20};let {name, age} = obj;    // 函数参数解构function method({name, age}) {    // ...}let obj = {    name: \"Hello\",    age: 20}method(obj);      函数函数声明function func(parms) {    return returnvalue;}函数可作为函数对象使用，适用于闭包// 构造器生成函数对象let fun = new Function(\"console.log('hello');\");fun()// 函数声明的函数对象function func() {    // ...}let fun = func;fun();// 匿名函数对象let fun = function () {    // ...}fun();// 直接调用匿名函数对象(function func(x) {    // ...})(x);// 函数默认值function method(a, b, c = 10) {    // ...}// 解构默认值function method({name, age = 20}) {    // ...}函数对象方法：通过函数对象调用，都可以修改函数对象的this指向  call(obj, parms…)：传入对象obj，执行该函数同时将该函数的this指向obj，parms为函数参数  apply(obj, parmsArray)：将函数的this指向传入的obj，函数参数以数组形式传入  bind(thisArg)：复制一个函数，并设置新函数的this，设置后不可更改，若第二个参数之后传入参数，则将原函数对应位置参数设为固定值this、argumentsJavaScript的this以函数为导向，每个函数调用时包含两个隐含参数this和arguments，与原型对象不同，原型对象prototype在函数创建时生成，this和arguments在函数调用时传入this的值为函数调用的上下文对象(object context)，可理解为指向调用函数的对象      对象调用时，this指向该对象        全局函数调用时，this指向window对象        函数中调用函数时，this指向window对象    在全局作用域中声明的变量和函数，本质是声明Window对象的动态属性    对于变量，使用var声明会声明到Window对象中，使用let声明不会声明到Window对象中  arguments是封装函数参数的对象，是一个伪数组，可以通过下标访问rest参数rest参数用于代替arguments，在参数列表中将多余参数包装成伪数组在函数中使用，rest参数必须在参数列表末尾function method(...args) {    // ...}扩展运算符...：将数组转换为一个参数序列（在ES8中支持对象的扩展运算符）let arr = [1, 2, 3, 4];// ...arr =&gt; 1, 2, 3, 4扩展运算符的应用      数组合并    let a = [1, 2];let b = [3, 4];let c = [...a, ...b];  // c = [1, 2, 3, 4]            数组复制：浅拷贝    let a = [1, 2, 3, 4];let b = [...a];            将伪数组转换为真数组    const divs = document.querySelectorAll(\"div\");const divArr = [...divs];      箭头函数类似于lambda表达式let hello = function (a, b) {    return a + b;}let hello = (a, b) =&gt; {    return a + b;}let hello = (a, b) =&gt; a + b; // 单行返回箭头函数this的指向：function函数有自己的this值，指向调用该函数的对象(object context)，箭头函数没有自己的this值，其this值通过继承函数作用域链上最近的函数获取箭头函数不能使用call、apply、bind函数改变this指向let circle = {    radius: 10,    outer:function () {        let inter = function () {            console.log(this == window);            console.log(this.value);        };        inter();        console.log(this == circle)    }}circle.outer() // true undefined true// inter由函数调用，它的this指向浏览器对象window，window里没有radius属性，返回undefinedlet circle = {    radius: 10,    outer:function () {        let inter = () =&gt; {            console.log(this == window);            console.log(this.value);        };        inter();        console.log(this == circle)    }}circle.outer() // false 10 true// inter是箭头函数，根据函数作用域链向上寻找并继承其他函数的this值，inter继承outer的this值，指向circle数组JavaScript数组可以动态扩容，且可以同时存放任意类型，length属性返回数组长度// new创建let arr = new Array();arr[0] = 1;// 字面量创建let arr = [1, 2, 3];let [a, b, c] = arr  // 解构赋值let [d, e, f, g = 10] = arr  // 解构默认值let [h, ...i] = arr // 解构剩余值数组，可将可迭代对象转换为数组数组遍历  for三段式  for-in：获取可迭代对象的键，可遍历数组和对象属性，最好用于遍历对象属性  for-of：获取可迭代对象的值，可遍历数组和对象属性，最好用于遍历数组数组方法  push()：在尾部添加任意个数元素，返回新的长度  pop()：删除最后一个元素，返回该元素  unshift()：在开头添加任意个数元素，返回新的长度  shift()：删除第一个元素，返回该元素  forEach()：传入一个函数对象，对数组元素执行该函数，函数对象中的参数分别为数组元素，下标，整个数组  slice(start, end)：[start, end)，数组切片并返回，支持负数倒数索引  splice(start, n, obj…)：删除指定索引开头的n个元素并已数组形式返回，在start处插入多个obj  concat()：连接多个数组并返回新数组  join()：将数组以字符串返回，可以传入字符串指定分隔符  reverse()：反转数组  sort()：排序，默认按照字典序排序，传入一个函数对象指定Comparator对象对象的分类  ES标准对象：String、Object等  浏览器对象：console、document等  自定义对象对象创建判断对象中是否存在某个属性:attr in obj，attr类型为String，以属性名匹配变量let person = {    name: \"nnn\",    age: 20}console.log(\"name\" in person)  // truelet {name, age} = person  // 对象解构赋值，名称必须与属性名相同let {name:n1, age:n2} = person // 解构赋值别名let {name:n1, age:n2 = 30} = person  // 解构赋值默认值声明一个Object类型对象let obj = new Object();// 字面量创建let obj = {    name:\"obj\",    age:18};可以在声明对象后，在外部动态赋值属性let obj = {}; // Object类型obj.name = \"obj\";// 字典型赋值// 若key不符合命名规范，则自动转换为String类型obj[18] = 999; // {'18': 999}// 若key符合命名规范，则声明该变量obj[\"n1\"] = 1000; // {n1: 1000}使用计算属性（动态属性名）let a = \"Hello\";let method = \"myMethod\";let obj = {    // 中括号中可以使用复杂表达式    [a]: 20,    [method]() {        // ...    }}// obj[a]或obj['Hello']可以声明其他类型的对象，动态赋值属性let obj = new String();obj.age = 100;console.log(obj); // [String: ''] { age: 100 }对象使用属性访问和下标访问obj.n // 属性访问将输入的属性名作为变量与对象属性变量进行匹配，若没有该属性则返回undefinedobj[n] // 下标访问将输入的属性名作为值与对象属性名进行匹配let obj = {    name:\"abc\"}let n = \"name\";obj.n // undefinedobj[n] // \"abc\"for/in遍历对象字段for (let n in obj) {    // typeof n = String    obj[n]; // 访问对象变量值}对象方法let obj = {    fun:function (x) {        // ...    },    fun1() {        // ...    }}obj.fun(x);对象简化写法对象字面量声明对象时，传入变量时简化属性名let name = \"Hello\";let age = 20;const obj = {    name,    age,    // 匿名函数简写    method() {        // ...    }}类模拟类早期JavaScript不支持类，可以通过一些方法模拟类构造函数经典方法function Person(name, age) {    this.name = name; // 实例字段    this.age = age;    this.fun = function (x) {        // ...    } // 实例方法}let p = new Person(name, age);模拟类方法(极简方法)使用对象模拟一个类，其中定义构造函数Javascript定义类（class）的三种方法 - 阮一峰的网络日志 (ruanyifeng.com)var Person = { // 建议const    create:function (name) {        var p = {}; // 建议const        p.name = name;      \tp.speak = function() {console.log(\"Hello\");};        return p;    }}// 简化写法/*const Person = {    create:function(name) {        return {            name:name,            speak:function() {                console.log(\"Hello\");            }        };    }}*/let p = Person.create(name);p.name;p.speak();使用该方法创建的对象总是Object类型({}类型)let p = Person.create(name);p instanceof Person // TypeErrorp instanceof Person.create // falsep instanceof Object // true该方法使用简单，便于理解，在不需要类型判断时可以使用继承使用极简方法可以很容易地实现继承的效果const Animal = {    create: function () {        return {            name:\"动物\"        };    }}const Cat = {    create: function () {        const cat = Animal.create();        cat.age = 2;        return cat;    }}访问限制使用极简方法来模拟私有字段/方法和公有字段/方法const Cat = {    create: function () {        const cat = {};        // 相当于在构造时动态设置访问级        let name = \"nn\"; // private        cat.age = 2; // public        cat.getName = function() {return name;};        return cat;    }}类字段和类方法使用极简方法来模拟类字段和类方法const Cat = {    create: function () {        const cat = Animal.create();        cat.age = 2;        return cat;    },    // 在Cat中定义的字段和方法可以看做类字段和类方法，通过Cat调用    value: \"nnn\";    speak: function () {        console.log(\"Hello\");    }}Cat.speak();Cat.value;将类字段/方法与对象关联，使得对象可以操作类字段/方法const Cat = {    create: function () {        const cat = {};        cat.age = 2; // 实例字段        cat.speak = this.speak; // 类方法，该方法调用者为Cat，this指向Cat，或者赋值Cat.speak        // 类字段共享只能使用方法来对类字段进行操作，若直接赋值，其实是动态添加了实例属性，无法做到共享        // 操作时使用Cat类调用，该方法的调用者为cat对象，this指向cat对象，使用this调用无效        cat.setValue = function (value) {            Cat.value = value;        }        cat.getValue = function () {            return Cat.value;        }        return cat;    },    // 在Cat中定义的字段和方法可以看做类字段和类方法，通过Cat调用    value: \"nnn\",    speak: function () {        console.log(\"Hello\");    }}class类在ES6中，js添加了类功能，可以使用class声明一个类class Person {    // 属性    name  // 声明属性    age = 20  // 初始化属性\tstatic attr  // 静态属性，无法通过实例访问，只能通过类访问    // 方法    fun() {        // ...        // 实例方法中的this指向实例对象    }    static fun1() {        // ...        // 静态方法中的this指向类    }    // 构造器    constructor(name) {        this.name = name    }}let person = new Person()  // 构造函数person instanceof Person  // 类型判断// 声明动态属性person.name = \"Hello\"封装私有属性使用#前缀class Person {    #name  // 私有属性必须先声明    constructor(name) {        this.#name = name    }    // 可提供getter和setter    getName() {        return this.#name    }    setName(name) {        this.#name = name    }    // 简化语法糖，可简化为属性访问形式    get name() {        return this.#name    }    set name(name) {        this.#name = name    }}继承与多态js使用extends实现继承，支持方法重写class Animal {    // ...}class Dog extends Animal {    // 重写构造器时，调用父类构造，同Java    constructor() {        super()    }    // ...}多态：js是动态语言，它的多态并不依赖于继承，在使用一个未知类型对象时，只关心该对象内部是否有相应的属性或方法原型对象每个函数、对象都自动存在一个原型对象，隐含的prototype属性指向原型对象，而原型对象中的constructor属性指向该函数对象当函数以构造函数的形式调用时(类实例化)，该构造函数创建的对象中会包含一个隐含属性__proto__，该属性指向原型对象若函数是构造函数，则类中声明的方法会存储在原型对象中fun.prototype  // 函数访问自己的原型对象，通常使用该方式访问原型对象obj.__proto__  // 对象访问自己的原型对象fun.prototype == obj.__proto__  // truefun.prototype.constructor == fun  // prototype和constructor属性是对应的Object.getPrototypeOf(obj)  // 通过Object安全访问原型对象原型对象可看做一个类对象(静态)，其中定义的属性和方法可作为各个对象实例的类字段和类方法创建出对象或构造函数后，可以向原型对象里动态定义字段和方法function Person(name) {    this.name = name;}let p = new Person(name);Person.prototype.age = 20;console.log(p.age) // 20instanceofinstanceof用于判断对象实例类型，判断实例是否是某个构造函数创建的，不能用于判断原型对象TypeException:Right-hand side of 'instanceof' is not callable，instanceof的右值必须是可调用的instanceof实际是判断实例对象的__proto__和构造函数的prototype是否相同function Person(name) {    this.name = name;}let p = new Person(name);console.log(p instanceof Person) // trueconsole.log(p instanceof Person.prototype) // error原型链构造函数与对象的原型关系两种构造方法的原型链经典方法(对应类实例化)：真正的创建了Person构造函数，生成了Person的原型对象极简方法或字面量方法：本质上person是个Object对象，没有创建新的原型对象原型继承：js继承通过原型链实现，子类的原型对象就是父类的实例对象对象方法      hasOwnProperty：判断对象实例自身的字段    使用obj.hasOwnProperty(\"attr\")判断对象实例自身的字段，不包含原型对象的字段    function Person(name) {    this.name = name;}let p = new Person(name);Person.prototype.age = 20;\"age\" in p // truep.hasOwnProperty(\"age\") // false            Object.is：判断两个对象是否完全相等        Object.assign：对象合并，将后一参数对象合并到前一参数对象，若出现重名成员，则覆盖        Object.setPrototypeOf：设置对象原型对象        Object.getPrototypeOf：获取对象原型对象        Object.fromEntries：通过二维数组或Map来创建对象        Object.entries：将对象转换为二维数组  常用工具对象Date创建Date对象自动以当前时间创建Date date = new Date();// 传入指定时间字符串创建，格式:mm/dd/yyyy hh:MM:ssDate date = new Date(\"10/5/2022 16:17:00\");方法  getDate()：返回日期  getDay()：返回日期是周几，周日返回0  getMonth()：返回月份，从0开始  getFullYear()：返回年份  getTime()：返回时间戳(自1970年1月1日到至今的毫秒数)  Date.now()：获取当前时间戳字符串字符串支持下表访问，length获取字符串长度  charCodeAt()：返回指定位置字符的Unicode编码  String.fromCharCode()：返回Unicode编码对应的字符  concat()：连接多个字符串  indexOf(char, start)：获取字符串中字符的索引，不存在则返回-1，start指定开始查找的位置  lastIndexOf()：从尾部查找字符的索引  slice()：获取子串  substring()：获取子串，不支持负数索引  split()：字符串分割为数组，传入字符串分隔符，传入空串，则以每个字符分割  search()：搜索字符串中的子串，返回第一次出现的索引，不存在则返回-1  replace()：将字符串中的第一个指定子串替换为新内容  trimStart()：去除字符串起始空白  trimEnd()：去除字符串末尾空白  trim()：去除字符串起始和末尾空白正则表达式JavaScript正则表达式使用RegExp对象封装let reg = new RegExp(\"expression\", \"pattern\");// 字面量创建let reg = /expression/pattern;pattern  “i”:忽略大小写  “g”:全局匹配相关方法  test(str)：测试str是否符合正则表达式  与字符串相关，由字符串调用          split()：传入正则表达式，根据正则表达式的匹配结果分割字符串，默认全局匹配      search()：传入正则表达式，返回第一个匹配结果的索引，不支持全局匹配      match()：传入正则表达式，返回第一个匹配结果，正则设置为全局匹配g，返回所有匹配结果的数组      replace()：传入正则表达式，将第一个匹配结果替换为新内容，正则设置为全局匹配g，将所有匹配结果替换      JSON  JSON.parse(jsonString)：将json字符串转换为json对象  JSON.stringify(obj)：将js对象转换为json字符串MapMap的键值支持任意对象let map = new Map()map.sizemap.keys()map.values()map.entries()map.set(key, value)map.get(key)  // 不存在返回undefinedmap.delete(key)  // 删除keymap.has(key)  // 是否包含keymap.clear()let arr = Array.from(map)  // 将map转换为k-v数组let map = new Map([[k1, v1], [k2, v2], [k3, v3]])  // 数组转换为map// 遍历mapfor (let entry of map) {    // entry = [k, v]    // ...}for (let [k, v] of map) {    // ...}Setlet set = new Set()set.sizeset.add(value)set.delete(value)set.has(value)for (let item of set) {    // ...}let set = new Set([v1, v2, v3])  // 数组转换为Set迭代器迭代器用于for…of访问，实际通过Symbol.iterator方法获取迭代器Iterator，调用Iterator的next方法遍历，next方法返回一个包含value和done两个属性的对象，value为遍历值，done表示遍历是否完成自定义迭代器class MyArray {    #array = [\"a\", \"b\", \"c\"];    [Symbol.iterator]() {        let i = 0;        let _this = this;        // 返回一个Iterator对象，带有next方法        return {            next() {                // next方法返回一个带有value和done两个属性的对象                if (i &lt; _this.#array.length) {                    return {                        value: _this.#array[i++],                        done: false                    }                } else {                    return {                        value: undefined,                        done: true                    }                }            }        }    }}const myArray = new MyArray();for (let v of myArray) {    console.log(v);}生成器生成器是一个函数，可以实现代码逻辑的迭代执行function* generate() {    // 生成器中可以使用yield，中断执行，返回输出    yield 1    yield 2    yield 3}for (let v of generate()) {    console.log(v);}生成器传参function* generate(arg) {    // 调用传参    console.log(arg)    // next方法传参    let res1 = yield    console.log(res1)  // A    let res2 = yield    console.log(res2)  // B    let res3 = yield    console.log(res3)  // C}let generator = generate(\"Hello\")generator.next()  // 执行console.log(arg)generator.next(\"A\")  // 赋值res1，执行console.log(res1)generator.next(\"B\")  // 赋值res2，执行console.log(res2)generator.next(\"C\")  // 赋值res3，执行console.log(res3)模块化在ES6之前有许多模块化规范  CommonJS：NodeJS  AMD：requireJS  CMD：SeaJS模块化语法导出：export// 导出变量export let variable = 20;// 导出函数export function method() {    // ...}// 统一导出export {    variable,    function1}// 默认导出，通过default属性获取export default {    name: variable,    age: 20,    method: function() {        // ...    }}导出：import// 导入所有成员import * as my_module from 'filepath'// 解构导入，使用别名import {variable as other, function1} from 'filepath'// 默认导出解构import {default as m} from 'filepath'// 默认导出语法糖import m from 'filepath'// 动态导入import(\"./hello.js\").then(module =&gt; {    // ...})"
  },
  
  {
    "title": "回溯算法——理论基础",
    "url": "/posts/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95-%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/",
    "categories": "算法, 回溯算法",
    "tags": "算法, 回溯算法",
    "date": "2024-03-18 20:16:00 +0800",
    





    
    "snippet": "前言我在大概两年前就学习过回溯算法，但总是学了就忘，写了很多例题但一到自己写就抓瞎，本质上还是不理解，现在打算跟着代码随想录系统的重新学一遍，记录一下自己的理解递归for循环回溯算法的本质就是穷举，但它比嵌套for更适用的一点是它可以实现任意k层的for循环，想象一下这个情境，输入一个参数k，实现k层嵌套循环。直接硬编码k层for循环是无法实现的，因为k是一个变化的参数，但是这个问题使用回溯...",
    "content": "前言我在大概两年前就学习过回溯算法，但总是学了就忘，写了很多例题但一到自己写就抓瞎，本质上还是不理解，现在打算跟着代码随想录系统的重新学一遍，记录一下自己的理解递归for循环回溯算法的本质就是穷举，但它比嵌套for更适用的一点是它可以实现任意k层的for循环，想象一下这个情境，输入一个参数k，实现k层嵌套循环。直接硬编码k层for循环是无法实现的，因为k是一个变化的参数，但是这个问题使用回溯就可以解决（准确地说是递归+for循环）我们先来写一个两层的for循环for (int i = 0; i &lt; n; i++) {    for (int j = 0; j &lt; n; j++) {        // ......    }}实际上它的穷举结果可以抽象成一棵树，如下图所示那么我们怎么使用递归+for循环实现这个穷举树呢，先给出代码void trace(int layer) {    if (layer == 2) {        return;    }    for (int i = 0; i &lt; n; i++) {        // ...        trace(layer + 1);    }}使用一个参数layer表示当前循环的层数，当layer == 2时，退出递归，这也被称为递归的终止条件。每一层包含一个for循环，递归到第二层，也就是执行了两层for循环乍一看，怎么使用递归反而更加复杂了，还多需要一个参数，但当我需要执行k层循环时，使用递归就变得轻而易举，而一般嵌套for循环就无法实现了void trace(int layer, int k) {    // 将递归层数用参数k表示    if (layer == k) {        return;    }    for (int i = 0; i &lt; n; i++) {        // ...        trace(layer + 1, k);    }}有了递归+for循环这一利器，我们就可以实现嵌套for循环无法实现的穷举了我们再来看一下trace函数和穷举树的关系，我们在trace函数中使用参数k表示穷举树的深度，在每个节点中，for循环的穷举范围就是该节点的所有子状态，也称为宽度。在之后的解题中，分析出树的深度和宽度对我们写程序有很大的帮助，包括在剪枝中，也是围绕着宽度来分析回溯算法在上述框架下，我们得出回溯算法的模板void backtrack(参数、状态) {    if (终止条件) {        存放结果;        return;    }    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {        处理节点;        backtrack(路径，选择列表); // 递归        回溯，撤销处理结果  // 回溯    }}回溯算法之所以称为回溯算法，就是因为撤销处理结果这一步，那么为什么要撤销呢，实际上，回溯算法解决的问题通常要求给出所有符合要求的状态，倘若没有回溯这一步，一次穷举到达叶节点后，就无法继续穷举了，因此要撤回叶节点的结果，返回到上一层节点才能继续遍历其他节点回溯算法可以解决以下问题  组合情况  分割集合  子集  全排列  N皇后、解数独"
  },
  
  {
    "title": "SharpPcap学习总结",
    "url": "/posts/sharppcap%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/",
    "categories": "C#",
    "tags": "C#, SharpPcap",
    "date": "2024-03-16 21:38:00 +0800",
    





    
    "snippet": "前言SharpPcap是.NET环境中跨平台的抓包框架，对WinPcap和LibPcap进行了统一的封装，使用C#语言本人的毕设需要使用WinPcap进行抓包解析，还需要做一个UI界面，正好.NET有这样一个库，同时还有WPF这样的UI框架，之前参与过Android项目，WPF的xaml布局写法和Android很类似，上手WPF难度应该不算很高，综合考虑下选择使用C#完成毕设（根本原因是C+...",
    "content": "前言SharpPcap是.NET环境中跨平台的抓包框架，对WinPcap和LibPcap进行了统一的封装，使用C#语言本人的毕设需要使用WinPcap进行抓包解析，还需要做一个UI界面，正好.NET有这样一个库，同时还有WPF这样的UI框架，之前参与过Android项目，WPF的xaml布局写法和Android很类似，上手WPF难度应该不算很高，综合考虑下选择使用C#完成毕设（根本原因是C++用不顺手​~​:broken_heart::broken_heart::broken_heart:）理想是丰满的，现实是骨感的，当我兴致勃勃准备查找文档开始干的时候，发现怎么网上搜出来的例子跑不通。找到GitHub仓库，在Tutorial找到一篇文档，但是还是有例子跑不通，猜测是版本的问题，结果发现在releases中写“Please see nuget for releases”，这个nuget又是啥，咋还跑到那里去发布，后来了解到nuget是.NET的包管理平台，类似Java的Maven。一路搜索过去，倒是找到了SharpPcap的Nuget地址，但是还是找不到最新的文档，此时我的内心是崩溃的没办法，只能硬着头皮看Tutorial的文档和反编译的源码慢慢调试了，在此记录一下SharpPcap新版本的API使用，SharpPcap版本为6.3.0SharpPcap的GitHub仓库：dotpcap/sharppcapPacketDotNet的GitHub仓库：dotpcap/packetnetNuGet地址：NuGet Gallery SharpPcap 6.3.0SharpPcap安装SharpPcap已经发布在NuGet上，所以我们可以直接通过Visual Studio的NuGet管理器获取安装，这里使用Visual Studio 2022版本      安装SharpPcap    打开项目的NuGet管理器，点击浏览，在搜索框搜索SharpPcap，点击安装即可                查看依赖项    安装完成后，我们可以看到项目中的依赖项已经有了SharpPcap的依赖，其中也包含一个叫PacketDotNet的库，SharpPcap主要负责数据包的捕获，而PacketDotNet就是负责数据包的解析            在代码中使用SharpPcap    在代码中引入SharpPcap命名空间和PacketDotNet命名空间即可，打印版本检查是否可以正常使用    using System;using SharpPcap;using PacketDotNet;     namespace backend {    public class Backend {        public static void Main(string[] args) {            // Tutorial中获取版本为string ver = SharpPcap.Version.VersionString;            var version = Pcap.Version;            var sharpPcapVersion = Pcap.SharpPcapVersion;            Console.WriteLine(version);            Console.WriteLine($\"SharpPcapVersion = {sharpPcapVersion}\");        }    }}            可以打印出Npcap版本和SharpPcap版本，接下来就可以愉快的使用了:clap::clap::clap:  获取接口列表在SharpPcap中获取接口列表非常简单，只需要一行代码var list = CaptureDeviceList.Instance;// 打印接口信息foreach (var device in list) {    Console.WriteLine(device);}获取到的CaptureDeviceList继承了ReadOnlyCollection&lt;ILiveDevice&gt;，是一个ILiveDevice类型的只读集合，由此可见获取到的设备实例是ILiveDevice类型的ILiveDevice继承了ICaptureDevice和IInjectionDevice两个接口，这两个接口都继承了IPcapDevice接口，这两个接口中主要包含了各自功能模块的方法接口// ILiveDevicepublic interface ILiveDevice : ICaptureDevice , IInjectionDevice {}// IInjectionDevicepublic interface IInjectionDevice : IPcapDevice {    // 发送数据包    void SendPacket(ReadOnlySpan&lt;byte&gt; p, ICaptureHeader header = null);}// ICaptureDevicepublic interface ICaptureDevice : IPcapDevice {    // 数据包捕获回调    event PacketArrivalEventHandler OnPacketArrival;    // 停止捕获回调    event CaptureStoppedEventHandler OnCaptureStopped;    // 是否开始捕获    bool Started { get; }    // 捕获超时时间    TimeSpan StopCaptureTimeout { get; set; }    // 开始异步捕获    void StartCapture();    // 停止捕获    void StopCapture();    // 开始同步捕获    void Capture();    // 捕获一个数据包    GetPacketStatus GetNextPacket(out PacketCapture e);    // 捕获统计信息    ICaptureStatistics Statistics { get; }}IPcapDevice中包含了接口设备相关的信息public interface IPcapDevice : IDisposable {        // 设备名    string Name { get; }    // 设备描述    string Description { get; }    // 最后一次发生的错误信息    string LastError { get; }    // 过滤表达式    string Filter { get; set; }    // 设备MAC地址    System.Net.NetworkInformation.PhysicalAddress MacAddress { get; }    // 打开设备    void Open(DeviceConfiguration configuration);    // 关闭设备    void Close();    // 设备的链路层类型    PacketDotNet.LinkLayers LinkType { get; }}打开接口并捕获从上面的接口方法中，可以看到相关的打开、捕获等方法，基本使用如下var devices = CaptureDeviceList.Instance;// 获取第一个接口var dev = devices[0];// 设置捕获回调device.OnPacketArrival += new PacketArrivalEventHandler(OnPacketArrival);dev.Open();  // 打开接口dev.StartCapture();  // 开始异步捕获Console.ReadLine();  // 阻塞主进程dev.StopCapture();  // 停止捕获dev.Close();  // 关闭接口// 回调捕获函数，捕获的包类型为PacketCapturepublic static void OnPacketArrival(object sender, PacketCapture p) {    var data = p.Data;  // 数据包数据，字节数组    var date = p.Timeval.Date;  // 时间戳    // ......}实际上这里使用的Open()是一个扩展方法，IPcapDevice接口中的Open()接收一个DeviceConfiguration类型的参数，表示启动配置，而在CaptureDeviceExtensions.cs文件中，对Open()和IInjectionDevice接口的SendPacket()做了扩展DeviceConfiguration中有两个常用的属性  DeviceModes Mode：接口工作模式          None：默认模式      Promiscuous：混杂模式        int ReadTimeout：捕获超时时间开启接口混杂模式和设置超时时间，可以调用CaptureDeviceExtensions.cs文件中的扩展device.Open(mode: DeviceModes.Promiscuous, read_timeout: 1000);捕获数据包与WinPcap一样，SharpPcap也有回调捕获和非回调捕获两种方式，在SharpPcap新版本中，将两种方式返回的数据包类型统一为了PacketCapture类型回调捕获在ICaptureDevice接口中有两个委托属性，可以定义回调函数      PacketArrivalEventHandler OnPacketArrival    数据包捕获回调，函数类型为void OnPacketArrival(object sender, PacketCapture e)        CaptureStoppedEventHandler OnCaptureStopped    停止捕获回调，函数类型为void OnCaptureStop(object sender, CaptureStoppedEventStatus status)  在调用Open()之前，设置接口的OnPacketArrival属性即可设置捕获回调device.OnPacketArrival += new PacketArrivalEventHandler(OnPacketArrival);非回调捕获使用ICaptureDevice接口中的GetNextPacket()获取一个数据包，该函数接收一个PacketCapture类型的输出参数，PacketCapture是数据包类型，返回值是GetPacketStatus枚举类型，表示捕获数据包的状态public enum GetPacketStatus {    // 超时    ReadTimeout = 0,\t// 捕获到数据包    PacketRead = 1,\t// 捕获错误    Error = -1,\t// 捕获中止    NoRemainingPackets = -2,};在While循环中持续获取数据包，不需要调用StartCapture()var device = devices[index];device.Open(mode: DeviceModes.Promiscuous, read_timeout: 1000);while (device.GetNextPacket(out PacketCapture packet) == GetPacketStatus.PacketRead) {    Console.WriteLine(packet.GetPacket().GetPacket());}device.Close();过滤数据包在SharpPcap中设置过滤数据包非常简单，只需要设置IPcapDevice接口中的Filter属性为过滤表达式即可device.Filter = \"ip6 and icmp6\";  // 过滤ICMPv6包数据包解析数据包主要使用到PacketDotNet库，PacketDotNet中将几乎所有类型的数据包都封装了实体类，而它们都继承了Packet这个抽象父类，其中也包含一些用于解析的方法，主要用到下面两个方法  Packet.ParsePacket()：将PacketCapture解析为Packet对象，  Extract&lt;T&gt;()：从Packet对象中提取指定数据包类型，返回相应的数据包对象基本使用如下private static void OnPacketArrival(object s, PacketCapture packetCapture) {    var packet = Packet.ParsePacket(        packetCapture.Device.LinkType,         packetCapture.Data.ToArray()    );    // 也可通过以下方式获取    // var packet = packetCaptrue.GetPacket().GetPacket();        // 解析出来的首先是链路层对象，ParsePacket方法返回Packet父类引用，强转为子类    var ethernet = packet as EthernetPacket ?? throw new NullReferenceException();    var udp = ethernet.Extract&lt;UdpPacket&gt;();    if (udp != null) {        Console.WriteLine(udp);    }}数据包解析的部分工作原理详见：SharpPcap数据包解析原理堆文件处理堆文件处理使用到LibPcap模块的功能，LibPcap中接口的父类为PcapDevice类，该类实现了ICaptureDevice接口写入堆文件写入文件主要使用CaptureFileWriterDevice类，它继承了PcapDevice类，主要使用以下方法      CaptureFileWriterDevice()：唯一构造器    传入写入文件名和打开模式，默认为打开并创建        Open()：打开接口    传入DeviceConfiguration，主要参数是链路层类型LinkLayers，要与捕获接口的链路层类型一致    在CaptureDeviceExtensions.cs中包含两个Open扩展函数          void Open(this CaptureFileWriterDevice device, ICaptureDevice captureDevice)      void Open(this CaptureFileWriterDevice device, LinkLayers linkLayerType = LinkLayers.Ethernet)            Write()：写入文件，有两个重载          void Write(ReadOnlySpan&lt;byte&gt; p, ref PcapHeader h)      void Write(ReadOnlySpan&lt;byte&gt; p)      void Write(RawCapture p)      基本使用如下，注意在Windows中，文件的相对路径是相对于.exe可执行文件的路径// 默认模式为打开并创建CaptureFileWriterDevice writer = new(\"capture.pcap\");// 打开捕获接口device.Open(mode: DeviceModes.Promiscuous, read_timeout: 1000);// 打开写入接口writer.Open(device);device.OnPacketArrival += new(OnPacketArrival);device.StartCapture();Console.ReadLine();device.StopCapture();writer.Close();device.Close();private static void OnPacketArrival(object s, PacketCapture packetCapture) {    // 当文件模式不是追加时，在回调中打开写入接口，每次打开会清空文件    writer.Write(packetCapture.GetPacket());}读取堆文件读取文件主要使用CaptureFileReaderDevice类，它继承了PcapDevice类，主要使用以下方法  CaptureFileReaderDevice()：唯一构造器，传入读取的文件名  Open()：打开接口  StartCapture()：开始读取文件基本使用如下CaptureFileReaderDevice reader = new(\"capture.pcap\");reader.Open();// 设置读取到数据包的回调reader.OnPacketArrival += new(OnPacketArrival);// 开始读取reader.StartCapture();Console.ReadLine();reader.StopCapture();reader.Close();private static void OnPacketArrival(object s, PacketCapture packetCapture) {    Console.WriteLine(packetCapture.GetPacket().GetPacket().PrintHex());}发送数据包发送单个数据包使用IInjectionDevice接口中的SendPacket方法，CaptureDeviceExtensions.cs中包含该方法的四个扩展方法  void SendPacket(ReadOnlySpan&lt;byte&gt; p, ICaptureHeader header = null)  void SendPacket(this IInjectionDevice device, byte[] p, int size)  void SendPacket(this IInjectionDevice device, Packet p)  void SendPacket(this IInjectionDevice device, Packet p, int size)  void SendPacket(this IInjectionDevice device, RawCapture p, ICaptureHeader header = null)基本使用如下，从文件中读取数据包发送var device = devices[index];device.Open(mode: DeviceModes.Promiscuous, read_timeout: 1000);CaptureFileReaderDevice reader = new(\"capture.pcap\");reader.Open();while (reader.GetNextPacket(out PacketCapture packet) == GetPacketStatus.PacketRead) {     device.SendPacket(packet.GetPacket());}发送队列发送队列是WinPcap扩展功能，使用LibPcap模块，主要使用到SendQueue类，使用以下方法  SendQueue()：唯一构造器，传入队列大小，单位B  Add()：添加到发送队列，SendQueue.cs的SendQueueExtensions中包含它的四个扩展方法          bool Add(PcapHeader header, byte[] packet)      bool Add(this SendQueue queue, byte[] packet)      bool Add(this SendQueue queue, Packet packet)      bool Add(this SendQueue queue, RawCapture packet)      bool Add(this SendQueue queue, byte[] packet, int seconds, int microseconds)        Transmit()：发送发送队列，传入PcapDevice类型接口对象，返回发送的字节数，有一个重载          int Transmit(PcapDevice device, bool synchronized)      int Transmit(PcapDevice device, SendQueueTransmitModes transmitMode)      基本使用如下，从文件中读取数据包添加到发送队列并发送CaptureFileReaderDevice reader = new(\"capture.pcap\");reader.Open();// 构造发送队列SendQueue queue = new((int)reader.FileSize);while (reader.GetNextPacket(out PacketCapture packet) == GetPacketStatus.PacketRead) {    // 添加发送队列，传入RawCapture    queue.Add(packet.GetPacket());}device.Open(mode: DeviceModes.Promiscuous, read_timeout: 1000);// 在WinPcap下，ILiveDevice的运行时类型是LibPcapLiveDevice，强转为子类// LibPcapLiveDevice继承了PcapDevice类，实现了ILiveDevice接口// 使用LibPcapLiveDeviceList.Instance可直接获得LibPcapLiveDevice集合queue.Transmit(device as LibPcapLiveDevice, true);统计流量信息使用到ICaptureDevice对象的Statistics属性，对于LibPcapLiveDevice对象，该属性不为null，该属性为ICaptureStatistics类型，包含以下属性  ReceivedPackets：已接收的数据包数量  DroppedPackets：丢失的数据包数量  InterfaceDroppedPackets：接口丢包数基本使用如下device.Open(mode: DeviceModes.Promiscuous, read_timeout: 1000);device.OnPacketArrival += new(OnPacketArrival);device.StartCapture();Console.ReadLine();// 获取统计信息var statistics = device.Statistics;Console.WriteLine($\"接收{statistics?.ReceivedPackets}个包\");Console.WriteLine($\"丢失{statistics?.DroppedPackets}个包\");device.StopCapture();device.Close();"
  },
  
  {
    "title": "二叉树的遍历",
    "url": "/posts/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/",
    "categories": "算法",
    "tags": "算法, 二叉树",
    "date": "2024-03-15 21:25:00 +0800",
    





    
    "snippet": "前言二叉树的遍历是二叉树的基础算法，本文对个人的遍历写法做个记录深度优先遍历递归写法递归遍历比较简单，不作讲解和注释// 前序遍历void preorder(Node* node) {    if (node) {        visit(node);        preorder(node-&gt;left);        preorder(node-&gt;right);    }...",
    "content": "前言二叉树的遍历是二叉树的基础算法，本文对个人的遍历写法做个记录深度优先遍历递归写法递归遍历比较简单，不作讲解和注释// 前序遍历void preorder(Node* node) {    if (node) {        visit(node);        preorder(node-&gt;left);        preorder(node-&gt;right);    }}// 中序遍历void inorder(Node* node) {    if (node) {        inorder(node-&gt;left);        visit(node);        inorder(node-&gt;right);    }}// 后序遍历void postorder(Node* node) {    if (node) {        postorder(node-&gt;left);        postorder(node-&gt;right);        visit(node);    }}非递归写法三种遍历的非递归写法难以统一的原因是在栈的遍历过程中，在处理当前节点时还需要指针去索引另一个访问节点，这里记录一个统一的迭代写法，将两种节点都放入栈中，但是在处理的当前节点后放入一个null与访问节点区分，这种写法在三种遍历上只需要改动顺序前序遍历vector&lt;Node*&gt; preorder(Node* root) {    vector&lt;Node*&gt; res;    stack&lt;Node*&gt; stack;    if (root) stack.push(root);    while (!stack.empty()) {        // 当前节点        Node* node = stack.top();        // 该节点是访问节点        if (node) {            stack.pop();            // 从左到右，左节点在栈顶，先放入右节点            if (node-&gt;right) stack.push(node-&gt;right);            if (node-&gt;left) stack.push(node-&gt;right);                        // 前序遍历，根节点在栈顶            stack.push(node);            // 添加null，使访问节点变为处理节点，即下次访问到null，将该节点放入结果集            stack.push(nullptr);        } else {            // 遇到null，则栈顶下一个元素是处理节点            stack.pop();            // 获取处理节点            node = stack.top();            stack.pop();            res.push_back(node);        }    }    return res;}中序遍历vector&lt;Node*&gt; inorder(Node* root) {    vector&lt;Node*&gt; res;    stack&lt;Node*&gt; stack;    if (root) stack.push(root);    while (!stack.empty()) {        Node* node = stack.top();        if (node) {            stack.pop();            if (node-&gt;right) stack.push(node-&gt;right);            if (node-&gt;left) stack.push(node-&gt;left);            stack.push(node);            stack.push(nullptr);        } else {            stack.pop();            node = stack.top();            stack.pop();            res.push_back(node);        }    }    return res;}后序遍历vector&lt;Node*&gt; postorder(Node* root) {    vector&lt;Node*&gt; res;    stack&lt;Node*&gt; stack;    if (root) stack.push(root);    while (!stack.empty()) {        Node* node = stack.top();        if (node) {            stack.pop();            stack.push(node);            stack.push(nullptr);            if (node-&gt;right) stack.push(node-&gt;right);            if (node-&gt;left) stack.push(node-&gt;left);        } else {            stack.pop();            node = stack.top();            stack.pop();            res.push_back(node);        }    }    return res;}层次遍历层次遍历写法较简单，要注意它的应用，灵活变化非递归写法vector&lt;vector&lt;Node*&gt;&gt; levelorder(Node* root) {    queue&lt;Node*&gt; q;    // 每一层是一个vector    vector&lt;vector&lt;Node*&gt;&gt; res;    if (root) q.push(root);    while (!q.empty()) {        // 当前层宽度        int size = q.size();        vector&lt;Node*&gt; level;        for (int i = 0; i &lt; size; i++) {            Node* node = q.front();            q.pop();            level.push_back(node);            if (node-&gt;left) q.push(node-&gt;left);            if (node-&gt;right) q.push(node-&gt;right);        }        res.push_back(level);    }    return res;}递归写法使用前序遍历，通过深度索引到相应的层数组再添加，根节点的深度为0void levelorder(Node* node, vector&lt;vector&lt;Node*&gt;&gt;&amp; res, int depth) {    if (!node) return;    // 到达最后一层的下一层时，若还有节点，创建数组    if (res.size() == depth) res.push_back(new vector&lt;Node*&gt;());    res[depth].push_back(node);    levelorder(node-&gt;left, res, depth + 1);    levelorder(node-&gt;right, res, depth + 1);}vector&lt;vector&lt;Node*&gt;&gt; level(Node* root) {    vector&lt;vector&lt;Node*&gt;&gt; res;    levelorder(root, res, 0);    return res;}"
  },
  
  {
    "title": "SharpPcap数据包解析原理",
    "url": "/posts/sharppcap%E6%95%B0%E6%8D%AE%E5%8C%85%E8%A7%A3%E6%9E%90%E5%8E%9F%E7%90%86/",
    "categories": "C#",
    "tags": "C#, SharpPcap",
    "date": "2024-03-14 19:24:00 +0800",
    





    
    "snippet": "前言SharpPcap与WinPcap基本用法上相差不多，但对数据包解析这个功能，SharpPcap提供了很多方法来帮我们解析数据包，而在WinPcap中，我们需要定义好包的实体类型，通过指针强转来解析包的内容字节数组，SharpPcap着实方便不少。但好奇心驱使我去看看SharpPcap是如何实现解析的，正好也学习一下，因此阅读了SharpPcap的GitHub仓库的部分源码，主要是Pac...",
    "content": "前言SharpPcap与WinPcap基本用法上相差不多，但对数据包解析这个功能，SharpPcap提供了很多方法来帮我们解析数据包，而在WinPcap中，我们需要定义好包的实体类型，通过指针强转来解析包的内容字节数组，SharpPcap着实方便不少。但好奇心驱使我去看看SharpPcap是如何实现解析的，正好也学习一下，因此阅读了SharpPcap的GitHub仓库的部分源码，主要是PacketDotNet的解析部分，本文含有大量源码，展示时会进行一定程度简化，谨慎阅读PcapCapture结构和RawCapture类在ICaptureDevice.GetNextPacket()和OnPacketArrival回调中都包含一个PcapCapture类型的参数，这个参数在捕获回调中代替了CaptureEventArgs，在ICaptureDevice.GetNextPacket()中作为输出参数，可以看出这个类型统一了捕获返回的数据类型，下面给出源码看看里面有哪些属性public readonly ref struct PacketCapture {        // 构造一个RawCapture返回，RawCapture表示一个未处理的数据包    public RawCapture GetPacket() {        return new RawCapture(Device, Header, Data);    }    // 进行捕获的接口设备    public ICaptureDevice Device { get; }    // 数据包头部    public ICaptureHeader Header { get; }    // 数据包内容，ReadOnlySpan可以看做一个只读的字节数组，调用ToArray方法可以转换为byte[]    public ReadOnlySpan&lt;byte&gt; Data { get; }        // 构造器    public PacketCapture(ICaptureDevice device,                          ICaptureHeader header,                          ReadOnlySpan&lt;byte&gt; data) {        this.Header = header;        this.Device = device;        this.Data = data;    }}可以看到PcapCapture中包含了数据包的相关属性，GetPacket()中构造了一个RawCapture对象返回，接下来继续看看RawCapture中有什么，这里只给出主要属性，省略构造器和无关方法public class RawCapture {        // 接口链路层类型    public LinkLayers LinkLayerType { get; set; }    // 时间戳    public PosixTimeval Timeval { get; set; }    // 数据包内容字节数组    public byte[] Data;    // 数据包长度    public int PacketLength { get; set; }    // 解析数据包，返回PacketDotNet库中的Packet类型    public virtual Packet GetPacket() {        return Packet.ParsePacket(LinkLayerType, Data);    }}从上面的代码中，我们可以看出RawCapture中包含的属性，抽象程度更低，并且包含了原始的数据包内容字节数组，因此PcapCapture可以看做对RawCapture中的属性进行封装的结构体，用于统一两种捕获方法的参数类型ParsePacket方法在RawCapture中，可以看到有一个GetPacket方法，其中调用了Packet.ParsePacket方法，可以看出这个方法是Packet类的静态方法，实际上这个方法就是PacketDotNet库用于解析数据包的入口方法，将SharpPcap中的RawCapture类转换为PacketDotNet的Packet类，而解析过程都是围绕这个Packet类展开的，下面我们先看看ParsePacket方法的源码public static Packet ParsePacket(LinkLayers linkLayers, byte[] packetData) {    Packet p;        // 使用ByteArraySegment类包装数据包字节数组，这个类很重要，后面重点讲解    var byteArraySegment = new ByteArraySegment(packetData);    Log.DebugFormat(\"LinkLayer {0}\", linkLayers);    // 根据链路层类型构造不同的Packet子类    switch (linkLayers) {        case LinkLayers.Ethernet: {            p = new EthernetPacket(byteArraySegment);            break;        }        case LinkLayers.LinuxSll: {            p = new LinuxSllPacket(byteArraySegment);            break;        }        case LinkLayers.Null: {            p = new NullPacket(byteArraySegment);            break;        }        case LinkLayers.Ppp: {            p = new PppPacket(byteArraySegment);            break;        }        case LinkLayers.Ieee80211: {            p = MacFrame.ParsePacket(byteArraySegment);            break;        }        case LinkLayers.Ieee80211RadioTap: {            p = new RadioPacket(byteArraySegment);            break;        }        case LinkLayers.Ppi: {            p = new PpiPacket(byteArraySegment);            break;        }        case LinkLayers.Raw:        case LinkLayers.RawLegacy: {            p = new RawIPPacket(byteArraySegment);            break;        }        default: {            // 若没有匹配的链路层类型，抛出异常            ThrowHelper.ThrowNotImplementedException(ExceptionArgument.linkLayer);            p = null;            break;        }    }    return p;}可以看到这个入口方法是根据链路层类型返回不同的链路层实体类，这些实体类实际上就是Packet类的子类，我们在往上看看Packet类的修饰符，可以看到Packet用abstract修饰，Packet类就是一个抽象类，在ParsePacket方法中首先构造的就是链路层相关的实体类，因此可以得知PacketDotNet从链路层开始解析此外我们看到最后当linkLayers没有匹配时，就抛出了一个异常，我们就来看看这个LinkLayers中有哪些类型public enum LinkLayers : ushort {    Null = 0,    Ethernet = 1,\t// ......    Ieee80211 = 105,    // ......    Ieee80211RadioTap = 127,    // ......    IPv4 = 228,    IPv6 = 229,\t// ......}可以看到其中包含了非常多的枚举类型，其中包含了常用的Ethernet（IEEE 802.3 以太网）和IEEE 802.11 无线网等，但是在ParsePacket方法中，这些类型并不是全部支持，因此要注意ParsePacket()支持哪些类型现在看完ParsePacket方法、RawCapture类和PcapCapture类，我们可以很自如地使用ParsePacket()private static void device_OnPacketArrival(object sender, PacketCapture p) {    try {        var packet = Packet.ParsePacket(packet.Device.LinkType, packet.Data.ToArray());        // 或者获取到RawCapture，调用GetPacket()，GetPacket()中调用了ParsePacket()        // var packet = p.GetPacket().GetPacket()                // 获取到的是Packet抽象类的子类对象，而packet的类型是Packet，因此需要类型转换        // 现在大多数接口都是以太网，因此直接转换为Ethernet        var ethernet = packet as Ethernent;            } catch (Exception ex) {        Console.WriteLine($\"{ex.Message}\");    }}Packet类在获取到链路层Packet后，我们要继续解析，就要使用Packet类中的属性和方法了，Packet类是PacketDotNet库中所有数据包类型的顶级抽象父类，因此研究清楚它，我们也就大概了解其他的包类型了Packet类的内容非常多，仓库源码有500多行，因此要抓住主线来研究它，分清主要矛盾和次要矛盾Extract方法在我们继续解析时，会调用一个叫Extract的方法，顾名思义，这是一个在Packet类型的包中提取内层数据包的方法（协议栈是一个层次结构），在旧版本中传入要提取的包实体类的类型，在6.3.0版本中，类型信息通过泛型传入，它的源码也非常简单public T Extract&lt;T&gt;() where T : Packet {    // 从当前层开始    var t = this;    while (t != null) {        // 若某个内层的实体类型和指定类型相同，则返回该层的实体对象        if (t is T packet)            return packet;                // 转到内层，即负载数据包        t = t.PayloadPacket;    }    return null;}该方法实现的提取有点类似于链表遍历，从当前层开始，每次循环判断该层是否是指定层，不是就跳转到下一层那么现在的关键就是弄清楚PayloadPacket是如何得到的PayloadPacket属性我们找到Packet类的PayloadPacket属性，它是PayloadPacketOrData字段的属性，下面给出源码，省略无关部分public abstract class Packet {    // ......        // (1)    protected LazySlim&lt;PacketOrByteArraySegment&gt; PayloadPacketOrData = new(null);        public virtual Packet PayloadPacket {    \tget =&gt; PayloadPacketOrData.Value.Packet;    \tset {            // (2)        \tif (this == value) {    \t\t\tThrowHelper.ThrowInvalidOperationException(                \tExceptionDescription.PacketAsPayloadPacket            \t);        \t}            // (3)        \tPayloadPacketOrData.Value.Packet = value;        \tPayloadPacketOrData.Value.Packet.ParentPacket = this;    \t}\t}        // ......}光是这两个属性，都有不少东西可以说，下面一点一点来说      PayloadPacketOrData初始化    这句在语法上用到了类型省略的new，已知声明类型时，构造对象可以省略new后面的类型，这里先设置为null    初始化时使用了LazySlim来包装，这实际上是PacketDotNet实现的用于实现延迟初始化的类，和Kotlin的Lazy一样    PayloadPacketOrData真正有意义的类型是PacketOrByteArraySegment，这是一个包装Packet对象和ByteArraySegment对象的容器，ByteArraySegment可以先看做一个字节数组，在后面会进行讲解。总的来说，PayloadPacketOrData字段表示当前Packet对象的负载，负载可能是一个Packet包，也可能是一个ByteArraySegment字节数组        不合法操作判断    在设置PayloadPacketOrData时，判断负载是否等于当前数据包，若相等，则抛出不合法操作异常，一个包中包含首部和负载，将包设置成负载自然是不合法的        设置PayloadPacketOrData    这里Value属性获取到PacketOrByteArraySegment对象，设置它的Packet属性为输入值，Packet的上一层包为当前数据包  接下来，我们看看与它相关的其他属性，大多是为了访问方便的只读属性，下面给出源码，省略无关和不重要部分public abstract class Packet {    // ......        // 判断当前包的负载是否是字节数组    public virtual bool HasPayloadData =&gt;         PayloadPacketOrData.Value.Type == PayloadType.Bytes;        // 判断当前包的负载是否是一个包    public virtual bool HasPayloadPacket =&gt;         PayloadPacketOrData.Value.Type == PayloadType.Packet;        // 延迟初始化判断PayloadPacketOrData是否已经初始化    public virtual bool IsPayloadInitialized =&gt; PayloadPacketOrData.IsValueCreated;        // PayloadPacketOrData的ByteArraySegment属性，与PayloadPacket类似    public ByteArraySegment PayloadDataSegment {    \tget {        \tif (PayloadPacketOrData.Value.ByteArraySegment == null) {            \tLog.Debug(\"returning null\");            \treturn null;        \t}        \tLog.DebugFormat(                \"result.Length: {0}\",                 PayloadPacketOrData.Value.ByteArraySegment.Length            );        \treturn PayloadPacketOrData.Value.ByteArraySegment;    \t}    \tset =&gt; PayloadPacketOrData.Value.ByteArraySegment = value;\t}    // ......}  顺带提一嘴，Packet类中有一个PrintHex方法，可以返回数据包的十六进制字节，可以用于调试ByteArraySegment在理解其他属性前，我们先来看看这个在之前出现过多次的类型ByteArraySegment，数据包的内容字节数组的解析很大程度上要归功于它在前面的讲解中，我们说ByteArraySegment可以看做一个字节数组，的确如此，那么它和普通的字节数组有什么不同呢，我们分成几个部分来分析它的源码，源码中去除了日志等无关内容，首先来看它的属性和构造器public sealed class ByteArraySegment : IEnumerable&lt;byte&gt; {    private int _length;    // 获取或设置在offset之后的字节数    public int Length {        get =&gt; _length;        set {            if (value &lt; 0) {                value = 0;            }            _length = value;        }    }        // 获取被包装的字节数组    public byte[] Bytes { get; }    // 设置或获取Bytes中允许处理的最大字节数，这可以控制NextSegment()产生的字节数    public int BytesLength { get; set; }    // 获取或设置Bytes中的偏移    public int Offset { get; set; }        // 构造器    public ByteArraySegment(byte[] bytes) : this(bytes, 0, bytes.Length) { }\tpublic ByteArraySegment(byte[] bytes, int offset, int length)     \t: this(bytes, offset, length, bytes.Length) { }\tpublic ByteArraySegment(byte[] bytes, int offset, int length, int bytesLength) {    \tBytes = bytes;    \tOffset = offset;    \tLength = length;    \tBytesLength = Math.Min(bytesLength, bytes.Length);\t}        public ByteArraySegment(ByteArraySegment byteArraySegment) {    \tBytes = byteArraySegment.Bytes;    \tOffset = byteArraySegment.Offset;    \tLength = byteArraySegment.Length;    \tBytesLength = byteArraySegment.BytesLength;\t}    // ......}其中最重要的就是属性，它们表示了字节数组的相关的长度、偏移等信息，依次看一下这些属性的含义  Bytes：存储被该类包装的字节数组，其他所有属性都是依赖它来设置  BytesLength：表示字节数组的长度，当它小于Bytes.Length时，以该属性的长度值为准  Offset：表示字节数组的一个偏移位置  _length/Length：表示Bytes[Offset, BytesLength)这一部分的长度我们画个图来明确这些属性表示的部分可以看到BytesLength才是表示实际可以处理的数组长度，包括在构造器中也有体现，BytesLength设置为bytesLength和bytes.Length的最小值。Offset表示在数组中的一个偏移，Length表示Offset之后的长度，数据包解析的首部和负载的划分就是归功于这两个属性，下面我们就来看看它是如何划分的public sealed class ByteArraySegment : IEnumerable&lt;byte&gt; {        public ByteArraySegment NextSegment() {    \tvar numberOfBytesAfterThisSegment = BytesLength - (Offset + Length);    \treturn NextSegment(numberOfBytesAfterThisSegment);\t}\tpublic ByteArraySegment NextSegment(int segmentLength) {    \tvar startingOffset = Offset + Length; // start at the end of the current segment    \t// ensure that the new segment length isn't longer than the number of bytes    \t// available after the current segment    \tsegmentLength = Math.Min(segmentLength, BytesLength - startingOffset);    \t// calculate the ByteLength property of the new ByteArraySegment    \tvar bytesLength = startingOffset + segmentLength;    \treturn new ByteArraySegment(Bytes, startingOffset, segmentLength, bytesLength);\t}}这个类中最重要的方法就是这个NextSegment()了，在讲解它的原理之前，我们先看看它在哪里使用到了在ParsePacket()中，若linkLayers匹配到Ethernet，则构造了一个EthernetPacket对象，而在EthernetPacket类的方法中，就使用到了NextSegment()public EthernetPacket(ByteArraySegment byteArraySegment) {\tHeader = new ByteArraySegment(byteArraySegment);\tHeader.Length = EthernetFields.HeaderLength;\tPayloadPacketOrData =         new LazySlim&lt;PacketOrByteArraySegment&gt;(() =&gt; ParseNextSegment(Header, Type));}internal static PacketOrByteArraySegment ParseNextSegment(ByteArraySegment header,                                                           EthernetType type) {    var payload = header.NextSegment();\t// ......    return payloadPacketOrData;}可以看到构造器中首先构造了一个ByteArraySegment赋值给Header，设置Header.Length为以太网首部的长度，之后下一句相当于将ParseNextSegment()的结果赋值给PayloadPacketOrData，在ParseNextSegment()中调用了NextSegment()。现在我们知道了NextSegment()在使用之前需要设置一下Length属性，并且是设置为首部长度，接下来我们具体看看NextSegment()中是如何划分的，以最开始构造EthernetPacket为例构造EthernetPacket时传入的ByteArraySegment中Bytes为整个数据包，Length和BytesLength都等于Bytes.Length，Offset为0，调用NextSegment()前设置Length = 14（以太网首部长度为14B)，如下图所示下面用画图来表示每一步中每个变量的位置      var startingOffset = Offset + Length;            segmentLength = Math.Min(segmentLength, BytesLength - startingOffset);            var bytesLength = startingOffset + segmentLength;    BytesLength不变        new ByteArraySegment(Bytes, startingOffset, segmentLength, bytesLength);      从上面的步骤我们可以看出，对于不同的片段，Length就是该片段的长度，例如对于首部，Length就是首部的长度，对于负载，Length就是负载的长度。那么Offset就起到一个索引的作用，Offset就是该片段在数组中的起始索引上面的例子是EthernetPacket类的特例，我们看看是不是所有的包都可以通过这个过程得到首部和负载的长度，并且Offset就是起始索引假设有下图所示的ByteArraySegment      设置首部Length    Offset就是该首部的起始索引            调用NextSegment()获取负载      可以看到我们依然获得了符合要求的ByteArraySegment对象构造网络层实体在研究NextSegment方法的使用时，我们看到在EthernetPacket类中有一个ParseNextSegment方法，它是用于解析下一层网络层，构造网络层实体的方法，同时它的返回值赋值给了PayloadPacketOrData，那么EthernetPacket的负载就是ParseNextSegment()中返回的网络层实体对象，下面来看看它的源码internal static PacketOrByteArraySegment ParseNextSegment (ByteArraySegment header,                                                            EthernetType type) {    // slice off the payload    var payload = header.NextSegment();    var payloadPacketOrData = new PacketOrByteArraySegment();    // parse the encapsulated bytes    switch (type) {        case EthernetType.IPv4: {            payloadPacketOrData.Packet = new IPv4Packet(payload);            break;        }        case EthernetType.IPv6: {            payloadPacketOrData.Packet = new IPv6Packet(payload);            break;        }        case EthernetType.Arp: {            payloadPacketOrData.Packet = new ArpPacket(payload);            break;        }        case EthernetType.Lldp: {            payloadPacketOrData.Packet = new LldpPacket(payload);            break;        }        case EthernetType.PppoeSessionStage: {            payloadPacketOrData.Packet = new PppoePacket(payload);            break;        }        case EthernetType.WakeOnLan: {            payloadPacketOrData.Packet = new WakeOnLanPacket(payload);            break;        }        case EthernetType.VLanTaggedFrame:        case EthernetType.ProviderBridging:        case EthernetType.QInQ: {            payloadPacketOrData.Packet = new Ieee8021QPacket(payload);            break;        }        case EthernetType.TransparentEthernetBridging: {            payloadPacketOrData.Packet = new EthernetPacket(payload);            break;        }        default: // consider the sub-packet to be a byte array        {            payloadPacketOrData.ByteArraySegment = payload;            break;        }    }    return payloadPacketOrData;}可以看到中间的部分就是判断type的类型来构造不同的网络层实体对象，包括IPv4、IPv6、ARP等，与Packet.ParsePacket方法是类似的结语数据包解析的基本原理目前先探究到这里，当然这只是冰山一角，但对于相关函数的基本使用已经是不成问题，如果以后还有机会或又遇到了什么问题，再来继续探究"
  },
  
  {
    "title": "Kotlin高级——集合",
    "url": "/posts/kotlin%E9%AB%98%E7%BA%A7-%E9%9B%86%E5%90%88/",
    "categories": "Kotlin, 高级篇",
    "tags": "Kotlin, Android",
    "date": "2024-03-10 23:13:00 +0800",
    





    
    "snippet": "开始kotlin将Map、Set和List都分为只读和可变两种类型，只读类型使用原始名称，可变类型带有Mutable前缀，可变类型在只读类型的基础上扩展了读写接口容器类图如下容器默认实现  MutableList：ArrayList  MutableSet：LinkedHashSet  MutableMap：LinkedHashMap自定义集合：kotlin提供了每种集合的抽象类，用于自定义...",
    "content": "开始kotlin将Map、Set和List都分为只读和可变两种类型，只读类型使用原始名称，可变类型带有Mutable前缀，可变类型在只读类型的基础上扩展了读写接口容器类图如下容器默认实现  MutableList：ArrayList  MutableSet：LinkedHashSet  MutableMap：LinkedHashMap自定义集合：kotlin提供了每种集合的抽象类，用于自定义集合实现  AbstractCollection  AbstractList  AbstractSet  AbstractMap元组容器Pair和Triple是kotlin内置的元组对象，Pair是二元组，Triple是三元组Pair和Triple都包含toXXX方法，将元组转换为其他数据类型Pair对于任意类型扩展了to方法，A.to(B)返回一个Pair&lt;A, B&gt;对象，to方法使用infix修饰，可以使用中缀表示集合创建集合创建方法      调用XXXOf函数：传入元素序列，不传入时创建空集合    val l = listOf(1, 2, 3, 4)val s = setOf(1, 2, 3, 4)val m = mapOf(1 to 2, 3 to 4) // map接收pair类型              listOf：使用默认实现，自动类型推断，当存在null时，返回可空类型，不存在时，返回非空类型      mutableListOf：listOf的可变类型      listOfNotNull：使用默认实现，自动类型推断，可接收可空类型，自动过滤null，返回非空类型      arrayListOf：使用具体实现，其余特性与listOf一致            调用buildXXX函数：传入一个闭包，可初始化容量    闭包接收者为集合的可变类型，通过可变类型修改容器，修改越界时会抛出异常        调用emptyXXX：创建空集合        调用具体实现的构造函数  集合转换、复制集合转换、复制方法      List和Set转换    List和Set调用toXXX可以任意地相互转换到它们的只读类型或可变类型，当list转换为set时会去除重复元素        map转换    List和Set无法直接转换为Map，Map只能转换为List，其中的元素为Pair对象    调用map.keys可以获取由key组成的set集合，调用map.values可以获取由value组成的Collection集合        转换拷贝    在调用toXXX进行转换时实际是创建了一个新对象且对元素进行浅拷贝，调用toXXX方法时可以调用同类型的toXXX方法，因此可以通过该方法实现拷贝  引用可变限制：由于可变类型是只读类型的子类，当可变类型集合被赋值给只读类型引用时，集合变为只读，通过可变类型引用也不能修改集合，此时只能将对象强转为可变类型迭代器可迭代对象接口为Iterable&lt;T&gt;，包含一个iterator方法返回一个Iterator对象迭代器接口为Iterator&lt;T&gt;，拥有两个方法  hasNext：判断是否有下一个元素  next：访问下一个元素对于List还实现了一个Iterator的子接口ListIterator，添加了方法实现反向迭代  hasPrevious：判断是否有上一个元素  previous：访问上一个元素  nextIndex：返回当前元素的下一个索引  previousIndex：返回当前元素的前一个索引可变迭代器对于可变类型，实现了一个MutableIterator子接口，包含一个remove方法，可以在迭代时删除元素对于List还实现了MutableListIterator子接口，添加了List的修改和添加方法val s = mutableSetOf(2, 3, 4)val iterator = s.iterator()iterator.next()  // 到达第一个元素iterator.remove()  // 删除2，[3, 4]iterator.next()  // 保持相对位置，next返回3序列序列是kotlin提供的另一种容器，用于集合流处理，类似java的Stream序列与集合的不同  集合是立即计算，在调用操作函数后立即计算返回结果，序列是惰性计算，调用操作后将操作记录下来，在调用终止操作时才进行计算  集合每一步计算都会创建新的对象，序列将所有步骤一次性执行，不会创建集合的副本中间对象  序列不支持集合的随机访问，序列是只读的，不支持元素修改和添加删除  集合的执行流是将一个操作对所有元素执行一次，序列的执行流是对一个元素执行一次所有操作序列创建      调用sequenceOf函数，传入元素序列        调用集合的asSequence函数，类似java中的stream方法        调用generateSequence函数，传入一个闭包作为元素生成函数，当生成函数返回null时，生成结束        调用sequence函数，传入一个闭包，闭包中只能调用yield和yieldAll函数，用于生成元素    与generateSequence的不同：generateSequence是将序列创建好后进入流操作，sequence函数是从生成元素就进入流操作，当操作下一个元素时generateSequence不会被调用，而sequence会被调用，由yield产生下一个操作的值，产生后sequence会被暂停    元素生成方法          yield：生成一个值      yieldAll：生成一个序列，传入集合或序列      集合操作集合的操作函数以成员函数或扩展函数存在，集合操作分为两类，公共操作和写操作，公共操作可用于只读集合和可变集合，写操作只能用于可变集合集合与序列在操作时的不同  对于集合，会创建集合的副本对象，因此当集合操作分步执行时，需要对返回的新对象进行操作  对于序列，会创建只记录操作信息的对象，可对原来操作的对象继续操作val list = listOf(1, 2, 3, 4)val filter = list.filter { it &gt; 2 }  // 操作返回一个新的对象fileter.forEach { println(it) }  // 对新对象继续操作// 错误写法val l = listOf(1, 2, 3, 4)l.fileter { it &gt; 2 }  // 操作返回的对象被丢弃l.forEach { println(it) }  // 对原来的list进行操作，filter没有执行集合操作详情见官方文档：集合操作概述 · Kotlin 官方文档 中文版 (kotlincn.net)"
  },
  
  {
    "title": "Kotlin高级——反射",
    "url": "/posts/kotlin%E9%AB%98%E7%BA%A7-%E5%8F%8D%E5%B0%84/",
    "categories": "Kotlin, 高级篇",
    "tags": "Kotlin, Android",
    "date": "2024-03-10 22:57:00 +0800",
    





    
    "snippet": "开始Kotlin反射依赖反射库实现implementation \"org.jetbrains.kotlin:kotlin-reflect:1.8.10\"Kotlin中可以直接使用java的反射，目前java反射的性能还是高于Kotlin，因此实际使用大多使用java反射有两种方式获取java的Class对象  javaClass字段  KClass的java字段kotlin反射与java反射...",
    "content": "开始Kotlin反射依赖反射库实现implementation \"org.jetbrains.kotlin:kotlin-reflect:1.8.10\"Kotlin中可以直接使用java的反射，目前java反射的性能还是高于Kotlin，因此实际使用大多使用java反射有两种方式获取java的Class对象  javaClass字段  KClass的java字段kotlin反射与java反射的类结构组成类引用kotlin中的KClass类对应java的Class类获取KClass类class Personval kClass: KClass&lt;Person&gt; = Person::class  // 使用类名引用val p = Person()// p可能是Person的子类，使用协变类型接收val objClass: KClass&lt;out Person&gt; = p::class  // 对象引用，获取到的是实际类型函数引用函数使用::引用，引用的类型为KFunctionfun say(a: String): Int {    return 0}val f0: KFunction&lt;Int&gt; = ::say// 成员函数引用class Person {    fun say(): Int = 0}val pf1: KFunction&lt;Int&gt; = Person::say属性引用属性使用::引用，引用类型为KPropertyval x = 20val x0: KProperty&lt;Int&gt; = ::x// 可变属性引用var y = 20val y0: KMutableProperty&lt;Int&gt; = ::y// 成员属性引用class Person {    val x = 20    var y = 20}val px1: KProperty&lt;Int&gt; = Person::xval py1: KMutableProperty&lt;Int&gt; = Person::y"
  },
  
  {
    "title": "Kotlin高级——高阶函数",
    "url": "/posts/kotlin%E9%AB%98%E7%BA%A7-%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/",
    "categories": "Kotlin, 高级篇",
    "tags": "Kotlin, Android",
    "date": "2024-03-10 22:42:00 +0800",
    





    
    "snippet": "开始高阶函数是将函数作为参数和返回值的函数，函数可以作为对象进行传递，函数对象的类型由参数和返回值表示，参数名可省略(Int, Int) -&gt; Int() -&gt; Unit // 最简单的函数// 一个函数对象也可以如下声明val method: (Int) -&gt; Int函数类型支持可空类型，支持嵌套，支持类型别名((Int, Int) -&gt; Unit)? // 可空类...",
    "content": "开始高阶函数是将函数作为参数和返回值的函数，函数可以作为对象进行传递，函数对象的类型由参数和返回值表示，参数名可省略(Int, Int) -&gt; Int() -&gt; Unit // 最简单的函数// 一个函数对象也可以如下声明val method: (Int) -&gt; Int函数类型支持可空类型，支持嵌套，支持类型别名((Int, Int) -&gt; Unit)? // 可空类型(Int) -&gt; ((Int) -&gt; Unit) // 嵌套表示(Int) -&gt; (Int) -&gt; Unit // -&gt;符号是右结合的typealias Handler = () -&gt; Unit // 类型别名函数类型实例化通过以下方式可以实例化一个函数类型，lambda表达式和匿名函数是函数字面量，通过invoke方法或使用调用操作符method()调用函数对象  lambda表达式  匿名函数  使用具名函数引用          顶层函数、局部函数、扩展函数：::method      成员方法：String::toInt      主构造器：::ClassName      匿名函数可以指定返回类型，返回类型推断与具名函数相同val f: (Int, Int) -&gt; Int = fun (a: Int, b: Int): Int {    return a + b}// 支持单表达式val h: (Int, Int) -&gt; Int = fun (a: Int, b: Int): Int = a + b// 支持类型推断，类型声明和返回值类型不可省略val m = fun (a: Int, b: Int): Int = a + blambda表达式val f: (Int, Int) -&gt; Int = {    // 参数写在括号内部，类型声明可以忽略    a: Int, b: Int -&gt; // 最后一个表达式作为返回值    // statement    // expression}// 支持类型推断，类型声明和返回值类型val h = {    a: Int, b: Int -&gt; a + b}简写语法  当lambda表达式是函数的最后一个方法时，lambda表达式传参可以放在括号外面  当函数只有lambda表达式一个参数时，函数的括号可以省略  当lambda表达式只有一个参数时，可以省略参数声明，使用隐式参数it  若lambda表达式中的参数未使用，在参数声明处使用_替代SAM函数式接口SAM：当接口中只有一个抽象方法时，接口称为函数式接口，函数式接口可以进行SAM转换interface Handler {    fun handle()}val handler: Handler = object : Handler {    override fun handle() {        // 匿名对象写法    }}// 函数式接口可以添加fun关键字，开启lambda表达式支持// 不是函数式接口添加fun关键字会编译错误fun interface Comsumer {    fun accept()}val consumer: Consumer = Consumer {    // Lambda表达式}函数字面量的接收者一个函数类型中可以带有接收者，表示指定接收者中的一个函数类型class Person {    // 该函数的接收者函数类型为Person.() -&gt; Unit    fun say() {    }}通过lambda和匿名函数两种字面量获取接收者函数// 在字面量内部，隐式传入了接收者引用this// 带有接收者时，lambda不支持类型推断，匿名函数支持类型推断，类型声明和返回值类型不可省略val f: Person.() -&gt; Unit = { say() }val m: Person.() -&gt; Unit = fun Person.(): Unit { say() }限定this表达式this默认指向最内层的作用域对象(类、扩展函数、带有接收者的函数字面量)，可以使用限定this表达式获取外部作用域的this，格式为this@label，由于类声明无法设置标签，因此通常使用隐式标签当调用this的属性和方法时，可以省略this，但存在同名顶层函数或顶层属性时，最好指定thisclass A {    inner class B {        // Int的扩展函数，接收者为Int        fun Int.foo() { // 隐式标签@foo            val a = this@A // A的this            val b = this@B // B的this            val c = this // foo()的接收者Int            val c1 = this@foo // foo()的接收者Int            // 带有String接收者的匿名函数字面量            val funLit = fun String.() {                val d = this // funLit的接收者String            }                        // 带有String接收者的lambda函数字面量            val funLit1: String.() -&gt; Unit = {                val d1 = this // funLit1的接收者String            }            val funLit2 = { s: String -&gt;                // foo()的接收者Int，因为它包含的lambda表达式没有任何接收者                val d2 = this            }        }    }}内联函数当一个函数接收一个lambda表达式作为参数，lambda表达式在调用时会产生一个函数对象，且会捕获闭包，当lambda表达式过多时性能开销较大，此时可以使用内联提升性能在需要传入lambda参数的函数上用inline关键字修饰，此时该函数称为内联函数直接returnjava的lambda表达式中支持return，本质是一个方法的返回kotlin的lambda表达式中不支持直接使用return，需要使用标签才能返回使用内联后，内联函数会将lambda表达式中的代码直接插入到调用处，减少了lambda表达式对象的创建，当lambda表达式中包含return时，return也会被内联到内联函数中，因此return是从内联函数中返回fun main() {    f {        println(\"lambda执行中\")        return    }}inline fun f(h: () -&gt; Unit) {    println(\"lambda调用前\")    h()    // lambda中的return被内联到调用处，直接return，该句不执行    println(\"lambda调用后\")}noinline关键字使用noinline关键字指定某个lambda表达式不进行内联，通常当传入的函数字面量作为函数对象使用时，不进行内联inline fun foo(inlined: () -&gt; Unit, noinline notInlined: () -&gt; Unit) {    // notInlined不进行内联}操作符重载使用operator关键字实现指定名称的成员函数或扩展函数，Kotlin只支持有限的几种操作符重载class OrdersList: IndexedContainer {    // 重载访问操作符    operator fun get(index: Int) {         // statements    }   }一元操作            表达式      翻译为                  +a      a.unaryPlus()              -a      a.unaryMinus()              !a      a.not()              a++      a.inc()              a--      a.dec()      二元操作            表达式      翻译为                  a + b      a.plus(b)              a - b      a.minus(b)              a * b      a.times(b)              a / b      a.div(b)              a % b      a.rem(b)              a..b      a.rangeTo(b)              a..&lt;b      a.rangeUntil(b)              a in b      b.contains(a)              a !in b      !b.contains(a)              a == b      a?.equals(b) ?: (b === null)              a != b      !(a?.equals(b) ?: (b === null))              a &gt; b      a.compareTo(b) &gt; 0              a &lt; b      a.compareTo(b) &lt; 0              a &gt;= b      a.compareTo(b) &gt;= 0              a &lt;= b      a.compareTo(b) &lt;= 0              a += b      a.plusAssign(b)              a -= b      a.minusAssign(b)              a *= b      a.timesAssign(b)              a /= b      a.divAssign(b)              a %= b      a.remAssign(b)      其他操作符            索引访问操作符      翻译为                  a[i]      a.get(i)              a[i, j]      a.get(i, j)              a[i_1, ……, i_n]      a.get(i_1, ……, i_n)              a[i] = b      a.set(i, b)              a[i, j] = b      a.set(i, j, b)              a[i_1, ……, i_n] = b      a.set(i_1, ……, i_n, b)                  invoke操作符      翻译为                  a()      a.invoke()              a(i)      a.invoke(i)              a(i, j)      a.invoke(i, j)              a(i_1, ……, i_n)      a.invoke(i_1, ……, i_n)      "
  },
  
  {
    "title": "Kotlin基础——函数",
    "url": "/posts/kotlin%E5%9F%BA%E7%A1%80-%E5%87%BD%E6%95%B0/",
    "categories": "Kotlin, 基础篇",
    "tags": "Kotlin, Android",
    "date": "2024-03-10 20:42:00 +0800",
    





    
    "snippet": "开始kotlin函数使用fun关键字声明，参数必须有类型声明fun function(arg: Int): Int {    return arg * 2}函数作用域：顶层函数、成员函数、局部函数kotlin支持顶层函数和顶层属性，也支持局部函数默认参数和具名参数函数参数可以使用默认参数，使用函数时可以使用具名参数指定参数值fun add(a: Int, b: Int = 10): Int ...",
    "content": "开始kotlin函数使用fun关键字声明，参数必须有类型声明fun function(arg: Int): Int {    return arg * 2}函数作用域：顶层函数、成员函数、局部函数kotlin支持顶层函数和顶层属性，也支持局部函数默认参数和具名参数函数参数可以使用默认参数，使用函数时可以使用具名参数指定参数值fun add(a: Int, b: Int = 10): Int {    return a + b}add(5, 10) // 正常调用add(5) // 使用b默认值add(a = 5, b = 10) // 具名参数调用add(a = 5) // 具名参数调用，使用b默认值当默认值参数在无默认值参数之前，无默认值参数只能通过具名参数调用fun add(a: Int, b: Int = 10, c: Int): Int {    return a + b + c}add(10, 5, c = 20) // 默认值参数和它之前的参数可以按顺序传值，默认值之后的参数必须具名参数传值UnitUnit类似于void，表示不需要返回值，若不指定返回值类型，默认为Unitfun method(): Unit {    // ...}fun method() { // 返回Unit    // ...}单表达式函数当一个函数中只有一个表达式时，可以简化语法fun add(a: Int, b: Int): Int = a + b// 当返回值类型可从表达式中推断时，可省略返回值类型fun add(a: Int, b: Int) = a + b// 函数代码块不支持返回值类型推断可变参数可变参数使用vararg关键字修饰，作为参数数组使用fun method(a: Int, vararg b: Int, c: Int) {    // statement}method(2, 3,4,5,6, c = 10) // 可变参数和它之前的参数按顺序传值，可变参数之后的参数必须具名参数传值中缀表示法使用infix关键字声明的函数可以使用中缀表达式形式，即a op b，等价于a.op(b)  函数必须是成员方法或扩展函数  函数必须只有一个参数  函数参数不能是可变参数，不能有默认值  当在类中需要使用当前类作为接收者时，接收者为thisclass Person {    infix fun say(content: String) {        println(content)    }}fun main() {    val person = Person()    // person称为接收者，\"Hello\"为参数    person say \"Hello\"}"
  },
  
  {
    "title": "Kotlin高级——泛型",
    "url": "/posts/kotlin%E9%AB%98%E7%BA%A7-%E6%B3%9B%E5%9E%8B/",
    "categories": "Kotlin, 高级篇",
    "tags": "Kotlin, Android",
    "date": "2024-03-10 20:25:00 +0800",
    





    
    "snippet": "开始泛型类class MyClass&lt;T&gt; {    fun method(t: T): T}泛型函数fun &lt;T&gt; method(t: T): T {    // statements}泛型约束用于约束泛型参数的上界，类似java的extends，默认的上界是Any?class Person&lt;T : String&gt;当类型需要多个上界时，使用where语句...",
    "content": "开始泛型类class MyClass&lt;T&gt; {    fun method(t: T): T}泛型函数fun &lt;T&gt; method(t: T): T {    // statements}泛型约束用于约束泛型参数的上界，类似java的extends，默认的上界是Any?class Person&lt;T : String&gt;当类型需要多个上界时，使用where语句，T类型必须同时继承/实现A类型和B类型class Person&lt;T&gt; where T : A, T : B类型擦除在Java和Kotlin中都有类型擦除，指的是在使用泛型时，泛型参数会在编译期间去除，也就是List&lt;T&gt;的泛型参数T会被擦除，List&lt;T&gt;就变成List，类中使用到泛型参数的地方都会被赋予类型随之带来一个问题，就是无法在运行时判断泛型参数的类型（Kotlin可以通过reified关键字实现），同时无法描述泛型参数的类型关系，其中一个例子是List&lt;Object&gt;不是List&lt;String&gt;的父类，这样的现象称为不变协变与逆变协变和逆变用于解决不变问题，二者统称为型变协变和逆变通常用在函数参数和返回值的类型声明上，用于扩展容器输入和输出的类型范围，并不能进行实际地转换，如果要实现类型转换，只能创建新对象，手动进行转换星投影：类似java的泛型通配符?，用于接收不确定的泛型信息，只能读取值（向外输出值），相当于&lt;out Any?&gt;      Java实现：使用extends实现协变，使用super实现逆变，只支持使用处型变    interface Collection&lt;T&gt; {    // 协变：向下扩展类型范围，只能安全读取，确保读取的都是T的子类    Collection&lt;? extends T&gt; method1();    void method2(Collection&lt;? extends T&gt; c);            // 逆变：向上扩展类型范围，只能安全写入，确保写入的都是T的子类    Collection&lt;? super T&gt; method3();    void method4(Collection&lt;? super T&gt; c);}            Kotlin实现：使用out实现协变，使用in实现逆变，支持声明处型变    // 使用处型变interface Collection&lt;T&gt; {    // 协变    fun method1(): Collection&lt;out T&gt;;    fun method2(c: Collection&lt;out T&gt;);            // 逆变    fun method3(): Collection&lt;in T&gt;;    fun method4(c: Collection&lt;in T&gt;);}    // 声明处型变interface Collection&lt;out T&gt; {    // T只支持协变    fun method1(): Collection&lt;T&gt;;    fun method2(c: Collection&lt;T&gt;);}interface Collection&lt;in T&gt; {    // T只支持逆变    fun method3(): Collection&lt;in T&gt;;    fun method4(c: Collection&lt;in T&gt;);}      协变逆变原理核心原理为一个父类引用可以无障碍地接收一个子类对象，协变和逆变都是基于这一点实现的容器泛型使用协变还是逆变，与它作为形参还是返回值是无关的，要看该容器的值的使用场景  当容器在消费场景时，容器需要被读取，因此外部需要使用一个父类引用接收读取值，因此容器泛型使用协变声明，确保容器内的值都是外部声明类型的子类，可以安全接收  当容器在生产场景时，容器需要被写入，因此容器内需要使用一个父类引用接收写入值，因此容器泛型使用逆变声明，确保写入值都是容器声明类型的子类，可以安全写入具体化泛型参数用于解决获取泛型参数的运行时类型问题获取泛型的运行时类型场景  序列化和反序列化  数据库操作  自定义注解  泛型类型检查kotlin和java在运行时会进行类型擦除，因此无法在运行时获取泛型的实际类型  java可以通过反射获取  kotlin使用reified+inline实现// inline+reifiedinline fun &lt;reified T&gt; TreeNode.findParentOfType(): T? {    var p = parent    // T 可以作为类型，用于检查和转换    while (p != null &amp;&amp; p !is T) {        p = p.parent    }    return p as T?}"
  },
  
  {
    "title": "Kotlin高级——委托",
    "url": "/posts/kotlin%E9%AB%98%E7%BA%A7-%E5%A7%94%E6%89%98/",
    "categories": "Kotlin, 高级篇",
    "tags": "Kotlin, Android",
    "date": "2024-03-10 20:25:00 +0800",
    





    
    "snippet": "开始委托模式是将一个对象的职责委托给其他对象完成，kotlin委托通过by关键字实现类委托将类中的方法委托到被委托对象实现interface Method {    fun method()}class MethodImpl : Method {    override fun method() {        // statement    }}// 委托类与被委托类实现同一接口clas...",
    "content": "开始委托模式是将一个对象的职责委托给其他对象完成，kotlin委托通过by关键字实现类委托将类中的方法委托到被委托对象实现interface Method {    fun method()}class MethodImpl : Method {    override fun method() {        // statement    }}// 委托类与被委托类实现同一接口class Person(method: Method) : Method by method {    // 委托类中自动生成了接口中的方法，并将调用转发给被委托对象        // 当委托类重写了接口方法时，调用委托类重写的方法    override fun method() {        // statement    }}属性委托在属性后使用by关键字加一个表达式，表达式返回被委托对象，将属性的定义委托给该对象管理属性的getter和setter被委托给这个对象的getValue和setValue方法(val属性只需提供getValue方法)class Person {    var name: String by Delegate()}class Delegate : ReadWriteProperty&lt;Person, String&gt; {    override operator fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): String {        return \"$thisRef, 这里委托了 ${property.name} 属性\"    }    override operator fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: String) {        println(\"$thisRef 的 ${property.name} 属性赋值为 $value\")    }}by-lazy延迟初始化是调用了lazy函数，lazy函数传入一个闭包，返回一个Lazy对象，属性定义由Lazy对象管理Lazy对象只实现了getValue方法，因此通常用于val属性的延迟初始化将属性委托到映射// Map为只读mapclass Person(val map: Map&lt;String, Any?&gt;) {    val name: String by map    val age: Int by map}// MutableMap为可变mapclass Student(val map: MutableMap&lt;String, Any?&gt;) {    var name: String by map    var age: Int by map}可观察属性kotlin的Delegates类的observable方法可以实现属性的观察者，observable方法传入一个初始值和一个观察者处理器闭包import kotlin.properties.Delegatesclass Person {    var name: String by Delegates.observable(\"initValue\") {        property, oldValue, newValue -&gt;         // statement    }}Delegates.notNull用于对一个非空var属性进行延迟初始化lateinit不支持原始类型，Delegates.notNull支持所有非空类型当属性委托给notNull后，若未进行初始化直接访问会抛出异常import kotlin.properties.Delegatesclass Person {   \tvar age: Int by Delegates.notNull&lt;Int&gt;()}自定义委托创建一个类作为被委托类，对于val属性，需要实现getValue操作符，对于var属性，需要实现setValue和getValue操作符  当属性为var时，被委托对象继承ReadWriteProperty，重写setValue和getValue  当属性为val时，被委托对象继承ReadOnlyProperty，重写getValueclass Delegate : ReadWriteProperty&lt;Person, String&gt; {    // thisRef：委托对象的引用，类型可以是委托对象类型或其父类型    // property：KProperty类型，存储属性的元数据    // 返回值：返回属性对应类型或其子类型    override operator fun getValue(thisRef: Person, property: KProperty&lt;*&gt;): String {        return \"$thisRef, 这里委托了 ${property.name} 属性\"    }\t// value：新值，必须是属性对应类型或其父类型    override operator fun setValue(thisRef: Person, property: KProperty&lt;*&gt;, value: String) {        println(\"$thisRef 的 ${property.name} 属性赋值为 $value\")    }}provideDelegate用于定义创建被委托对象时的逻辑通过provider委托时，优先调用provideDelegate，再调用getValue/setValueclass Person {    var name: String by DelegateProvider()}class Delegate : ReadWriteProperty&lt;Person, String&gt; {    override operator fun getValue(thisRef: Person, property: KProperty&lt;*&gt;): String {        return \"\"    }    override operator fun setValue(thisRef: Person, property: KProperty&lt;*&gt;, value: String) {        // statement    }}// 委托提供者class DelegateProvider {    operator fun provideDelegate(person: Person, property: KProperty&lt;*&gt;) : ReadWriteProperty&lt;Person, String&gt; {        // statement        return Delegate() // 返回一个委托对象    }}"
  },
  
  {
    "title": "Kotlin基础——类与对象",
    "url": "/posts/kotlin%E5%9F%BA%E7%A1%80-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/",
    "categories": "Kotlin, 基础篇",
    "tags": "Kotlin, Android",
    "date": "2024-03-09 19:33:00 +0800",
    





    
    "snippet": "开始使用class关键字声明一个类，类中包含构造器、初始化块、方法、属性、内部类class Obj // 创建一个空类kotlin中没有new关键字，直接使用函数形式创建对象var obj: Obj = Obj()访问修饰符kotlin的访问修饰符有public、protected、private、internal，可用于类、接口、属性、构造器、方法默认权限都为publicprivate和i...",
    "content": "开始使用class关键字声明一个类，类中包含构造器、初始化块、方法、属性、内部类class Obj // 创建一个空类kotlin中没有new关键字，直接使用函数形式创建对象var obj: Obj = Obj()访问修饰符kotlin的访问修饰符有public、protected、private、internal，可用于类、接口、属性、构造器、方法默认权限都为publicprivate和internal  private：在同一模块中可见，可跨文件  internal：只在同一文件中可见构造器kotlin的构造器分为主构造器和次构造器，当没有声明构造器时，kotlin会自动生成一个空参构造主构造器主构造器跟在类名之后class Person constructor(name: String, age: Int,) {    // 构造器参数列表可以使用尾部逗号}// 当主构造器没有注解以及访问修饰符(默认为public)时，constructor关键字可以省略class Person(name: String, age: Int,) {    // 主构造器中的参数可以直接在init块和属性初始化表达式中使用}init块：主构造器中不能包含代码，初始化代码可在init中编写，一个类中可以包含多个init块init块实际是主构造器的一部分，因此主构造器和init块先于次构造器执行class Person(name: String) {    init {        println(name)  // 可以直接使用参数    }}在构造器中传入的参数为形参，类中可以保存参数class Person(name: String) {    var name: String = name}// 可以直接在构造器参数列表中声明class Person(var name: String, val age: Int) {    // Person类拥有属性name    // age为只读属性}次构造器一个类中可以拥有多个次构造器，使用constructor关键字声明当类不存在主构造器时，一个次构造器可以委托给另一个次构造器class Person {    var name: String = \"\"    var age: Int = 0    var sex: String = \"\"    constructor(name: String) {        this.name = name    }    constructor(name: String, age: Int) {        this.name = name        this.age = age    }    // 委托给另一个构造器    constructor(name: String, age: Int, sex: String) : this(name, age) {        this.sex = sex    }}若类存在主构造器，则每个次构造器都需要委托给主构造器class Person(var name: String) {    var age: Int = 0  // 次构造器不能承担初始化的任务    // 每个次构造器必须委托到主构造器，通过this引用到指定构造器    constructor(name: String, age: Int) : this(name) {        this.age = age    }    // 通过其他次构造器间接委托到主构造器    constructor(name: String, age: Int, salary: Double) : this(name, age) {        // ...    }}属性定义kotlin中没有static关键字，属性支持访问修饰符、var、val修饰class Person(var name: String, var age: Int,) {    var id: String = \"$name:$age\"    // 只读属性，必须立即初始化或在init块中初始化    val realAge: Int = age}属性的初始化时机kotlin类中的每个属性必须进行初始化class Person(var name: String, var age: Int) {    // 直接赋值    var attr: String = \"value1\"        // 使用构造参数    var attr1: String = \"$name:$age\"        // init块    var attr2: String    init {        attr2 = \"value2\"    }        // lateinit延迟初始化    // 属性必须为var，属性不能是Int、Float、Double、Char、Boolean类型    lateinit var attr3: String    // 使用lateinit后可以在任何时候初始化，若在未初始化时访问，会抛出异常        // by-lazy延迟初始化    // 属性必须为val，在第一次访问属性时初始化    val attr4: String by lazy {        // ...        // expression    }}getter、setterkotlin会为每个属性自动生成默认的getter和setter，在访问属性obj.attr时自动调用getter和setter  val属性不允许有setter  在属性声明之后可以设置自定义getter  使用自定义getter后，属性不能通过lateinit和by-lazy进行初始化  getter的访问权限与属性的访问权限相同，setter的访问权限可单独设置class Person(var name: String, var age: String) {    var attr: String    \tget() {            // ...            return \"$age\"        }    \tset(value) {            // ...        }}幕后字段field：用于在getter和setter中使用当前字段的值class Person(var age: Int) {    var id: String = \"\"    \tget() {            return field        }    \tset(value) {            field = value        }        var id1: String    \tget() {            return id1 // 直接调用id1字段会自动调用getter，此时产生无限递归        }}  当只有自定义getter时          无论是否使用field，属性支持直接赋值和init块初始化        当只有自定义setter时          无论是否使用field，属性只支持直接赋值初始化        当自定义getter和setter都存在时          若getter和setter中都没有使用field，属性可以不初始化      否则，属性必须直接赋值初始化      简写getter：对于getter可以使用单表达式写法class Person(var name: String) {    var id: String = \"\"    \tget() = \"value\"  // expression}属性的类型推断：当属性的类型可以从赋值或简写getter中推断时，类型声明可以忽略class Person(var name: String) {    // 从直接赋值中推断    var age = \"\"    \tget() = field        // 从单表达式getter中推断    var age    \tget() = \"\"    init {        // 属性必须初始化        age = \"...\"    }        // 编译错误，只能从直接赋值和单表达式getter其中一个进行推断    var age = \"\"    \tget() = \"\"        // 语法错误，不存在field    var age    \tget() = field}继承kotlin的所有类都继承Any类，Any类相当于java的Object，但是对equals、hashCode、toString三个方法都进行了重写kotlin类默认为final类，不可继承，类属性默认为不可重载使用open关键字修饰一个类，使该类可以被继承当子类继承父类时，必须通过父类的构造器构造父类(主构造器和次构造器都可以)  当子类存在主构造器时，使用主构造器构造父类  当子类不存在次构造器时，将每个次构造器委托到父类的构造器构造父类open class Person(var name: String) {    }// 子类存在主构造器class Student(name: String) : Person(name) {    // 子类继承父类的name属性}// 子类不存在子构造器class Teacher : Person {    constructor(name: String) : super(name) {        // 委托到父类构造器    }}子类重写kotlin类属性默认为不可重写，子类不可声明父类的同名属性和同名方法在属性和方法声明时使用open关键字和override关键字开启重写open class Person(open var name: String) {    open fun say() {        // ...    }}class Student(override var name: String) : Person(name) {    override fun say() {        // ...    }}super泛型：用于选择父类或接口的实现open class A {    open fun f () { print(\"A\") }    fun a() { print(\"a\") }}interface B {    fun f() { print(\"B\") } //接口的成员变量默认是 open 的    fun b() { print(\"b\") }}class C : A() , B{    override fun f() {        super&lt;A&gt;.f()//调用 A.f()        super&lt;B&gt;.f()//调用 B.f()，接口默认实现    }}抽象类kotlin的抽象类与java类似，使用abstract关键字，无法实例化，构造器只能由子类调用abstract class Person {    abstract var age: Int    abstract fun say()}class Student : Person() {    override var age: Int = 0    override fun say()}接口kotlin接口与java接口类似，使用interface关键字  接口可以包含属性，属性是抽象的，实现类需要重写属性或在接口中为val属性提供getter  接口可以提供默认实现interface Listener {    val attr: String    var attr1: String    // getter只能用于val属性    val attr2: String    \tget() = \"value\"        fun method() {        // 接口默认实现    }}class Person : Listener {    override val attr: String = \"\"    override var attr1: String = \"\"}嵌套类与内部类嵌套类与内部类都是定义在一个类中的类，区别在于是否持有外部引用，嵌套类不持有外部引用，内部类持有外部引用class Outer {    private val bar: Int = 1    // 嵌套类    class Nested {        fun foo() = 2    }}class Outer {    private val bar: Int = 1    var v = \"成员属性\"    // 内部类    inner class Inner {        fun foo() = bar  // 访问外部类成员        fun innerTest() {            var o = this@Outer //获取外部类的成员变量            println(\"内部类可以引用外部类的成员，例如：\" + o.v)        }    }}数据类声明使用data关键字声明，编译器会自动生成equals、hashCode、toString、ComponentN和copy方法  数据类的主构造器必须包含至少一个参数  属性不能是open、abstract、sealed、inner编译器只会对主构造器中声明的属性生成方法，对在类体中声明的属性不会提供方法kotlin提供了Pair和Triple数据类data class Person(name: String, age: Int)解构声明能将一个对象中的属性同时解构为多个变量，该对象的类需要实现componentN操作符，编译器会将解构声明编译为componentN函数的调用解构声明中的参数可以声明类型，支持类型推断，解构声明如果存在不需要的变量，可以使用_替换class Person(var name: String, var age: Int) {    operator fun component1(): String = name    operator fun component2(): Int = age}fun main() {    val p = Person(\"hello\", 20)    val (name, age) = person    // 编译器根据解构参数列表调用调用对应位置的componentN函数    // 编译器将解构声明编译为以下代码    val name = person.component1()    val age = person.component2()}返回值解构可以在返回一个对象的地方使用解构声明替换for ((key, value) in map) {    // 对每个entry使用解构声明}// 数据类会自动生成componentN函数，可以用于返回值解构data class Result(val result: Int, val status: Status)fun function(): Result {    return Result(result, status)}val (result, status) = function()Lambda参数解构在lambda表达式的参数部分也可以使用解构声明，一个解构声明看做一个参数，类型声明与推断与一般参数相同map.mapValues { entry -&gt; \"${entry.value}!\" }map.mapValues { (key, value) -&gt; \"$value!\" }密封类使用sealed关键字声明，与枚举类类似，密封类的子类必须与密封类位于同一文件或者嵌套在密封类中密封类的子类可以拥有自己的属性和方法，可以看做是限制子类类型的抽象类或者扩展的枚举类，通常用于when匹配  Kotlin枚举类：与java枚举类相同，使用enum关键字声明sealed class Objclass SubClass1 : Obj() {    var attr: Int = 0}class SubClass2 : Obj() {    var attr: Int = 0}// 嵌套在密封类中sealed class Obj {    class SubClass1 : Obj() {        var attr: Int = 0    }    class SubClass2 : Obj() {        var attr: Int = 0    }}类型别名使用typealias关键字可以为类型、函数创建别名typealias NodeSet = Set&lt;Network.Node&gt;typealias FileTable&lt;K&gt; = MutableMap&lt;K, MutableList&lt;File&gt;&gt;函数别名typealias MyHandler = (Int, String, Any) -&gt; Unittypealias Predicate&lt;T&gt; = (T) -&gt; Boolean内部类和嵌套类别名class A {    inner class Inner}class B {    class Nest}typealias AInner = A.Innertypealias BNest = B.Nest对象表达式对象表达式用于创建一个匿名对象，使用object关键字，对象表达式中可以访问包含它的作用域中的变量若没有指定继承或实现，匿名对象继承Any类object : &lt;superClass&gt;|&lt;implementation&gt; {    // 对象体}对象声明使用object的对象声明可以实现单例模式，天然实现了线程安全和延迟初始化(懒汉式)对象声明也可以继承和实现接口object Singleton {    // 对象体}var s = Singleton  // 赋值引用Singleton.method()  // 直接引用伴生对象表示一个伴随着类的对象，在类加载时进行初始化，使用companion关键字声明每个类只能有一个伴生对象，伴生对象也可以继承或实现接口，他们依然是实例成员class Person {    // 匿名伴生对象    companion object {        // 对象体        fun method() {            // ...        }    }}class Student {    // 具名伴生对象    companion object Obj {        // 对象体        fun method() {            // ...        }    }}// 引用伴生对象Person.Companion.method()Student.Obj.method()// 省略伴生对象引用Person.method()Student.method()// 获取伴生对象，通过类名引用var p = Personvar s = Student扩展能在外部对一个类或接口扩展新的方法和属性，不需要继承或装饰器扩展函数class Personfun Person.say() {    // 扩展一个say方法    // 可以使用this，this指向Person类，this称为接收者}class Student&lt;T&gt;fun &lt;T&gt; Student&lt;T&gt;.study() {    // 扩展一个泛型方法}// 可空接收者fun Person?.say() {    // 可以为一个可空接收者扩展函数    // 此时this也是可空的，需要进行空判断}var p: Person = Person()var pn: Person? = Person()// 非空对象可以安全调用非空和可空的扩展函数p.say()p.speak()// 可空对象需要使用可空调用调用非空的扩展函数pn?.say()pn.speak()扩展函数静态解析：扩展函数的调用是静态解析的，根据代码的编写静态调用，与运行时无关，若通过一个父类引用调用子类的扩展函数，此时无法调用子类扩展函数，只能调用到父类扩展函数扩展属性扩展属性不能拥有幕后字段field，因此无法直接赋值初始化var Person.name: String    get() = \"\"    set(value) {        // ...    }val Person.age: Int    get() = 0伴生对象扩展类的伴生对象也支持扩展函数和扩展属性class Person {    companion object {}}fun Person.Companion.method() {    // ...}var Person.Companion.attr: Int    get() = 0    set(value) {}类声明扩展在一个类A中声明另一个类B，可以在类A中对类B进行扩展，类A称为分发接收者，类B称为扩展接收者class Bclass A {    var b: B = B()    // 扩展类B的属性和方法只能在类A中使用    var B.attr: Int        get() = 0        set(value) {}    fun B.say() {        // ...    }}分发接收者虚拟解析：分发接收者的扩展可设为open，由子类重写，子类对象调用扩展时，会使用子类重写的扩展open class Base { }class Derived : Base() { }open class BaseCaller {    open fun Base.printFunctionInfo() {        println(\"Base extension function in BaseCaller\")    }    // 静态解析不会调用    open fun Derived.printFunctionInfo() {        println(\"Derived extension function in BaseCaller\")    }    fun call(b: Base) {        b.printFunctionInfo()   // 调用扩展函数    }}class DerivedCaller: BaseCaller() {    override fun Base.printFunctionInfo() {        println(\"Base extension function in DerivedCaller\")    }    // 静态解析不会调用    override fun Derived.printFunctionInfo() {        println(\"Derived extension function in DerivedCaller\")    }}fun main() {    // call方法中使用的是Base类的扩展，静态解析后只会使用Base类的扩展    BaseCaller().call(Base())   // “Base extension function in BaseCaller”    // 子类重写了扩展，调用扩展时，使用的是子类重写的扩展    DerivedCaller().call(Base())  // “Base extension function in DerivedCaller”    DerivedCaller().call(Derived())  // “Base extension function in DerivedCaller”}"
  },
  
  {
    "title": "Kotlin基础——开始",
    "url": "/posts/kotlin%E5%9F%BA%E7%A1%80-%E5%BC%80%E5%A7%8B/",
    "categories": "Kotlin, 基础篇",
    "tags": "Kotlin, Android",
    "date": "2024-03-08 23:10:00 +0800",
    





    
    "snippet": "前言自从学习完Kotlin，一直想把学习过程中的笔记总结起来发一下，现在总算有时间整理一下以前的笔记了，Kotlin现在可以算是我最喜欢的一门语言了，简洁又优雅:heart_eyes::heart_eyes::heart_eyes:，Kotlin现在也正在发展成一门多平台语言，希望Kotlin越来越好:clap::clap::clap:（早日取代Java这个老古董）文章导航基础篇  基础语法...",
    "content": "前言自从学习完Kotlin，一直想把学习过程中的笔记总结起来发一下，现在总算有时间整理一下以前的笔记了，Kotlin现在可以算是我最喜欢的一门语言了，简洁又优雅:heart_eyes::heart_eyes::heart_eyes:，Kotlin现在也正在发展成一门多平台语言，希望Kotlin越来越好:clap::clap::clap:（早日取代Java这个老古董）文章导航基础篇  基础语法：Null safety is all you need.:yum::yum::yum:  类与对象：Kotlin基础中的基础，必看:exclamation::exclamation::exclamation:  函数：Kotlin基础中的基础，必看:exclamation::exclamation::exclamation:高级篇  泛型：JVM的通病？更加优雅的Kotlin:v::v::v:  高阶函数：Kotlin之精髓，It makes Kotlin Kotlin，必看:exclamation::exclamation::exclamation:  集合：实用之Kotlin:sunglasses::sunglasses::sunglasses:  委托：不常用的好设计？  反射：Kotlin的遗憾是什么？  协程：更好用的异步编程:sunglasses::sunglasses::sunglasses:"
  },
  
  {
    "title": "Kotlin基础——基础语法",
    "url": "/posts/kotlin%E5%9F%BA%E7%A1%80-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/",
    "categories": "Kotlin, 基础篇",
    "tags": "Kotlin, Android",
    "date": "2024-03-08 23:10:00 +0800",
    





    
    "snippet": "开始kotlin的主程序代码结构如下所示package com.example.kotlinimport ...fun main(args: Array&lt;String&gt;) {}kotlin代码文件后缀为.kt，kotlin文件不需要声明所处的包，没有指定包时，默认位于default包中kotlin已经默认导入了一些包，可以直接使用其中的静态函数kotlin支持多种注释// 单行注...",
    "content": "开始kotlin的主程序代码结构如下所示package com.example.kotlinimport ...fun main(args: Array&lt;String&gt;) {}kotlin代码文件后缀为.kt，kotlin文件不需要声明所处的包，没有指定包时，默认位于default包中kotlin已经默认导入了一些包，可以直接使用其中的静态函数kotlin支持多种注释// 单行注释/*多行注释*/变量可以使用var和val声明一个变量，变量类型接在冒号后面var a: Int = 3val b: Int = 5var用于声明可变变量，val声明不可变变量kotlin支持类型推断var a = 3 // a: Int数据类型kotlin中没有基本数据类型(primitive type)，所有类型都是对象      整数类型：Byte、Short、Int、Long，kotlin不支持八进制        浮点类型：Float、Double，小数字面量默认推断为Double    kotlin不支持小类型隐式转换为大类型(Float to Double)    kotlin中的数值数据类型不支持隐式类型转换，需要调用toXXX()方法显式转换        字符：Char，Kotlin中的Char与Int同样不能隐式类型转换        布尔：Boolean        字符串：String，String不可变，重载了[]获取其中的字符          多行字符串：使用三引号'''可以创建多行字符串      字符串模板：在字符串中可以使用$value，在字符串中填充value值，长的表达式用大括号括起来${}      JVM平台的基本类型对于基本类型，jvm平台类型为primitive-type(int,float,double,char,boolean)  当创建数值类型的可空引用或使用泛型时，kotlin会使用java的包装类来实现这些基本类型的可空类型(自动装箱为包装类)  当创建不可空引用时，kotlin会使用primitive-type数组kotlin中的数组都是Array类型，通过泛型指定类型，对于primitive-type，kotlin提供了相应的Array(IntArray、FloatArray等)，可以省去装箱开销。Array类型不支持协变kotlin中的数组自带一个size属性，以及重载了[]为getter和setter创建数组方法  arrayOf方法：传入可变参数  Array构造函数：传入数组大小和一个初始化函数闭包区间操作符和函数      in判断某个值是否在指定区间内，!in为非逻辑        ..操作符：定义一个正向区间，a..b表示[a,b]        until中缀函数：定义一个正向半开区间，a util b表示[a,b)        downTo中缀函数：定义一个反向区间，a downTo b表示[a,b]逆序        step中缀函数：由区间对象调用，设置区间对象的步进大小，返回一个XXXProgression对象    区间对象不存储步进信息，只表示范围，所以调用后会使用区间创建一个XXXProgression对象并设置步进  区间本质是一个ClosedRange&lt;T&gt;对象(对于原始类型，对应IntRange等类型，避免装箱)，其中包含一些操作方法区间操作符支持所有可比较类型，内部使用了比较运算符进行比较，比较运算符会转换为compareTo方法，因此对于自定义类型，需要实现Comparable接口。对于自定义类型，只支持..操作符当区间对象用于遍历时，使用的是区间对象的iterator方法获取一个迭代器，自定义类型区间对象没有iterator方法，因此需要自己实现自定义类型的迭代器比较运算符与java比较运算符类似，由于kotlin的类型都是对象，因此比较都是基于compareTo方法，当使用比较运算符时会自动转换为compareTo方法，对于自定义类型，可以实现Comparable接口相等运算符  ==：比较对象的值  ===：比较对象的地址NULL安全检查kotlin中的对象总体分为可空对象和不可空对象，默认为不可空对象，若要使用可空对象，需要在类型后添加?val a: Int = 20val b: Int? = null可空调用：对可空对象调用其方法和属性时需要显式声明var str: String?var length: Int? = str?.length // 当str为空时不调用返回null，length为可空对象强制为不可空var len: Int = str!!.length // 当str为空时会抛出NPE空判断赋值var len: Int = str?.length ?: -1 // 当?:前不为null时取前面的值，否则取后面的值在与Java互操作的实践中，私以为还是把从Java传到kotlin的对象全部看做可空类型比较好，因为无法保证Java传入的对象一定是非空的。要注意Java传入对象时，IDE可能会提示类型是非空的，这时还是需要按可空来处理（好一点的时候会提示为平台类型）类型转换与类型检查is运算符与空判断使用is运算符可以检查某个对象是否为某个类型在进行空判断后，对象会自动转换为不可空类型和可空类型var obj: Anyif (obj is String) {    // 使用is运算符后，在该块中，obj会自动转换为String}// 在块外部，obj依然是Any类型var obj1: String?if (obj1 == null) {    // 进行空判断后，obj1在该块中为可空类型}// 在块外会自动转换为不可空类型转换操作符as若两个类型具有继承关系时，子类对象可以直接赋值给父类引用，父类引用通过as关键字转换为子类引用val person: Person = Student()val student: Student = person as Student直接使用as操作符是不安全的，当person为可空类型并且值为null时，转换会失败，并且抛出NPEval person: Person? = Student()val student: Student? = person as Student?  // 转换为可空类型val student1: Student? = person as? Student  // 使用安全的转换操作符as操作符可以在导入同名类时，将其中一个类进行重命名，这个用到的地方不多可空与不可空原理kotlin的可空与不可空检查发生在编译时和运行时kotlin允许不可空对象赋值给可空引用，不允许可空对象赋值为不可空引用var a: Int = 10var b: Int? = a  // 编译通过var a: Int? = 10var b: Int = a  // 编译错误var b: Int = a ?: -1  // 空判断赋值当将一个不可空对象赋值给一个可空引用时，会将不可空对象的引用浅拷贝到可空引用，不会创建新的对象，这两个引用指向同一个对象(a === b = true)流程控制kotlin中几乎所有语句都可以作为表达式if语句if语句支持表达式，在每个分支中的最后一个表达式作为该分支的返回值当if作为表达式时，else分支必须存在val x = if (condition) value1 else value2val y = if (condition) {    println(...)    value1} else {    println(...)    value2}when语句// 与switch类似when(variable) {    value1 -&gt; {        // statement    }}// when语句可以作为表达式val x = when(variable) {    value1 -&gt; {        // statement        // expression    }    value2 -&gt; {        // statement        // expression    }    // 当when作为表达式，variable没有全部枚举时，必须添加else    else -&gt; {        // statement        // expression    }}// 多值匹配、表达式匹配、区间匹配、类型匹配when(variable) {    value1, value2 -&gt; {        // statement    }    // 表达式的返回值必须与variable类型相同    expression -&gt; {        // statement    }    in start..end -&gt; {        // statement    }    // 在该块中variable被自动转换为String    is String -&gt; {        // statement    }}// if-else形式// 此时when语句没有参数when {    // condition为布尔表达式    condition -&gt; {        // statement    }    else -&gt; {        // 必须有else语句    }}// 引入临时变量when (val v = expression) {    // 变量v只用于when块中    // ...}for语句kotlin的for循环为for-in，支持所有提供了Iterator的对象的遍历for (item in collection) {    // use item}// 数字区间遍历，i为隐式名称for (i in start..end) {    // statement}通过数组索引遍历集合for (i in arr.indices) {   \t// statement}for ((index, item) in arr.withIndex())控制关键字break和continue与java中的作用相同kotlin的任何表达式都可以设置一个标签，格式为label@，可以引用标签进行流程控制，引用格式为@label每个函数拥有一个同名的隐式标签，通常使用隐式标签，任何表达式都可以设置一个标签，但不一定能够引用它，没有设置标签时，通过隐式标签引用标签通常用于return、continue、break，但不是所有表达式都具有作用域并且能够返回，因此不是所有表达式的标签都能用于return、continue、breakbreak标签、continue标签loop@ for (i in 1..100) {    for (j in 1..100) {        break@loop        // continue@loop    }}return标签return默认从最内层的函数作用域和匿名函数中返回，使用标签可以返回到外部的作用域      普通函数/匿名函数：任何函数都可以使用标签进行返回return@label value，但不是所有函数都能设置自定义标签，只有能够作为表达式的函数才能设置标签，通常直接使用return    // 顶层函数，不是表达式fun f() {    return@f}// 成员函数，不是表达式class Person {    fun say() {        return@say    }}// 局部函数，可以设置标签fun outer() {    inter@ fun inter() {        return@inter    }}// 匿名函数，可以设置标签val f: () -&gt; Unit = unnamed@ fun () {    return@unnamed}            lambda表达式：lambda表达式不支持使用return从lambda中返回，因此要实现从lambda中返回需要使用标签    val f: () -&gt; Unit = f@ {    return@f  // 不使用标签直接return结束f所在的作用域无法实现，已经不允许直接使用return}      异常kotlin的所有异常类都是Throwable的子类，kotlin中同样有try-catch-finally，作用与java相同，kotlin的所有异常都是运行时异常try可作为表达式，表达式的类型为Nothingval x = try {    // statement    // expression} catch(Throwable e) {    // statement    // expression} finally {    // finally中不支持表达式返回值}Nothing类型通常表示一个函数永远不会返回或者一个集合为空// 直接抛出异常，函数永远没有返回值fun method(): Nothing {    throw ...}var list: List&lt;Nothing&gt; = listOf()"
  },
  
  {
    "title": "STL函数笔记",
    "url": "/posts/stl%E5%87%BD%E6%95%B0%E7%AC%94%E8%AE%B0/",
    "categories": "C/C++",
    "tags": "C/C++, STL",
    "date": "2024-03-08 20:08:00 +0800",
    





    
    "snippet": "前言本文对C++ STL标准模板库中的常用容器、算法等作一个总结，同时记录一些学习的要点，便于以后快速查阅容器  序列式容器：以线性排列存储某一类型的元素，元素都可序，但未必有序，不会自动按照值大小排序  关联式容器：容器中的元素结构为&lt;K, V&gt;键值对，通过键可访问到值，会进行自动按升序(或比较器)排序，一般结构为树或哈希表vectorvector，动态数组#include&l...",
    "content": "前言本文对C++ STL标准模板库中的常用容器、算法等作一个总结，同时记录一些学习的要点，便于以后快速查阅容器  序列式容器：以线性排列存储某一类型的元素，元素都可序，但未必有序，不会自动按照值大小排序  关联式容器：容器中的元素结构为&lt;K, V&gt;键值对，通过键可访问到值，会进行自动按升序(或比较器)排序，一般结构为树或哈希表vectorvector，动态数组#include&lt;vector&gt;// 构造vector&lt;int&gt; v; // 一个空的vector对象vector&lt;int&gt; v(v1); // 复制v得到新的vector对象vector&lt;int&gt; v(n); // 一个有n个元素的vector对象vector&lt;int&gt; v(n, value); // 一个有n个value值的vector对象vector&lt;int&gt; v(first, end); // 将first和end迭代器定义的序列复制到vector中// 基本操作v.front(); // 返回首元素v.back(); // 返回尾元素v.data(); // 返回指向首元素的指针v.at(n); // 返回v[n]，有边界检查v.push_back(value); // 向表尾插入value值v.size(); // 返回表长v.empty(); // 判断表是否为空v.pop_back(); // 删除表尾元素v.begin(); // 返回指向首元素的随机存取迭代器v.end(); // 返回指向表尾下一个位置的随机存取迭代器// 函数v.insert(iterator, value); // 向Iterator指向的位置前插入valuev.insert(iterator, n, value); // 向Iterator指向的位置前插入n个valuev.insert(iterator, first, last); // 向Iterator指向的位置前插入first-last序列v.erase(iterator); // 将Iterator指向的元素删除v.erase(first, last); // 删除first和last迭代器指定的序列v.reserve(n); // 预分配处存储n个元素的空间v.resize(n); // 改变表长为n，超出表长则删除，扩大则用默认值填满v.resize(n, value); // 改变表长为n，超出表长则删除，扩大则用value填满v.clear(); // 删除表中元素v.swap(v1); // v与v1交换v.assign(first, last); // 将v替换为first-last序列operator=; // 对vector对象赋值// 比较运算符重载按字典序比较值string字符串，一个字符的序列型容器#include&lt;string&gt;// 构造string s; // 一个空字符串string s(\"ABC\"); // 一个\"ABC\"字符串string s(\"ABC\", n, length); // 从ABC上下标n处截取length长度的字符串string s(\"ABC\", length); // 在ABC上从0开始截取length长度的字符串string s(str1); // 复制str1的字符串string s(str1, n); // 从str1[n]处开始截取的字符串string s(str1, n, length); // 从str1[n]处截取length长度的字符串string s(length, ch); // length长度由ch组成的字符串// 基本操作s.front(); // 返回首字符s.back(); // 返回尾字符s.data(); // 返回指向首字符的指针s.at(n); // 返回s[n]的字符，有边界检查s.begin(); // 返回首字符的迭代器s.end(); // 返回尾字符下一位的迭代器s.empty(); // 判断字符串是否为空s.size(); // 返回字符串长度s.capacity(); // 返回分配的对象能存储的字符数量s.push_back(ch); // 在字符串尾插入字符s.pop_back(); // 删除字符串尾的字符s.assign(str); // s赋值为str// 函数s.insert(iterator, length, ch); // 在Iterator之前插入length长度的字符chs.insert(n, str); // 在s[n]之前插入strs.insert(n, str, length); // 在s[n]之前的length长度插入str，长度大于str则用空格填充s.insert(n, length, ch); // 在s[n]之前插入length长度的字符chs.erase(n); // 删除从s[n]开始的字符串s.erase(n, length); // 删除s[n]开始length长度的字符串s.erase(iterator); // 删除Iterator指向的字符s.erase(first, last); // 删除first-last字符序列s.append(length, ch); // 后附length长度的字符chs.append(str); // 后附字符串strs.append(str, n, length); // 后附str[n, n + length)s.compare(str); // 比较s和strs.compare(n, length, str); // 比较s的子串[n, n + length)和strs.compare(n1, length1, str, n2, length2); // 比较s[n1, n1+length1)和str[n2, n2+length)s.starts_with(str); // 判断前缀是否是strs.starts_with(ch); // 判断前缀是否是chs.ends_with(str); // 判断后缀是否是strs.ends_with(ch); // 判断后缀是否是chs.clear(); // 清空字符串s.replace(n, length, str); // 将s[n, n + length)替换为strs.substr(n, length); // 返回s[n, n + length)s.copy(dest, length, n); // 复制s[n, n + length)到dests.resize(n); // 改变字符串长度为ns.resize(n, ch); // 改变字符串长度为n并用ch填充s.swap(str); // 交换两个字符串s.find(str); // 查找s中的str子串s.find(str, n, length); // 在s[n, n + length)中查找str子串s.find(ch); // 查找首个ch字符s.rfind(str); // 查找s中最后一个str子串s.rfind(str, n, length); // 查找s[n, n + length)中最后一个str子串s.rfind(ch); // 查找最后一个ch字符stoi(str, n, base); // 从str[n]处开始按base进制转换为十进制int值stol(str, n, base); // 从str[n]处开始按base进制转换为十进制long值stoll(str, n, base); // 从str[n]处开始按base进制转换为十进制long long值stof(str, n, base); // 从str[n]处开始按base进制转换为十进制float值stod(str, n, base); // 从str[n]处开始按base进制转换为十进制double值stold(str, n, base); // 从str[n]处开始按base进制转换为十进制long double值to_string(value); // 将value转换为字符串operator+=; // 后附字符或字符串operator+; // 字符或字符串拼接// 比较运算符重载按字典序比较字符串stack栈，先进后出，不支持迭代器#include&lt;stack&gt;// 构造// 第一个模板参数为元素类型// 第二个模板参数为底层容器类型，必须满足顺序容器(vector, deque, list)，默认为dequestack&lt;int&gt; s; // 一个空的int栈，底层为dequestack&lt;int, vector&lt;int&gt;&gt; s; // 一个空的int栈，底层为int型vectorstack&lt;int, vector&lt;int&gt;&gt; s(v); // 使用vector对象创建栈stack&lt;int&gt; s(s1); // 将s1复制创建栈// 基本操作s.top(); // 访问栈顶元素s.empty(); // 判断栈是否为空s.size(); // 返回栈的元素数s.push(value); // 将value插入到栈中s.pop(); // 弹出栈顶元素，不返回s.swap(s1); // 交换s和s1// 比较运算符重载按字典序比较stack中的值queue队列，先进先出，不支持迭代器#include&lt;queue&gt;// 构造// 第一个模板参数为元素类型// 第二个模板参数为底层容器类型，必须满足顺序容器(deque, list)，默认为dequequeue&lt;int&gt; q; // 一个空的int队列，底层为dequequeue&lt;int, vector&lt;int&gt;&gt; q; // 一个空的int队列，底层为int型vectorqueue&lt;int, vector&lt;int&gt;&gt; q(first, last); // 使用first-last序列创建队列queue&lt;int&gt; q(q1); // 将q1复制创建队列// 基本操作q.front(); // 访问队首元素q.back(); // 访问队尾元素q.empty(); // 判断队列是否为空q.size(); // 返回队长q.push(value); // 向队尾插入valueq.pop(); // 弹出队首元素，不返回q.swap(q1); // 交换q和q1// 比较运算符重载按字典序比较值deque双端队列，支持下标随机访问，可以在两端以常数时间插入和删除#include&lt;deque&gt;// 构造deque&lt;int&gt; dq; // 一个空的dequedeque&lt;int&gt; dq(n); // 一个有n个元素空间的dequedeque&lt;int&gt; dq(n, value); // 一个有n个value的dequedeque&lt;int&gt; dq(dq1); // 将dq1复制创建dq// 基本操作dq.at(n); // 返回dq[n]dq.front(); // 返回队首元素dq.back(); // 返回队尾元素dq.size(); // 返回队列长度dq.empty(); // 判断dq是否为空dq.begin(); // 返回首元素的迭代器dq.end(); // 返回队尾下一位的迭代器dq.push_back(value); // 将value插入到队尾dq.pop_back(); // 弹出队尾元素，不返回dq.push_front(value); // 将value插入到队首dq.pop_front(); // 弹出队首元素，不返回dq.clear(); // 清空队列// 函数dq.insert(iterator, value); // 在Iterator指向位置之前插入valuedq.insert(iterator, n, value); // 在Iterator指向位置之前插入n个valuedq.erase(iterator); // 删除Iterator处的元素dq.erase(first, end); // 删除first-end序列dq.resize(n); // 改变容器大小为ndq.resize(n, value); // 改变容器大小为n，多余处用value填充dq.assign(n, value); // 将dq赋值为n个valuedq.assign(first, last); // 将dq赋值为first-last序列// 比较运算符重载按字典序比较值listlist通常实现为双向链表，支持以常数时间进行插入和删除#include&lt;list&gt;// 构造list&lt;int&gt; l; // 一个空listlist&lt;int&gt; l(l1); // 将l1复制创建llist&lt;int&gt; l(n, value); // 创建n个value的listlist&lt;int&gt; l(first, last); // 用first-last序列创建一个list// 基本操作l.front(); // 返回首元素l.back(); // 返回尾元素l.begin(); // 返回指向首元素的迭代器l.end(); // 返回指向尾元素下一位的迭代器l.size(); // 返回表长l.empty(); // 判断表是否为空l.clear(); // 清空表l.push_back(value); // 在表尾插入valuel.pop_back(); // 弹出表尾元素l.push_front(value); // 在表头插入valuel.pop_front(); // 弹出表头元素// 函数l.insert(iterator, value); // 在Iterator处插入valuel.insert(iterator, n, value); // 在Iterator处插入n个valuel.erase(iterator); // 删除Iterator处的元素l.erase(first, last); // 删除first-last序列l.resize(n); // 改变表的大小为nl.resize(n, value); // 改变表的大小为n，多余处用value填充l.merge(l1); // 将两个排序链表按升序合并l.merge(l1, comparator); // 将两个排序链表按comparator比较函数排序l.sort(); // 将表按升序排序l.sort(comparator); // 将表按comparator比较函数排序l.swap(l1); // 交换l和l1l.splice(iterator, l1); // 将l中Iterator处的元素转移给l1l.remove(value); // 删除表中的value值l.reverse(); // 将l反转l.unique(); // 删除表中连续的重复元素，保留第一个// 比较运算符重载按字典序比较值set/multisetset自动对元素进行排序，键值对K与V相等，查找、插入、删除拥有O(logN)复杂度，通常实现为红黑树  set中元素唯一，不允许重复，若插入重复则不会插入  multiset元素可重复  元素类型是自定义类型，则需要仿函数指定排序规则，在创建时传入  unordered_set底层使用哈希表实现，插入/删除为O(1)复杂度#include&lt;set&gt;#include&lt;multiset&gt;// 构造set&lt;int&gt; s; // 一个空的setset&lt;int&gt; s(s1); // 将s1复制创建sset&lt;int&gt; s(first, last); // 用first-last序列创建setset&lt;int, comparator&gt; s; // 按给定比较器创建set// 基本操作s.begin(); // 返回首元素迭代器s.end(); // 返回尾元素下一位迭代器s.empty(); // 判断set是否为空s.size(); // 返回set元素数s.clear(); // 清空sets.swap(s1); // 交换s和s1s.find(key); // 返回键为key的元素的迭代器s.contains(key); // 判断set中是否有键为key的元素s.count(key); // 返回键为key的元素数量// 函数s.insert(value); // 插入values.insert(first, last); // 插入first-last序列s.erase(iterator); // 删除Iterator处的元素s.erase(first, last); // 删除first-last序列s.erase(key); // 删除键为key的元素s.equal_range(key); // 返回键为key的元素的范围(迭代器对)s.lower_bound(key); // 返回首个键不小于key的元素的迭代器s.upper_bound(key); // 返回首个键大于key的元素的迭代器s.key_comp(); // 返回用于比较键的函数s.value_comp(); // 返回用于比较值的函数s.merge(s1); // 将s和s1合并// 比较运算符重载按字典序比较值pairpair，表示一对数据#include&lt;iostream&gt;// 构造pair&lt;int, int&gt; p; // 一个空对pair&lt;int, int&gt; p(value1, value2); // 一个value1和value2的数据对pair&lt;int, int&gt; p(p1); // 用p1创建p// 基本操作p.first; // 数对的首元素p.second; // 数对的第二个元素// 函数make_pair(value1, value2); // 创建value1和value2的数对// 比较运算符重载按字典序比较map/multimapmap中存储键值对&lt;K, V&gt;并自动进行排序，查找、插入、删除拥有O(logN)复杂度，通常实现为红黑树  map键值唯一，multimap键值不唯一  元素类型是自定义类型，需要仿函数指定排序规则  unordered_map底层使用哈希表实现#include&lt;map&gt;#include&lt;multimap&gt;// 构造map&lt;int, int&gt; m; // 一个空的mapmap&lt;int, int&gt; m(first, last); // 用first-last序列创建mapmap&lt;int, int&gt; m(m1); // m1复制创建mmap&lt;int, int, comparator&gt; m; // 用给定比较器创建map// 基本操作m.at(key); // 访问键为key的值operator[]; // 下标访问键为key的值m.begin(); // 返回首元素的迭代器m.end(); // 返回尾元素的迭代器m.empty(); // 判断map是否为空m.size(); // 返回map中的元素数m.clear(); // 清空mapm.count(key); // 返回键为key的元素数量m.swap(m1); // 将m和m1交换m.find(key); // 返回键为key的元素的迭代器m.contains(key); // 判断map中是否包含键为key的元素// 函数m.insert(pair); // 插入pairm.insert(first, last); // 插入first-last序列m.erase(iterator); // 删除Iterator处的元素m.erase(first, last); // 删除first-last序列m.equal_range(key); // 返回键为key的元素范围的迭代器对m.lower_bound(key); // 返回首个键不小于key的元素的迭代器m.upper_bound(key); // 返回首个键大于key的元素的迭代器m.key_comp(); // 返回用于比较键的函数m.value_comp(); // 返回用于比较值的函数m.merge(m1); // 将m与m1合并算法STL库中提供的工具函数，基于容器的迭代器进行操作#include&lt;algorithm&gt;// 不修改序列的操作all_of(first, last, predicate); // 判断predicate对[first-last]每个元素是否都为trueany_of(first, last, predicate); // 判断predicate对[first-last]每个元素是否至少有一个为truenone_of(first, last, perdicate); // 判断predicate对[first-last]每个元素是否都不为truefor_each(first, last, function); // 对first-last序列每个元素应用functionfor_each_n(first, n, function); // 对first开始的前n个元素应用functioncount(first, last, value); // 返回first-last序列中等于value的元素数count_if(first, last, predicate); // 返回predicate对first-last序列中返回true的元素数mismatch(first1, last1, first2); // 返回[first1, last1)和[first2, last)的首个不匹配项的迭代器对mismatch(first1, last1, first2, last2);// 返回[first1, last1)和[first2, last2)的首个不匹配项的迭代器对mismatch(first1, last1, first2, predicate);// 返回[first1, last1)和[first2, last)的首个predicate为false项的迭代器对mismatch(first1, last1, first2, last2, predicate);// 返回[first1, last1)和[first2, last2)的首个predicate为false项的迭代器对find(first, last, value); // 返回[first, last)中首个等于value项的迭代器find_if(first, last, predicate); // 返回[first, last)中首个predicate为true项的迭代器find_if_not(first, last, predicate); // 返回[first, last)首个predicate为false项的迭代器find_end(first1, last1, first2, last2);// 返回[first1, last1)中[first2, last2)最后一次匹配处的迭代器find_end(first1, last1, first2, last2, predicate);// 返回[first1, last1)中[first2, last2)最后一次predicate对每个元素为true处的迭代器find_first_of(first1, last1, first2, last2);// 返回[first1, last1)中首个与[first2, last2)元素相等的元素的迭代器find_first_of(first1, last1, first2, last2, predicate);// 返回[first1, last1)中首个与[first2, last2)元素predicate为true的元素的迭代器adjacent_find(first, last);// 返回[first, last)中首个相邻的重复元素的迭代器adjacent_find(first, last, predicate);// 返回[first, last)中首个相邻的predicate为true的元素的迭代器search(first1, last1, first2, last2);// 返回[first1, last1)中子序列[first2, last2)首次出现处的迭代器search(first1, last1, first2, last2, predicate);// 返回[first1, last1)中子序列[first2, last2)首次predicate为true处的迭代器search_n(first, last, n, value);// 返回[first, last)中n个等于value的序列的迭代器search_n(first, last, n, value, prediacate);// 返回[first, last)中n个predicate对元素与value为true的序列的迭代器// 修改序列的操作copy(first1, last1, first2);// 复制[first1, last1)到开始于first2的另一范围copy_if(first1, last1, first2, predicate);// 复制[first1, last1)中predicate为true的元素到开始于first2的另一范围copy_n(first1, n, first2);// 复制开始于first1的n个元素到开始于first2的另一范围copy_backward(first1, last1, last2);// 复制[first1, last1)到终于last2的另一范围(从后往前复制)fill(first, last, value); // 将value赋值给[first, last)fill_n(first, n, value); // 将开始于first的n个元素赋值为valuetransform(first1, last1, first2, unaryFunction);// 将一元函数unaryFunction应用到[first1, last1)并存储结果到开始于first2的范围transform(first1, last1, first2, output, binaryFunction);// 将二元函数应用到[first1, last1)和开始于first2的范围并存储结果到开始于output的范围generate(first, last, function);// 将function生成的值赋值给[first, last)generate_n(first, n, function);// 将function生成的值赋值给开始于first的n个元素remove(first, last, value);// 移除[first, last)中等于value的元素remove_if(first, last, predicate);// 移除[first, last)中predicate为true的元素remove_copy(first1, last1, first2, value);// 复制[first1, last1)到开始于first2的范围，忽略等于value的元素remove_copy_if(first1, last1, first2, predicate);// 复制[first1, last1)到开始于first2的范围，忽略predicate为true的元素replace(first, last, oldValue, newValue);// 替换[first, last)所有等于oldValue的元素replace_if(first, last, predicate, newValue);// 替换[first, last)所有predicate为true的元素replace_copy(first1, last1, first2, oldValue, newValue);// 复制[first1, last1)到开始于first2的范围并替换原序列等于oldValue的元素replace_copy_if(first1, last1, first2, predicate newValue);// 复制[first1, last1)到开始于first2的范围并替换原序列中predicate为true的元素swap(x, y); // 交换x和yswap_ranges(first1, last1, first2); // 交换[first1, last1)和开始于first2的范围iter_swap(first, second); // 交换first和second指向的元素reverse(first, last);// 反转[first, last)reverse_copy(first1, last1, first2);// 复制[first1, last1)到开始于first2的范围并将新序列逆序rotate(first1, first2, last1);// 对[first1, last1)进行左旋转，满足旋转后first2处成为新范围的首元素rotate_copy(first1, first2, last1, output);// 将[first1, last1）复制到开始于output的范围并左旋转，满足first2处成为新范围的首元素unique(first, last);// 删除[first, last)中的连续重复元素，保留第一个unique(first, last, predicate);// 删除[first, last)中连续predicate为true的元素，保留第一个unique_copy(first1, last1, first2);// 复制[first1, last1)到开始于first2的范围并删除连续重复元素，保留第一个unique_copy(first1, last1, first2, predicate);// 复制[first1, last1)到开始于first2的范围并删除连续predicate为true的元素，保留第一个next_permutation(first, last);// 修改first-last序列为字典序中当前序列的下一个序列prev_permutation(first, last);// 修改first-last序列为字典序中当前序列的上一个序列// 划分操作is_partitioned(first, last, predicate);// 判断[first, last)中predicate为true的元素是否都在predicate为false元素之前partition(first, last, predicate);// 将[first, last)中predicate为true的元素排在predicate为false的元素之前partition_copy(first1, last1, first2, first3, predicate);// 将[first1, last1)中predicate为true的元素复制到first2范围，为false的元素复制到first3范围stable_partition(first, last, predicate);// 将[first, last)中predicate为true的元素排在predicate为false的元素之前，保持相对顺序partition_point(first, last, predicate);// 定位划分范围[first, last)中首个predicate为false的元素// 排序操作is_sorted(first, last); // 判断序列是否为升序is_sorted(first, last, comparator); // 判断序列是否符合比较器排序is_sorted_until(first, last); // 查找序列中的最大已排序子序列is_sorted_until(first, last, comparator); // 查找序列中最大符合比较器排序的子序列sort(first, last); // 将序列按升序排序sort(first, last, comparator); // 将序列按比较器顺序排序stable_sort(first, last); // 稳定排序stable_sort(first, last, comparator); // 按比较器顺序稳定排序partial_sort(first, middle, last);// 将[first, last)中已排序的最小元素重排到[first, middle)partial_sort(first, middle, last, comparator);// 将[first, last)中按比较器排序的最小元素重排到[first, middle)partial_sort_copy(first1, last1, first2, last2);// 将[first1, last1)排序结果存储到[first2, last2)，不改变原序列// 二分查找操作(已升序排序范围)lower_bound(first, last, value);// 返回序列中首个大于或等于value的元素的迭代器upper_bound(first, last, value);// 返回序列中首个大于value的元素的迭代器binary_search(first, last, value);// 在序列中二分查找valuemerge(first1, last1, first2, last2, output);// 将[first1, last1)和[first2, last2)合并存储到output范围// 集合操作(已排序范围)includes(first1, last1, first2, last2);// 判断[first1, last1)是否是[first2, last2)的子序列set_difference(first1, last1, first2, last2, output);// 取两个已排序序列的差集并复制到开始于output的范围set_intersection(first1, last1, first2, last2, output);// 取两个已排序序列的交集并复制到开始于output的范围set_union(first1, last1, first2, last2, output);// 取两个已排序序列的并集并复制到开始于output的范围// 最大/最小操作max(x, y); // 返回x, y的较大者max_element(first, last); // 返回序列中最大元素min(x, y); // 返回x, y的较小者min_element(first, last); // 返回序列中的最小元素minmax_element(first, last); // 返回序列中的最大和最小元素_gcd(x, y); // 返回x, y的最大公因子accumulate(first, last, val); // 将first-last序列求和，val为初值，返回值与val类型相同// 比较操作equal(first1, last1, first2);// 判断两个序列是否相等equal(first1, last1, first2, last2);// 判断两个序列是否相等equal(first1, last1, first2, predicate);// 判断两个序列predicate是否为trueequal(first1, last1, first2, last2, predicate);// 判断两个序列predicate是否为truelexicographical_compare(first1, last1, first2, last2);// 判断[first1, last1)是否按字典序小于[first2, last2)迭代器迭代器是容器与算法之间的中介，迭代器可以看做指针，支持类似指针的操作迭代器操作通用迭代器操作  *it：访问当前迭代器指向的元素  it1 == it2：判断迭代器相等  it1 != it2：判断迭代器不相等不同类型的迭代器支持不同的操作  前向迭代器：前向访问，支持自增操作  双向迭代器：双向访问，支持自增自减操作  随机迭代器：随机访问，支持迭代器移动任意单位访问  输入迭代器：只支持前向访问读取  输出迭代器：只支持前向访问写入迭代器获取通常通过容器提供的以下函数来获取迭代器  begin()/end()：迭代器类型T::iterator，前向访问，可读写  cbegin()/end()：迭代器类型T::const_iterator，前向访问，可读不可写  rbegin()/rend()：迭代器类型T::reverse_interator，反向访问，可读写  crbegin()/crend()：迭代器类型T::const_reverse_interator，反向访问，可读不可写  begin(T)/end(T)：C++11工具方法，支持数组的迭代器访问迭代器失效以下两种情况会导致迭代器失效  对于序列型容器，修改元素不会导致迭代器失效，插入或删除可能导致迭代器失效  对于关联型容器，修改、插入、删除都可能导致迭代器失效仿函数      仿函数又称为函数对象，是一个实行函数功能的类，该类必须重载函数调用运算符(operator())    函数对象可以有自己的状态，如记录函数调用次数，是否允许调用  可以作为参数传递class MyComparator {public:    bool operator()(int x, int y) const {        return x &gt; y;    }};谓词：返回bool型的仿函数称为谓词。参数列表含有一个参数，称为一元谓词，含有两个参数，称为二元谓词内建仿函数STL中提供的一些仿函数，主要用于条件判断和基本运算#include&lt;functional&gt;// 算术仿函数template&lt;class T&gt; plus&lt;T&gt;; // x + ytemplate&lt;class T&gt; minus&lt;T&gt;; // x - ytemplate&lt;class T&gt; multiplies&lt;T&gt;; // x * ytemplate&lt;class T&gt; divides&lt;T&gt;; // x / ytemplate&lt;class T&gt; modulus&lt;T&gt;; // x % ytemplate&lt;class T&gt; negate&lt;T&gt;; // -x// 比较仿函数template&lt;class T&gt; equal_to&lt;T&gt;; // x == ytemplate&lt;class T&gt; not_equal_to&lt;T&gt;; // x != ytemplate&lt;class T&gt; greater&lt;T&gt;; // x &gt; ytemplate&lt;class T&gt; less&lt;T&gt;; // x &lt; ytemplate&lt;class T&gt; greater_equal&lt;T&gt;; // x &gt;= ytemplate&lt;class T&gt; less_equal&lt;T&gt;; // x &lt;= y// 逻辑仿函数template&lt;class T&gt; logical_and&lt;T&gt;; // x &amp;&amp; ytemplate&lt;class T&gt; logical_or&lt;T&gt;; // x || ytemplate&lt;class T&gt; logical_not&lt;T&gt;; // !x"
  },
  
  {
    "title": "KMP代码实现详解",
    "url": "/posts/KMP%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E8%AF%A6%E8%A7%A3/",
    "categories": "算法",
    "tags": "算法, KMP",
    "date": "2024-03-08 00:00:00 +0800",
    





    
    "snippet": "前言在考研时学会了KMP算法的手算，没有深究它的算法实现（主要是也不咋考），今天在LeetCode上刷到KMP的题目，在此记录一下代码实现的理解相关LeetCode题目  28. 找出字符串中第一个匹配项的下标 - 力扣（LeetCode）  459. 重复的子字符串 - 力扣（LeetCode）KMP算法KMP算法主要就是两步  使用模式串生成next数组（本文使用的是next[0]=-1...",
    "content": "前言在考研时学会了KMP算法的手算，没有深究它的算法实现（主要是也不咋考），今天在LeetCode上刷到KMP的题目，在此记录一下代码实现的理解相关LeetCode题目  28. 找出字符串中第一个匹配项的下标 - 力扣（LeetCode）  459. 重复的子字符串 - 力扣（LeetCode）KMP算法KMP算法主要就是两步  使用模式串生成next数组（本文使用的是next[0]=-1的版本）  使用next数组对匹配串进行匹配以下称模式串为P，匹配串为S，P[i]表示P的第i个字符，从0开始，S同理Talk is cheap. Show me the code. 直接上代码/** * 生成next数组 * @param next next数组 * @param p 模式串 */void getNext(int* next, const string&amp; p) {    int i = 0;    int j = -1;    next[i] = j;    while (i &lt; p.size() - 1) {        if (j == -1 || p[i] == p[j]) {            next[++i] = ++j;        } else {            j = next[j];        }    }}/** * KMP匹配 * @param s 匹配串 * @param p 模式串 * @return 匹配子串的下标 */int kmp(string&amp; s, string&amp; p) {    int i = 0;    int j = 0;    int s_len = s.size();    int p_len = p.size();    while (i &lt; s_len &amp;&amp; j &lt; p_len) {        if (j == -1 || s[i] == p[j]) {            i++;            j++;        } else {            j = next[j];        }    }    return j == p_len ? i - j : -1;}算法过程以LeetCode第28题为例生成next数组首先说明函数中的定义      i：扫描P的主要指针，从0递增到字符串长度，不会减小        j：用于查找最长重合前后缀的指针，扫描时随i递增，查找前后缀时回退减小        next[l]=k：表示长度为l的子串p[0, l - 1]，它的最长重合前后缀的长度为k    注意，在序列型的结构中，长度同时代表了索引，这一点在后面会用到  我们按照代码的执行一遍，使用的模式串p=\"abac\"void getNext(int* next, const string&amp; p) {    int i = 0;    int j = -1;    next[i] = j;    while (i &lt; p.size() - 1) {        if (j == -1 || p[i] == p[j]) {            next[i + 1] = j + 1;            i++;            j++;            // 与next[++i] = ++j等价，为后续便于讲解        } else {            j = next[j];        }    }}      i = 0, j = -1, p[i] = a    j == -1判断为true，令next[++i]=++j，即next[1] = 0        i = 1, j = 0, p[i] = b, p[j] = a    p[i] == p[j]判断为false，令j = next[j]，即j = -1        i = 1, j = -1, p[i] = b    j == -1判断为true，next[2] = 0        i = 2, j = 0, p[i] = a, p[j] = a    p[i] == p[j]判断为true，next[3] = 1        i = 3退出循环，得到next = {-1, 0, 0, 1}  Case1：p[i] = p[j]我们首先研究p[i] == p[j]判断为true，执行next[i + 1] = j + 1的情况从上述过程中，首先可以看出只有在修改next数组时，i才递增，则next的填入是随着i的递增进行的。执行next[i + 1] = j + 1表示将长度为i + 1的子串的最长重合前后缀长度设置为j + 1，那么p[i]实际就是长度为i + 1的子串的最后一个字符(注意之前提到的长度同时代表了索引)比如next[2]表示[0, 1]的长度为2的子串，而填入之前i = 1，p[1]就是该子串的最后一个字符i还有另一个意义，它指向子串后缀的最后一个字符，这应该很好理解，i指向子串的最后一个字符，自然就是子串后缀的最后一个字符现在弄清楚p[i]和next[i + 1]的关系之后，我们再来看看p[j]是什么算法中始终是将j + 1的值赋给next，而next的值表示子串的最长重合前后缀长度，则j + 1表示最长重合前后缀长度，同样地，赋值前的j表示的就是重合前后缀的最后一个字符下标，p[j]就是重合前缀的最后一个字符现在我们来画个一般情况的图，i和j的指向如图所示现在我们要填入next[i + 1]，那么考虑p[0, i]的子串，即图中红框标出的子串假设next[i + 1] = j + 1成功执行，那么就表示长度为i + 1的子串的最长重合前后缀长度为j + 1，此时j指向重合前缀的最后一个字符，也就表示p[0, j]为重合的前缀，那么重合的后缀就是p[i - j, i]，即图中黄框的部分那么现在来看看为什么要比较p[i]和p[j]如上述，j指向前缀的最后一个字符，i指向后缀的最后一个字符，那么现在我们要填入next[i + 1]，就只需要比较前后缀的最后一个字符，就可以判定前后缀是否重合，为什么不需要比较前面的字符呢，这里包含了一个递归的思想，实际上前面的字符在填入next[0]到next[i]时已经比较过了这种情况实际上是一种比较理想的情况，下面就这种情况举个例子模式串p=\"aaaa\"      i = 0, j = -1, p[i] = a    j == -1判断为true，p[0, 0] = “a”，前缀为p[0, -1]，重合前后缀长度为0，next[1] = 0        i = 1, j = 0, p[i] = a, p[j] = a    p[i] == p[j]判断为true，p[0, 1] = “aa”，前缀为p[0, 0]，重合前后缀长度为1，next[2] = 1        i = 2, j = 1, p[i] = a, p[j] = a    p[i] == p[j]判断为true，p[0, 2] = “aaa”，前缀为p[0, 1]，重合前后缀长度为2，next[3] = 2        i = 3退出循环，得到next = {-1, 0, 1, 2}  和上一个例子比较可以看出，相同长度的字符串，这种情况执行的循环次数会少一点，主要是少在没有执行j = next[j]这一步，下面我们看看这一步如何理解Case2：p[i] != p[j]要执行j = next[j]，实际上就是满足j != -1 &amp;&amp; p[i] != p[j]当p[i] != p[j]时，说明当前比较的前缀和后缀的最后一个字符不相同，也就是当前比较的前后缀不重合，既然不重合，我们就需要查找一个位置使得前后缀重合，j = next[j]就是那个查找的步骤next[j]的值是长度为j的子串的最长重合前后缀长度。这里需要理解两个信息，一个是长度为j的子串，当我们调用next[j]时，我们的视角就应该放到p[0, j - 1]的子串上了，也就是之前比较的前缀（不包含最后一个字符）。另一个是j = next[j]，这一句实际上就是定位到p[0, j - 1]这个子串中的重合前后缀的最后一个字符的下一个字符（模糊点理解就是定位到前缀的前缀，j回退一步），如下图所示图中绿框的部分就是上一次循环比较的前缀，假设蓝框部分该前缀内的重合前后缀，当前循环执行j = next[j]后，在下一次循环中，我们比较p[i]和p[j]，若p[i] = p[j]，那么绿框部分就是当前红框子串的重合前后缀（因为蓝框部分重合，下一个字符还相等，那么继续重合）Case3：j = -1结合前面的讲解，这种情况应该很好理解了。当i刚开始遍历时，i = 0，p[0, i]只有一个字符，自然重合前后缀长度为0，next[1] = j + 1 = 0之后就是j回退到退无可退时，前缀没有重合的前后缀了，那么重合前后缀的长度自然也是0，next[i] = j + 1 = 0KMP匹配匹配算法相比next数组生成算法更加直观一些，我们直接开始算法过程测试用例：p = \"abac\", s = \"abaababac\"生成的next = {-1, 0, 0, 1}int kmp(string&amp; s, string&amp; p) {    int i = 0;    int j = 0;    int s_len = s.size();    int p_len = p.size();    while (i &lt; s_len &amp;&amp; j &lt; p_len) {        if (j == -1 || s[i] == p[j]) {            i++;            j++;        } else {            j = next[j];        }    }    return j == p_len ? i - j : -1;}      i = 0, j = 0    s[i] = p[j] = a, i++, j++        i = 1, j = 1    s[i] = p[j] = b, i++, j++        i = 2, j = 2    s[i] = p[j] = a, i++, j++        i = 3, j = 3    s[i] = a, p[j] = c, j = next[3] = 1        i = 3, j = 1    s[i] = a, p[j] = b, j = next[1] = 0        i = 3, j = 0    s[i] = a, p[j] = a, i++, j++        i = 4, j = 1    s[i] = b, p[j] = b, i++, j++        i = 5, j = 2    s[i] = a, p[j] = a, i++, j++        i = 6, j = 3    s[i] = b, p[j] = c, j = next[3] = 1        i = 6, j = 1    s[i] = b, p[j] = b, i++, j++        i = 7, j = 2    s[i] = a, p[j] = a, i++, j++        i = 8, j = 3    s[i] = c, p[j] = c, i++, j++        i = 9, j = 4    退出循环，j == p_len成功匹配，第一个匹配的下标为i - j  上述过程的正向比较很好理解，关键在于j = next[j]回退这一步，与之前next数组的生成有异曲同工之妙我们来看过程中的第9步，如下图所示上图中s[i]和p[j]不匹配时，前面的部分是比较过且匹配的，此时考虑next[j]表示的模式子串（蓝框部分）和对应的匹配子串（绿框部分），模式子串的重合前后缀的长度就是next[j]的值，next[3] = 1，则图中左下红框部分是模式子串的重合前缀，紫框部分就是与它重合的后缀，同时由于模式子串与匹配子串相等（绿框部分和蓝框部分相同），所以两个子串的重合后缀相等（紫框部分和右上红框部分相等），最终得到模式子串的重合前缀和匹配子串的重合后缀相等（两个红框部分相等）。令j = next[j]，得到重合前缀的下一个字符位置，下次从该位置开始比较，从而跳过之前重合的部分，这是KMP匹配的精髓KMP的应用生成next数组算法在LeetCode 459题有一个应用（459. 重复的子字符串 - 力扣（LeetCode））题目为给定一个非空的字符串s，检查是否可以通过由它的一个子串重复多次构成对于任意由子串重复多次构成的字符串，它必然有重合的前后缀，这是第一个必要条件，我们使用next数组来判断这个必要条件，若整个字符串的最长重合前后缀长度不为0，则存在重合前后缀通过上述讲解我们知道next[i]表示p[0, i - 1]的最长重合前后缀长度，那么我们想得到整个字符串的最长重合前后缀长度，就是求next[len]（len为整个字符串长度）。这里相对原来的算法，我们需要把循环条件改为i &lt; p.size()，多遍历最后一个字符，我们要求整个字符串的前后缀，自然要包含所有的字符，下面是这一部分的代码// 生成next数组void getNext(int* next, const string&amp; p) {    int i = 0;    int j = -1;    next[0] = -1;    // 原算法的循环条件为i &lt; p.size() - 1    while (i &lt; p.size()) {        if (j == -1 || p[i] == p[j]) {            next[++i] = ++j;        } else {            j = next[j];        }    }}// 解法bool repeatedSubstringPattern(string s) {    int len = s.size();    // 字符串为空，直接返回false    if (len == 0) return false;    // 求next[len]，长度需要多一位    int next[len + 1];    getNext(next, s);    // 判断next[len] != 0，可知是否满足必要条件一}我们已经判断了字符串中是否有重复的子串，现在来判断字符串是否是这个子串重复构成的比较直接的想法就是求出整个字符串中重复的子串，然后遍历比较，但有更简单的做法。如果一个字符串是这个子串重复构成的，那么字符串的长度一定是子串长度的整数倍，这个就是判定重复构成的第二个必要条件。这样就够了吗？这样确实够了，这里实际上运用到了next数组的性质，next数组的值表示的子串是最长的重合前后缀，我们使用next数组求出这个重复子串的长度，举两个例子，输入s1 = \"abababab\"和s2 = \"ababcdab\"显然两个串的长度相等，s1符合题目要求，s2不符合要求。我们考虑这两个串的最长重合前后缀，s1的最长重合前后缀是“ababab”，s2的最长重合前后缀是“ab”，若直接使用这个最长前后缀的长度判断它是否被字符串长度整除，那么s1会被判为false，s2判为true，这明显不符合题目要求。实际上只需要用字符串长度减去最长前后缀长度就可以得到重复的子串长度，妙就妙在这一点对于符合重复构成的字符串都是满足的，而其他字符串都是不满足的。下面给出解法的完整代码// 生成next数组void getNext(int* next, const string&amp; p) {    int i = 0;    int j = -1;    next[0] = -1;    // 原算法的循环条件为i &lt; p.size() - 1    while (i &lt; p.size()) {        if (j == -1 || p[i] == p[j]) {            next[++i] = ++j;        } else {            j = next[j];        }    }}// 解法bool repeatedSubstringPattern(string s) {    int len = s.size();    // 字符串为空，直接返回false    if (len == 0) return false;    // 求next[len]，长度需要多一位    int next[len + 1];    getNext(next, s);    // 判断next[len] != 0，可知是否满足必要条件一：存在重复的子串    // 判断len % (len - next[len]) == 0，可知是否满足必要条件二：字符串的长度是重复子串长度的整数倍    // len - next[len]就是重复子串的长度    if (next[len] != 0 &amp;&amp; len % (len - next[len]) == 0) {        return true;    }    return false;}结语KMP匹配的代码还是比较难理解的，其中关键是弄清i和j什么时候表示索引，什么时候表示长度，其次是要有递归的思想，理解j回退的原理，这两点弄清楚，KMP算法就算掌握了在理解next数组的基础上，可以灵活改变算法，用它求出我们想要的子串的最长重合前后缀，再利用最长重合前后缀的性质进行应用"
  },
  
  {
    "title": "WinPcap教程Demo总结",
    "url": "/posts/WinPcap%E6%95%99%E7%A8%8BDemo%E6%80%BB%E7%BB%93/",
    "categories": "C/C++",
    "tags": "WinPcap, C/C++",
    "date": "2024-03-07 00:00:00 +0800",
    





    
    "snippet": "前言最近学习了WinPcap，对教程中的Demo做一些函数说明补充官方中文文档：WinPcap: WinPcap 中文技术文档 (redicecn.com)Demo1: 获取接口列表  pcap_findalldevs_ex函数：获取接口列表  pcap_freealldevs(pcap_if_t*)：释放接口列表资源 int pcap_findalldevs_ex(     char *s...",
    "content": "前言最近学习了WinPcap，对教程中的Demo做一些函数说明补充官方中文文档：WinPcap: WinPcap 中文技术文档 (redicecn.com)Demo1: 获取接口列表  pcap_findalldevs_ex函数：获取接口列表  pcap_freealldevs(pcap_if_t*)：释放接口列表资源 int pcap_findalldevs_ex(     char *source,  // 使用的接口，PCAP_SRC_IF_STRING：网络接口，PCAP_SRC_FILE_STRING：文件接口     struct pcap_rmtauth *auth,  // 用户认证，默认null     pcap_if_t **alldevs,  // 接口链表头指针     char *errbuf  // 错误信息缓冲区     // return：-1表示错误 );pcap_if_t结构体是pcap_if的typedef，相关类型定义如下 // 接口表项 struct pcap_if {     struct pcap_if *next;  // 下一个接口     char *name;     // 接口名 name to hand to \"pcap_open_live()\"     char *description;  // 接口描述 textual description of interface, or NULL     struct pcap_addr *addresses;  // 该接口的地址列表     bpf_u_int32 flags;  // PCAP_IF_ interface flags };  // 接口地址表项 struct pcap_addr {     struct pcap_addr *next;     // sockaddr是通用地址类型，可表示IPv4、IPv6等地址     struct sockaddr *addr;      // 网络地址     struct sockaddr *netmask;   // 子网掩码     struct sockaddr *broadaddr; // 当前地址对应的广播地址     struct sockaddr *dstaddr;   // 当前地址的P2P目的地址 };  // sockaddr定义 struct sockaddr {     u_short sa_family;  // 地址类型，AF_INET表示IPv4，AF_INET6表示IPv6     char    sa_data[14];  // 地址数据 }; // sockaddr特定变种，可将sockaddr强转为以下两种 // IPv4地址 struct sockaddr_in {     short   sin_family;  // AF_INET 表示 IPv4     u_short sin_port;  // 端口号     struct in_addr  sin_addr;  // IPv4地址     char    sin_zero[8]; }; // IPv6地址 struct sockaddr_in6 {     short sin6_family;     u_short sin6_port;     u_long sin6_flowinfo;     struct in6_addr sin6_addr;     __C89_NAMELESS union {         u_long sin6_scope_id;         SCOPE_ID sin6_scope_struct;     }; };上述结构的关系如下图所示，一个接口可以拥有多个网络地址，都是以链表形式连接Demo2：获取接口高级信息对每个pcap_if对象打印其中的所有信息  name：接口名  description：接口描述  flags：flags &amp; PCAP_IF_LOOPBACK，判断是否是环回地址  addresses：pcap_addr地址列表IPV4地址转换字符串 /**  * @param in 32位整数地址  * @return 点分十进制字符串 */ char* ipv4_to_s(u_long in) {     // 12个字符串，每个字符串最大为4个3位数+3个点+null     static char output[12][3 * 4 + 3 + 1];     static short which;     u_char *p;      // IP地址表示为32位整数(u_long)，将其转换为u_char，就是将in按8位拆分，并得到首字节的指针     p = (u_char*) &amp;in;     which = (which + 1) % 12;     sprintf(output[which], \"%d.%d.%d.%d\", p[0], p[1], p[2], p[3]);     return output[which]; }IPv6地址转换字符串 /**  * @param sockaddr 地址项对象  * @param address 地址缓冲区  * @param addrlen 缓冲区长度  * @return 地址字符串 */ char* ipv6_to_s(struct sockaddr* sockaddr, char* address, int addrlen) {     socklen_t sockaddr_len = sizeof(struct sockaddr_in6);      /**      * 调用getnameinfo将IPV6地址转换为字符串      * @param sa sockaddr结构体，表示通用网络地址      * @param salen sockaddr结构体大小      * @param host 存储主机名的缓冲区指针      * @param hostlen 主机名缓冲区大小      * @param serv 存储服务名(端口号)缓冲区指针      * @param servlen 端口号缓冲区大小      * @param flags NI_NUMERICHOST：主机名转换为数字形式，NI_NUMERICSERV：服务名转换为数字形式      * @return 0 执行成功      */     if (getnameinfo(sockaddr, sockaddr_len, address, addrlen,                     nullptr, 0, NI_NUMERICHOST) != 0) {         address = nullptr;     }      return address; }Demo3：打开接口捕获数据包打开接口  pcap_open：打开接口  pcap_close(pcap_t*)：关闭接口 // 打开接口 pcap_t *pcap_open(     const char* source,  // 接口名，pcap_if.name     int snaplen,  // 截断长度，即捕获的数据包长度，单位B，捕获全部数据包设为65535     int flags,  // 默认只捕获发送给该接口的包，设置混杂模式捕获全部数据包，PCAP_OPENFLAG_PROMISCUOUS     int read_timeout,  // 超时时间     struct pcap_rmtauth *auth, // null     char* errbuf  // 错误信息缓冲区     // return pcap_t pcap结构体的typedef，表示已打开接口的描述符 );该函数返回的pcap_t结构是后续操作该接口的描述符，pcap结构体对用户不可见，由wpcap.dll维护，一个可能的描述（cite. winpcap - What structure pcap_t have? - Stack Overflow） struct pcap {     int fd;     int snapshot;     int linktype;     int tzoff;      /* timezone offset */     int offset;     /* offset for proper alignment */      struct pcap_sf sf;     struct pcap_md md;      /*      * Read buffer.      */     int bufsize;     u_char *buffer;     u_char *bp;     int cc;      /*      * Place holder for pcap_next().      */     u_char *pkt;       /*      * Placeholder for filter code if bpf not in kernel.      */     struct bpf_program fcode;      char errbuf[PCAP_ERRBUF_SIZE]; };捕获数据包打开接口后，调用pcap_loop捕获数据包，同时还有pcap_dispatch也可捕获数据包，两者参数相同两者的不同在于pcap_loop在超时时，如果未捕获到数据包，会使进程阻塞，因而可以持续捕获，而pcap_dispatch在超时时会直接返回，不能持续捕获 int pcap_loop(     pcap_t* handle,  // 打开接口描述符     int cnt,  // 捕获数据包的数量，0或负数时持续捕获     pcap_handler handler,  // 捕获数据包的回调函数     u_char* param  // 传递到回调函数的第一个参数param，     // return 成功捕获的数据包数量 );  // pcap_handler定义 void packet_handler(     u_char* param,  // pcap_loop传递的参数     const struct pcap_pkthdr* header,  // 包元数据     const u_char* pkt_data  // 包内容，字节数组 );  // 元数据定义 struct pcap_pkthdr {     struct timeval ts;  // 时间戳     bpf_u_int32 caplen; // 分组长度(成功捕获的长度)     bpf_u_int32 len;    // 包长度 };Demo4：非回调捕获包使用pcap_next_ex捕获一个数据包 int pcap_next_ex(     pcap_t* handle,  // 打开接口描述符     struct pcap_pkthdr**  header,  // 包元数据      const u_char** pkt_data  // 包内容     /**       * @return       * 1：捕获成功      * 0：超时失败      * -1：捕获失败，发生异常，可通过pcap_geterr(handle)获取错误信息      * -2：获取到离线记录文件的最后一个报文(EOF)     */ );Demo5：过滤数据包  pcap_compile：编译过滤表达式  pcap_setfilter：为捕获会话设置一个过滤器 int pcap_compile(     pcap_t* handle,  // 打开的接口描述符     struct bpf_program* bpf,  // 存储编译后的过滤器程序     const char* str,  // 过滤表达式     int optimize,  // 是否优化，1：优化，0：不优化     bpf_u_int32 net_mask  // 子网掩码     // return 0：成功 );  int pcap_setfilter(     pcap_t* handle,  // 打开的接口描述符     struct bpf_program* bpf  // 过滤器程序     // return 0：成功 );Demo6：UDPdump主流程  获取接口列表  选择接口，获取pcap_if  pcap_open打开接口，获取描述符handle  pcap_datalink检查接口的数据链路层类型，DLT_EN10MB为以太网  pcap_compile编译过滤表达式为bpf_program  pcap_setfilter设置handle的过滤器  pcap_freealldevs释放接口列表  pcap_loop开始捕获回调处理流程  通过pcap_pkthdr结构获取元数据，打印时间戳等信息      将pkt_data解析出IP首部和UDP首部    处理流程主要是对捕获到的字节数组进行解析，通常的做法就是先定位到要解析的部分的首地址，然后将指针强转为其他类型，指针强转就是改变指针指向的单位，换句话说，就是不同类型的指针移动时以不同的单位进行移动，改变指针类型就是改变指针移动的步长，当指针指向解析部分首地址时，改变指针类型为解析类型，就可以得到解析部分的完整结构了     /* 获得IP数据包头部的位置 */ ip_header* ip = (ip_header*)(pkt_data + 14); // 以太网头部长度，单位B      /* 获得UDP首部的位置 */ // ip-&gt;ver_ihl &amp; 0xf获取低4位值，即ihl // 首部长度单位4B，ihl * 4 = IP首部长度字节数 u_int ip_len = (ip-&gt;ver_ihl &amp; 0xf) * 4; // ip指针转为字节表示，ip + ip_len = IP包数据部分第一字节，再转为udp_header*，得到UDP首部 udp_header* udp = (udp_header*)((u_char*)ip + ip_len);      /* 将网络字节序列转换成主机字节序列 */ // 获取源端口和目的端口并转换，主机字节序和网络字节序不一定相同 sport = ntohs(udp-&gt;sport); dport = ntohs(udp-&gt;dport); // 类似有ntohl, htons，htonl      /* 打印IP地址和UDP端口 */ printf(\"%d.%d.%d.%d:%d -&gt; %d.%d.%d.%d:%d\\n\",        ip-&gt;saddr.byte1,        ip-&gt;saddr.byte2,        ip-&gt;saddr.byte3,        ip-&gt;saddr.byte4,        sport,        ip-&gt;daddr.byte1,        ip-&gt;daddr.byte2,        ip-&gt;daddr.byte3,        ip-&gt;daddr.byte4,        dport);      Demo7：处理脱机堆文件保存堆文件将捕获的数据包数据保存到文件中  pcap_dump_open：创建并打开堆文件，通常文件名为*.pcap  pcap_dump：将数据包写入堆文件 pcap_dumper_t* pcap_dump_open(     pcap_t* handle,  // 打开接口描述符     const char* filename  // 写入文件路径，注意Windows中相对路径相对于.exe文件     // return 打开的堆文件描述符，pcap_dumper的typedef );  void pcap_dump(     u_char* param,  // 堆文件描述符，将pcap_dumper_t强转得到，回调时通过param参数传递     const struct pcap_pkthdr* pkt_header,  // 数据包header     const u_char* pkt_data  // 数据包内容 );读取堆文件  pcap_createscrstr：根据参数生成一个描述接口的source字符串，可用于创建文件接口，使用pcap_open打开，pcap_loop捕获  pcap_open_offline：专用于打开文件接口 int pcap_createsrcstr(     char* source,  // 存储souce字符串的缓冲区     int type,  // source字符串类型，     const char* host,  // 远程主机名     const char* port,  // 远程端口号     const char* name,  // 接口名称，打开文件接口即文件名     char* errbuf  // 错误信息缓冲区     // return 0：成功 ); /**  * type参数  * PCAP_SRC_FILE：文件接口  * PCAP_SRC_IFLOCAL：本地接口  * PCAP_SRC_IFREMOTE：远程接口，必须基于RPCAP协议  */  pcap_t* pcap_open_offline(     const char* filename,  // 文件名     char* errbuf  // 错误信息缓冲区     // return 文件接口描述符 );Demo8：发送数据包发送单个数据包pcap_sendpacket：发送单个数据包 int pcap_sendpacket(     pcap_t* handle,  // 打开接口描述符      const u_char* packet,  // 数据包，包含首部信息     int packet_len  // 包大小，单位B     // return 0：成功 );发送队列使用发送队列，发送队列相关函数  pcap_sendqueue_alloc：创建指定大小的发送队列  pcap_sendqueue_queue：将包添加到发送队列  pcap_sendqueue_transmit：传输发送队列  pcap_sendqueue_destroy：销毁发送队列 pcap_send_queue* pcap_sendqueue_alloc(     u_int memsize  // 发送队列大小，单位B     // return 队列对象 );  int pcap_sendqueue_queue(     pcap_send_queue* queue,  // 发送队列对象     const struct pcap_pkthdr *pkt_header,  // 包header     const u_char *pkt_data  // 包内容     // return 0：成功，-1：失败 );  u_int pcap_sendqueue_transmit(     pcap_t* p,  // 发送接口描述符     pcap_send_queue* queue,  // 发送队列     int sync  // 是否同步发送     // return 成功发送的字节数 );Demo9：收集并统计网络流量pcap_setmode：设置接口为统计模式 int pcap_setmode(     pcap_t* p,  // 接口描述符     int mode  // 模式     // return 0：成功，-1：失败 ); /**  * mode参数  * MODE_CAPT：捕获模式，仅捕获数据包  * MODE_STAT：统计模式，获取统计信息  * MODE_MON：监视模式，接口设置为混杂模式  */开始捕获后，pkt_header和pkt_data为统计信息，具体如下所示      pkt_header中包含ts时间戳，成功捕获长度为包内容大小(统计信息)，pkt_data共16B        pkt_data中前8B为AcceptedPackets已捕获的数据包数量，后8B为AcceptedBytes已捕获字节数    *((LONGLONG*)pkt_data)获取AcceptedPackets数值    *((LONGLONG*)(pkt_data + 8))获取AcceptedBytes数值  补充：LARGE_INTEGER类型LARGE_INTEGER可表示一个64位符号数，定义如下typedef union _LARGE_INTEGER {  __C89_NAMELESS struct {    DWORD LowPart;    LONG HighPart;  } DUMMYSTRUCTNAME;  struct {    DWORD LowPart;    LONG HighPart;  } u;  LONGLONG QuadPart;} LARGE_INTEGER;LowPart存储64位数的低32位，HighPart存储64位数的低32位，当编译器不支持64位数时，LARGE_INTEGER通过LowPart和HighPart表示一个64位数，当支持64位数时，LARGE_INTEGER等价于LONGLONG(aka. __int64, long long)，可直接使用QuadPart"
  }
  
]

