---
layout: post
title: Kotlin基础——泛型与委托
category: Kotlin
tags: Kotlin Android
typora-root-url: "./.."
date: 2024-03-09 21:19 +0800
---
## 泛型

泛型类

```kotlin
class MyClass<T> {
    fun method(t: T): T
}
```

泛型函数

```kotlin
fun <T> method(t: T): T {
    // statements
}
```

### 泛型约束

用于约束泛型参数的上界，类似java的extends，默认的上界是`Any?`

``` kotlin
class Person<T : String>
```

当类型需要多个上界时，使用where语句，T类型必须同时继承/实现A类型和B类型

``` kotlin
class Person<T> where T : A, T : B
```

### 类型擦除

在Java和Kotlin中都有类型擦除，指的是在使用泛型时，泛型参数会在编译期间去除，也就是`List<T>`的泛型参数T会被擦除，`List<T>`就变成List，类中使用到泛型参数的地方都会被赋予类型

随之带来一个问题，就是无法在运行时判断泛型参数的类型（Kotlin可以通过reified关键字实现），同时无法描述泛型参数的类型关系，其中一个例子是`List<Object>`不是`List<String>`的父类，这样的现象称为不变

### 协变与逆变

协变和逆变用于解决不变问题，二者统称为型变

协变和逆变通常用在**函数参数和返回值的类型声明**上，用于扩展容器输入和输出的类型范围，并不能进行实际地转换，如果要实现类型转换，只能创建新对象，手动进行转换

星投影：类似java的泛型通配符`?`，用于接收不确定的泛型信息，只能读取值（向外输出值），相当于`<out Any?>`

-   Java实现：使用extends实现协变，使用super实现逆变，只支持**使用处型变**

    ```java
    interface Collection<T> {
        // 协变：向下扩展类型范围，只能安全读取，确保读取的都是T的子类
        Collection<? extends T> method1();
        void method2(Collection<? extends T> c);
        
        // 逆变：向上扩展类型范围，只能安全写入，确保写入的都是T的子类
        Collection<? super T> method3();
        void method4(Collection<? super T> c);
    }
    ```

-   Kotlin实现：使用out实现协变，使用in实现逆变，支持**声明处型变**

    ```kotlin
    // 使用处型变
    interface Collection<T> {
        // 协变
        fun method1(): Collection<out T>;
        fun method2(c: Collection<out T>);
        
        // 逆变
        fun method3(): Collection<in T>;
        fun method4(c: Collection<in T>);
    }
    
    // 声明处型变
    interface Collection<out T> {
        // T只支持协变
        fun method1(): Collection<T>;
        fun method2(c: Collection<T>);
    }
    interface Collection<in T> {
        // T只支持逆变
        fun method3(): Collection<in T>;
        fun method4(c: Collection<in T>);
    }
    ```

### 协变逆变原理

核心原理为一个**父类引用可以无障碍地接收一个子类对象**，协变和逆变都是基于这一点实现的

容器泛型使用协变还是逆变，与它作为形参还是返回值是**无关的**，要看该容器的值的**使用场景**

-   当容器在**消费场景**时，容器需要被读取，因此外部需要使用一个父类引用接收读取值，因此容器泛型使用协变声明，确保容器内的值都是外部声明类型的子类，可以安全接收
-   当容器在**生产场景**时，容器需要被写入，因此容器内需要使用一个父类引用接收写入值，因此容器泛型使用逆变声明，确保写入值都是容器声明类型的子类，可以安全写入

## 委托

委托模式是将一个对象的职责委托给其他对象完成，kotlin委托通过by关键字实现

### 类委托

将类中的方法委托到被委托对象实现

``` kotlin
interface Method {
    fun method()
}

class MethodImpl : Method {
    override fun method() {
        // statement
    }
}
// 委托类与被委托类实现同一接口
class Person(method: Method) : Method by method {
    // 委托类中自动生成了接口中的方法，并将调用转发给被委托对象
    
    // 当委托类重写了接口方法时，调用委托类重写的方法
    override fun method() {
        // statement
    }
}
```

### 属性委托

在属性后使用by关键字加一个表达式，表达式返回被委托对象，将属性的定义委托给该对象管理

属性的getter和setter被委托给这个对象的getValue和setValue方法(val属性只需提供getValue方法)

``` kotlin
class Person {
    var name: String by Delegate()
}

class Delegate : ReadWriteProperty<Person, String> {
    override operator fun getValue(thisRef: Any?, property: KProperty<*>): String {
        return "$thisRef, 这里委托了 ${property.name} 属性"
    }

    override operator fun setValue(thisRef: Any?, property: KProperty<*>, value: String) {
        println("$thisRef 的 ${property.name} 属性赋值为 $value")
    }
}
```

by-lazy延迟初始化是调用了lazy函数，lazy函数传入一个闭包，返回一个Lazy对象，属性定义由Lazy对象管理

Lazy对象只实现了getValue方法，因此通常用于val属性的延迟初始化

将属性委托到映射

``` kotlin
// Map为只读map
class Person(val map: Map<String, Any?>) {
    val name: String by map
    val age: Int by map
}
// MutableMap为可变map
class Student(val map: MutableMap<String, Any?>) {
    var name: String by map
    var age: Int by map
}
```

#### 可观察属性

kotlin的Delegates类的observable方法可以实现属性的观察者，observable方法传入一个初始值和一个观察者处理器闭包

``` kotlin
import kotlin.properties.Delegates

class Person {
    var name: String by Delegates.observable("initValue") {
        property, oldValue, newValue -> 
        // statement
    }
}
```

#### Delegates.notNull

用于对一个非空var属性进行延迟初始化

lateinit不支持原始类型，Delegates.notNull支持所有非空类型

当属性委托给notNull后，若未进行初始化直接访问会抛出异常

``` kotlin
import kotlin.properties.Delegates

class Person {
   	var age: Int by Delegates.notNull<Int>()
}
```

#### 自定义委托

创建一个类作为被委托类，对于val属性，需要实现getValue操作符，对于var属性，需要实现setValue和getValue操作符

-   当属性为var时，被委托对象继承ReadWriteProperty，重写setValue和getValue
-   当属性为val时，被委托对象继承ReadOnlyProperty，重写getValue

``` kotlin
class Delegate : ReadWriteProperty<Person, String> {
    // thisRef：委托对象的引用，类型可以是委托对象类型或其父类型
    // property：KProperty类型，存储属性的元数据
    // 返回值：返回属性对应类型或其子类型
    override operator fun getValue(thisRef: Person, property: KProperty<*>): String {
        return "$thisRef, 这里委托了 ${property.name} 属性"
    }
	// value：新值，必须是属性对应类型或其父类型
    override operator fun setValue(thisRef: Person, property: KProperty<*>, value: String) {
        println("$thisRef 的 ${property.name} 属性赋值为 $value")
    }
}
```

#### provideDelegate

用于定义创建被委托对象时的逻辑

通过provider委托时，优先调用provideDelegate，再调用getValue/setValue

``` kotlin
class Person {
    var name: String by DelegateProvider()
}

class Delegate : ReadWriteProperty<Person, String> {
    override operator fun getValue(thisRef: Person, property: KProperty<*>): String {
        return ""
    }

    override operator fun setValue(thisRef: Person, property: KProperty<*>, value: String) {
        // statement
    }
}
// 委托提供者
class DelegateProvider {
    operator fun provideDelegate(person: Person, property: KProperty<*>) : ReadWriteProperty<Person, String> {
        // statement
        return Delegate() // 返回一个委托对象
    }
}
```
